@startuml
left to right direction
namespace abi {
    class ContainerEngine << (S,Aquamarine) >> {
        + Libpod *libpod.Runtime

        + KubeApply(ctx context.Context, body io.Reader, options entities.ApplyOptions) error
        + ContainerCopyFromArchive(ctx context.Context, nameOrID string, containerPath string, reader io.Reader, options entities.CopyOptions) (entities.ContainerCopyFunc, error)
        + ContainerCopyToArchive(ctx context.Context, nameOrID string, containerPath string, writer io.Writer) (entities.ContainerCopyFunc, error)
        + AutoUpdate(ctx context.Context, options entities.AutoUpdateOptions) ([]*entities.AutoUpdateReport, []error)
        + ContainerExists(ctx context.Context, nameOrID string, options entities.ContainerExistsOptions) (*entities.BoolReport, error)
        + ContainerWait(ctx context.Context, namesOrIds []string, options entities.WaitOptions) ([]entities.WaitReport, error)
        + ContainerPause(ctx context.Context, namesOrIds []string, options entities.PauseUnPauseOptions) ([]*entities.PauseUnpauseReport, error)
        + ContainerUnpause(ctx context.Context, namesOrIds []string, options entities.PauseUnPauseOptions) ([]*entities.PauseUnpauseReport, error)
        + ContainerStop(ctx context.Context, namesOrIds []string, options entities.StopOptions) ([]*entities.StopReport, error)
        + ContainerPrune(ctx context.Context, options entities.ContainerPruneOptions) ([]*reports.PruneReport, error)
        + ContainerKill(ctx context.Context, namesOrIds []string, options entities.KillOptions) ([]*entities.KillReport, error)
        + ContainerRestart(ctx context.Context, namesOrIds []string, options entities.RestartOptions) ([]*entities.RestartReport, error)
        + ContainerRm(ctx context.Context, namesOrIds []string, options entities.RmOptions) ([]*reports.RmReport, error)
        + ContainerInspect(ctx context.Context, namesOrIds []string, options entities.InspectOptions) ([]*entities.ContainerInspectReport, []error, error)
        + ContainerTop(ctx context.Context, options entities.TopOptions) (*entities.StringSliceReport, error)
        + ContainerCommit(ctx context.Context, nameOrID string, options entities.CommitOptions) (*entities.CommitReport, error)
        + ContainerExport(ctx context.Context, nameOrID string, options entities.ContainerExportOptions) error
        + ContainerCheckpoint(ctx context.Context, namesOrIds []string, options entities.CheckpointOptions) ([]*entities.CheckpointReport, error)
        + ContainerRestore(ctx context.Context, namesOrIds []string, options entities.RestoreOptions) ([]*entities.RestoreReport, error)
        + ContainerCreate(ctx context.Context, s *specgen.SpecGenerator) (*entities.ContainerCreateReport, error)
        + ContainerAttach(ctx context.Context, nameOrID string, options entities.AttachOptions) error
        + ContainerExec(ctx context.Context, nameOrID string, options entities.ExecOptions, streams define.AttachStreams) (int, error)
        + ContainerExecDetached(ctx context.Context, nameOrID string, options entities.ExecOptions) (string, error)
        + ContainerStart(ctx context.Context, namesOrIds []string, options entities.ContainerStartOptions) ([]*entities.ContainerStartReport, error)
        + ContainerList(ctx context.Context, options entities.ContainerListOptions) ([]entities.ListContainer, error)
        + ContainerListExternal(ctx context.Context) ([]entities.ListContainer, error)
        + Diff(ctx context.Context, namesOrIDs []string, opts entities.DiffOptions) (*entities.DiffReport, error)
        + ContainerRun(ctx context.Context, opts entities.ContainerRunOptions) (*entities.ContainerRunReport, error)
        + ContainerWaitForExitCode(ctx context.Context, ctr *libpod.Container) (int, error)
        + ContainerLogs(ctx context.Context, namesOrIds []string, options entities.ContainerLogsOptions) error
        + ContainerCleanup(ctx context.Context, namesOrIds []string, options entities.ContainerCleanupOptions) ([]*entities.ContainerCleanupReport, error)
        + ContainerInit(ctx context.Context, namesOrIds []string, options entities.ContainerInitOptions) ([]*entities.ContainerInitReport, error)
        + ContainerMount(ctx context.Context, nameOrIDs []string, options entities.ContainerMountOptions) ([]*entities.ContainerMountReport, error)
        + ContainerUnmount(ctx context.Context, nameOrIDs []string, options entities.ContainerUnmountOptions) ([]*entities.ContainerUnmountReport, error)
        + Config(_ context.Context) (*config.Config, error)
        + ContainerPort(ctx context.Context, nameOrID string, options entities.ContainerPortOptions) ([]*entities.ContainerPortReport, error)
        + Shutdown(_ context.Context) 
        + ContainerStats(ctx context.Context, namesOrIds []string, options entities.ContainerStatsOptions) (<font color=blue>chan</font> entities.ContainerStatsReport, error)
        + ShouldRestart(ctx context.Context, nameOrID string) (*entities.BoolReport, error)
        + ContainerRename(ctx context.Context, nameOrID string, opts entities.ContainerRenameOptions) error
        + ContainerClone(ctx context.Context, ctrCloneOpts entities.ContainerCloneOptions) (*entities.ContainerCreateReport, error)
        + ContainerUpdate(ctx context.Context, updateOptions *entities.ContainerUpdateOptions) (string, error)
        + ContainerRunlabel(ctx context.Context, label string, imageRef string, args []string, options entities.ContainerRunlabelOptions) error
        + ContainerStat(ctx context.Context, nameOrID string, containerPath string) (*entities.ContainerStatReport, error)
        + Events(ctx context.Context, opts entities.EventsOptions) error
        + GenerateSystemd(ctx context.Context, nameOrID string, options entities.GenerateSystemdOptions) (*entities.GenerateSystemdReport, error)
        + GenerateSpec(ctx context.Context, opts *entities.GenerateSpecOptions) (*entities.GenerateSpecReport, error)
        + GenerateKube(ctx context.Context, nameOrIDs []string, options entities.GenerateKubeOptions) (*entities.GenerateKubeReport, error)
        + HealthCheckRun(ctx context.Context, nameOrID string, options entities.HealthCheckOptions) (*define.HealthCheckResults, error)
        + NetworkUpdate(ctx context.Context, netName string, options entities.NetworkUpdateOptions) error
        + NetworkList(ctx context.Context, options entities.NetworkListOptions) ([]types.Network, error)
        + NetworkInspect(ctx context.Context, namesOrIds []string, options entities.InspectOptions) ([]entities.NetworkInspectReport, []error, error)
        + NetworkReload(ctx context.Context, names []string, options entities.NetworkReloadOptions) ([]*entities.NetworkReloadReport, error)
        + NetworkRm(ctx context.Context, namesOrIds []string, options entities.NetworkRmOptions) ([]*entities.NetworkRmReport, error)
        + NetworkCreate(ctx context.Context, network types.Network, createOptions *types.NetworkCreateOptions) (*types.Network, error)
        + NetworkDisconnect(ctx context.Context, networkname string, options entities.NetworkDisconnectOptions) error
        + NetworkConnect(ctx context.Context, networkname string, options entities.NetworkConnectOptions) error
        + NetworkExists(ctx context.Context, networkname string) (*entities.BoolReport, error)
        + NetworkPrune(ctx context.Context, options entities.NetworkPruneOptions) ([]*entities.NetworkPruneReport, error)
        + GetContainerNetStatuses() ([]ContainerNetStatus, error)
        + PlayKube(ctx context.Context, body io.Reader, options entities.PlayKubeOptions) (*entities.PlayKubeReport, error)
        + PlayKubeDown(ctx context.Context, body io.Reader, options entities.PlayKubeDownOptions) (*entities.PlayKubeReport, error)
        + PodExists(ctx context.Context, nameOrID string) (*entities.BoolReport, error)
        + PodKill(ctx context.Context, namesOrIds []string, options entities.PodKillOptions) ([]*entities.PodKillReport, error)
        + PodLogs(ctx context.Context, nameOrID string, options entities.PodLogsOptions) error
        + PodPause(ctx context.Context, namesOrIds []string, options entities.PodPauseOptions) ([]*entities.PodPauseReport, error)
        + PodUnpause(ctx context.Context, namesOrIds []string, options entities.PodunpauseOptions) ([]*entities.PodUnpauseReport, error)
        + PodStop(ctx context.Context, namesOrIds []string, options entities.PodStopOptions) ([]*entities.PodStopReport, error)
        + PodRestart(ctx context.Context, namesOrIds []string, options entities.PodRestartOptions) ([]*entities.PodRestartReport, error)
        + PodStart(ctx context.Context, namesOrIds []string, options entities.PodStartOptions) ([]*entities.PodStartReport, error)
        + PodRm(ctx context.Context, namesOrIds []string, options entities.PodRmOptions) ([]*entities.PodRmReport, error)
        + PodPrune(ctx context.Context, options entities.PodPruneOptions) ([]*entities.PodPruneReport, error)
        + PodCreate(ctx context.Context, specg entities.PodSpec) (*entities.PodCreateReport, error)
        + PodClone(ctx context.Context, podClone entities.PodCloneOptions) (*entities.PodCloneReport, error)
        + PodTop(ctx context.Context, options entities.PodTopOptions) (*entities.StringSliceReport, error)
        + PodPs(ctx context.Context, options entities.PodPSOptions) ([]*entities.ListPodsReport, error)
        + PodInspect(ctx context.Context, nameOrIDs []string, options entities.InspectOptions) ([]*entities.PodInspectReport, []error, error)
        + PodStats(ctx context.Context, namesOrIds []string, options entities.PodStatsOptions) ([]*entities.PodStatsReport, error)
        + SecretCreate(ctx context.Context, name string, reader io.Reader, options entities.SecretCreateOptions) (*entities.SecretCreateReport, error)
        + SecretInspect(ctx context.Context, nameOrIDs []string, options entities.SecretInspectOptions) ([]*entities.SecretInfoReport, []error, error)
        + SecretList(ctx context.Context, opts entities.SecretListRequest) ([]*entities.SecretInfoReport, error)
        + SecretRm(ctx context.Context, nameOrIDs []string, options entities.SecretRmOptions) ([]*entities.SecretRmReport, error)
        + SecretExists(ctx context.Context, nameOrID string) (*entities.BoolReport, error)
        + Info(ctx context.Context) (*define.Info, error)
        + SystemPrune(ctx context.Context, options entities.SystemPruneOptions) (*entities.SystemPruneReport, error)
        + SystemDf(ctx context.Context, options entities.SystemDfOptions) (*entities.SystemDfReport, error)
        + Reset(ctx context.Context) error
        + Renumber(ctx context.Context) error
        + Migrate(ctx context.Context, options entities.SystemMigrateOptions) error
        + Unshare(ctx context.Context, args []string, options entities.SystemUnshareOptions) error
        + Version(ctx context.Context) (*entities.SystemVersionReport, error)
        + Locks(ctx context.Context) (*entities.LocksReport, error)
        + SystemCheck(ctx context.Context, options entities.SystemCheckOptions) (*entities.SystemCheckReport, error)
        + SetupRootless(_ context.Context, noMoveProcess bool, cgroupMode string) error
        + SetupRootless(_ context.Context, noMoveProcess bool, cgroupMode string) error
        + VolumeCreate(ctx context.Context, opts entities.VolumeCreateOptions) (*entities.IDOrNameResponse, error)
        + VolumeRm(ctx context.Context, namesOrIds []string, opts entities.VolumeRmOptions) ([]*entities.VolumeRmReport, error)
        + VolumeInspect(ctx context.Context, namesOrIds []string, opts entities.InspectOptions) ([]*entities.VolumeInspectReport, []error, error)
        + VolumePrune(ctx context.Context, options entities.VolumePruneOptions) ([]*reports.PruneReport, error)
        + VolumeList(ctx context.Context, opts entities.VolumeListOptions) ([]*entities.VolumeListReport, error)
        + VolumeExists(ctx context.Context, nameOrID string) (*entities.BoolReport, error)
        + VolumeMounted(ctx context.Context, nameOrID string) (*entities.BoolReport, error)
        + VolumeMount(ctx context.Context, nameOrIDs []string) ([]*entities.VolumeMountReport, error)
        + VolumeUnmount(ctx context.Context, nameOrIDs []string) ([]*entities.VolumeUnmountReport, error)
        + VolumeReload(ctx context.Context) (*entities.VolumeReloadReport, error)

    }
    class ContainerNetStatus << (S,Aquamarine) >> {
        + Name string
        + ID string
        + Status <font color=blue>map</font>[string]types.StatusBlock

    }
    class FarmNode << (S,Aquamarine) >> {
    }
    class ImageEngine << (S,Aquamarine) >> {
        + Libpod *libpod.Runtime

        + ArtifactInspect(ctx context.Context, name string, _ entities.ArtifactInspectOptions) (*entities.ArtifactInspectReport, error)
        + ArtifactList(ctx context.Context, _ entities.ArtifactListOptions) ([]*entities.ArtifactListReport, error)
        + ArtifactPull(ctx context.Context, name string, opts entities.ArtifactPullOptions) (*entities.ArtifactPullReport, error)
        + ArtifactRm(ctx context.Context, name string, _ entities.ArtifactRemoveOptions) (*entities.ArtifactRemoveReport, error)
        + ArtifactPush(ctx context.Context, name string, opts entities.ArtifactPushOptions) (*entities.ArtifactPushReport, error)
        + ArtifactAdd(ctx context.Context, name string, paths []string, opts *entities.ArtifactAddOptions) (*entities.ArtifactAddReport, error)
        + FarmNodeName(ctx context.Context) string
        + FarmNodeDriver(ctx context.Context) string
        + FarmNodeInspect(ctx context.Context) (*entities.FarmInspectReport, error)
        + Exists(_ context.Context, nameOrID string) (*entities.BoolReport, error)
        + Prune(ctx context.Context, opts entities.ImagePruneOptions) ([]*reports.PruneReport, error)
        + History(ctx context.Context, nameOrID string, opts entities.ImageHistoryOptions) (*entities.ImageHistoryReport, error)
        + Mount(ctx context.Context, nameOrIDs []string, opts entities.ImageMountOptions) ([]*entities.ImageMountReport, error)
        + Unmount(ctx context.Context, nameOrIDs []string, options entities.ImageUnmountOptions) ([]*entities.ImageUnmountReport, error)
        + Pull(ctx context.Context, rawImage string, options entities.ImagePullOptions) (*entities.ImagePullReport, error)
        + Inspect(ctx context.Context, namesOrIDs []string, opts entities.InspectOptions) ([]*entities.ImageInspectReport, []error, error)
        + Push(ctx context.Context, source string, destination string, options entities.ImagePushOptions) (*entities.ImagePushReport, error)
        + Tag(ctx context.Context, nameOrID string, tags []string, options entities.ImageTagOptions) error
        + Untag(ctx context.Context, nameOrID string, tags []string, options entities.ImageUntagOptions) error
        + Load(ctx context.Context, options entities.ImageLoadOptions) (*entities.ImageLoadReport, error)
        + Save(ctx context.Context, nameOrID string, tags []string, options entities.ImageSaveOptions) error
        + Import(ctx context.Context, options entities.ImageImportOptions) (*entities.ImageImportReport, error)
        + Search(ctx context.Context, term string, opts entities.ImageSearchOptions) ([]entities.ImageSearchReport, error)
        + Config(_ context.Context) (*config.Config, error)
        + Build(ctx context.Context, containerFiles []string, opts entities.BuildOptions) (*entities.BuildReport, error)
        + Tree(ctx context.Context, nameOrID string, opts entities.ImageTreeOptions) (*entities.ImageTreeReport, error)
        + Remove(ctx context.Context, images []string, opts entities.ImageRemoveOptions) (*entities.ImageRemoveReport, []error)
        + Shutdown(_ context.Context) 
        + Sign(ctx context.Context, names []string, options entities.SignOptions) (*entities.SignReport, error)
        + Scp(ctx context.Context, src string, dst string, opts entities.ImageScpOptions) (*entities.ImageScpReport, error)
        + List(ctx context.Context, opts entities.ImageListOptions) ([]*entities.ImageSummary, error)
        + ManifestCreate(ctx context.Context, name string, images []string, opts entities.ManifestCreateOptions) (string, error)
        + ManifestExists(ctx context.Context, name string) (*entities.BoolReport, error)
        + ManifestInspect(ctx context.Context, name string, opts entities.ManifestInspectOptions) (*define.ManifestListData, error)
        + ManifestAdd(ctx context.Context, name string, images []string, opts entities.ManifestAddOptions) (string, error)
        + ManifestAnnotate(ctx context.Context, name string, image string, opts entities.ManifestAnnotateOptions) (string, error)
        + ManifestAddArtifact(ctx context.Context, name string, files []string, opts entities.ManifestAddArtifactOptions) (string, error)
        + ManifestRemoveDigest(ctx context.Context, name string, image string) (string, error)
        + ManifestRm(ctx context.Context, names []string, opts entities.ImageRemoveOptions) (*entities.ImageRemoveReport, []error)
        + ManifestPush(ctx context.Context, name string, destination string, opts entities.ImagePushOptions) (string, error)
        + ManifestListClear(ctx context.Context, name string) (string, error)
        + ShowTrust(ctx context.Context, args []string, options entities.ShowTrustOptions) (*entities.ShowTrustReport, error)
        + SetTrust(ctx context.Context, args []string, options entities.SetTrustOptions) error

    }
    class SystemEngine << (S,Aquamarine) >> {
        + Libpod *libpod.Runtime

        + Shutdown(ctx context.Context) 

    }
    class TestingEngine << (S,Aquamarine) >> {
        + Libpod *libpod.Runtime
        + Store storage.Store

        + CreateStorageLayer(ctx context.Context, opts entities.CreateStorageLayerOptions) (*entities.CreateStorageLayerReport, error)
        + CreateLayer(ctx context.Context, opts entities.CreateLayerOptions) (*entities.CreateLayerReport, error)
        + CreateLayerData(ctx context.Context, opts entities.CreateLayerDataOptions) (*entities.CreateLayerDataReport, error)
        + ModifyLayer(ctx context.Context, opts entities.ModifyLayerOptions) (*entities.ModifyLayerReport, error)
        + PopulateLayer(ctx context.Context, opts entities.PopulateLayerOptions) (*entities.PopulateLayerReport, error)
        + CreateImage(ctx context.Context, opts entities.CreateImageOptions) (*entities.CreateImageReport, error)
        + CreateImageData(ctx context.Context, opts entities.CreateImageDataOptions) (*entities.CreateImageDataReport, error)
        + CreateContainer(ctx context.Context, opts entities.CreateContainerOptions) (*entities.CreateContainerReport, error)
        + CreateContainerData(ctx context.Context, opts entities.CreateContainerDataOptions) (*entities.CreateContainerDataReport, error)
        + RemoveStorageLayer(ctx context.Context, opts entities.RemoveStorageLayerOptions) (*entities.RemoveStorageLayerReport, error)
        + RemoveLayer(ctx context.Context, opts entities.RemoveLayerOptions) (*entities.RemoveLayerReport, error)
        + RemoveImage(ctx context.Context, opts entities.RemoveImageOptions) (*entities.RemoveImageReport, error)
        + RemoveContainer(ctx context.Context, opts entities.RemoveContainerOptions) (*entities.RemoveContainerReport, error)
        + RemoveLayerData(ctx context.Context, opts entities.RemoveLayerDataOptions) (*entities.RemoveLayerDataReport, error)
        + RemoveImageData(ctx context.Context, opts entities.RemoveImageDataOptions) (*entities.RemoveImageDataReport, error)
        + RemoveContainerData(ctx context.Context, opts entities.RemoveContainerDataOptions) (*entities.RemoveContainerDataReport, error)
        + ModifyLayerData(ctx context.Context, opts entities.ModifyLayerDataOptions) (*entities.ModifyLayerDataReport, error)
        + ModifyImageData(ctx context.Context, opts entities.ModifyImageDataOptions) (*entities.ModifyImageDataReport, error)
        + ModifyContainerData(ctx context.Context, opts entities.ModifyContainerDataOptions) (*entities.ModifyContainerDataReport, error)

    }
    class containerWrapper << (S,Aquamarine) >> {
    }
    class getContainersOptions << (S,Aquamarine) >> {
    }
}
"abi.FarmNode" *-- "extends""abi.ImageEngine"
"libpod.Container" *-- "extends""abi.containerWrapper"

"entities.ContainerEngine" <|-- "implements""abi.ContainerEngine"
"entities.ImageEngine" <|-- "implements""abi.ImageEngine"
"entities.TestingEngine" <|-- "implements""abi.TestingEngine"

namespace applehv {
    class AppleHVStubber << (S,Aquamarine) >> {
        + Remove(mc *vmconfigs.MachineConfig) ([]string, <font color=blue>func</font>() error, error)
        + State(mc *vmconfigs.MachineConfig, _ bool) (define.Status, error)
        + StopVM(mc *vmconfigs.MachineConfig, _ bool) error
        + UserModeNetworkEnabled(_ *vmconfigs.MachineConfig) bool
        + UseProviderNetworkSetup() bool
        + RequireExclusiveActive() bool
        + CreateVM(opts define.CreateVMOpts, mc *vmconfigs.MachineConfig, ignBuilder *ignition.IgnitionBuilder) error
        + Exists(name string) (bool, error)
        + MountType() vmconfigs.VolumeMountType
        + MountVolumesToVM(_ *vmconfigs.MachineConfig, _ bool) error
        + RemoveAndCleanMachines(_ *define.MachineDirs) error
        + SetProviderAttrs(mc *vmconfigs.MachineConfig, opts define.SetOptions) error
        + StartNetworking(mc *vmconfigs.MachineConfig, cmd *types.GvproxyCommand) error
        + StartVM(mc *vmconfigs.MachineConfig) (<font color=blue>func</font>() error, <font color=blue>func</font>() error, error)
        + StopHostNetworking(_ *vmconfigs.MachineConfig, _ define.VMType) error
        + UpdateSSHPort(mc *vmconfigs.MachineConfig, port int) error
        + VMType() define.VMType
        + PrepareIgnition(_ *vmconfigs.MachineConfig, _ *ignition.IgnitionBuilder) (*ignition.ReadyUnitOpts, error)
        + PostStartNetworking(mc *vmconfigs.MachineConfig, noInfo bool) error
        + GetRosetta(mc *vmconfigs.MachineConfig) (bool, error)

    }
}
"vmconfigs.AppleHVConfig" *-- "extends""applehv.AppleHVStubber"

"vmconfigs.VMProvider" <|-- "implements""applehv.AppleHVStubber"

namespace artifact {
    class artifactAddOptions << (S,Aquamarine) >> {
        + ArtifactType string
        + Annotations []string

    }
    class artifactListOutput << (S,Aquamarine) >> {
        + Digest string
        + Repository string
        + Size string
        + Tag string

    }
    class listFlagType << (S,Aquamarine) >> {
    }
    class pullOptionsWrapper << (S,Aquamarine) >> {
        + TLSVerifyCLI bool
        + CredentialsCLI string
        + DecryptionKeys []string

    }
    class pushOptionsWrapper << (S,Aquamarine) >> {
        + TLSVerifyCLI bool
        + CredentialsCLI string
        + SignPassphraseFileCLI string
        + SignBySigstoreParamFileCLI string
        + EncryptionKeys []string
        + EncryptLayers []int
        + DigestFile string

    }
    class rmFlagType << (S,Aquamarine) >> {
    }
}
"entities.ArtifactPullOptions" *-- "extends""artifact.pullOptionsWrapper"
"entities.ArtifactPushOptions" *-- "extends""artifact.pushOptionsWrapper"


namespace autoupdate {
    class autoupdate.Policy << (T, #FF7700) >>  {
    }
    class task << (S,Aquamarine) >> {
    }
    class updater << (S,Aquamarine) >> {
    }
}


namespace bindings {
    class APIResponse << (S,Aquamarine) >> {
        + Request *http.Request

        + IsInformational() bool
        + IsSuccess() bool
        + IsRedirection() bool
        + IsClientError() bool
        + IsConflictError() bool
        + IsServerError() bool
        + Process(unmarshalInto <font color=blue>interface</font>{}) error
        + ProcessWithError(unmarshalInto <font color=blue>interface</font>{}, unmarshalErrorInto <font color=blue>interface</font>{}) error

    }
    class APIVersionError << (S,Aquamarine) >> {
        + Error() string

    }
    class ConnectError << (S,Aquamarine) >> {
        + Err error

        + Error() string
        + Unwrap() error

    }
    class Connection << (S,Aquamarine) >> {
        + URI *url.URL
        + Client *http.Client

        + DoRequest(ctx context.Context, httpBody io.Reader, httpMethod string, endpoint string, queryParams url.Values, headers http.Header, pathValues ...string) (*APIResponse, error)
        + GetDialer(ctx context.Context) (net.Conn, error)

    }
    class bindings.valueKey << (T, #FF7700) >>  {
    }
}
"http.Response" *-- "extends""bindings.APIResponse"


namespace channel {
    interface WriteCloser  {
        + Chan() <font color=blue>chan</font> []byte

    }
    class writeCloser << (S,Aquamarine) >> {
        + Chan() <font color=blue>chan</font> []byte
        + Write(b []byte) (int, error)
        + Close() error

    }
}

"channel.WriteCloser" <|-- "implements""channel.writeCloser"

namespace command {
    class Monitor << (S,Aquamarine) >> {
        + Address define.VMFile
        + Network string
        + Timeout time.Duration

    }
    class QemuCmd << (S,Aquamarine) >> {
        + SetCPUs(c uint64) 
        + SetIgnitionFile(file define.VMFile) 
        + SetQmpMonitor(monitor Monitor) 
        + SetNetwork(vlanSocket *define.VMFile) error
        + SetUSBHostPassthrough(usbs []define.USBConfig) 
        + SetSerialPort(readySocket define.VMFile, vmPidFile define.VMFile, name string) 
        + SetBootableImage(image string) 
        + SetDisplay(display string) 
        + Build() []string
        + SetMemory(m strongunits.MiB) 
        + SetMemory(m strongunits.MiB) 

    }
    class command.QemuCmd << (T, #FF7700) >>  {
    }
}


namespace common {
    class BuildFlagsWrapper << (S,Aquamarine) >> {
        + SquashAll bool
        + Cleanup bool

    }
    class common.completeType << (T, #FF7700) >>  {
    }
    class common.keyValueCompletion << (T, #FF7700) >>  {
    }
    class formatSuggestion << (S,Aquamarine) >> {
    }
    class signingCleanup << (S,Aquamarine) >> {
    }
    class "<font color=blue>map</font>[string]<font color=blue>func</font>(string) ([]string, cobra.ShellCompDirective)" as fontcolorbluemapfontstringfontcolorbluefuncfontstringstringcobraShellCompDirective {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"cli.BudResults" *-- "extends""common.BuildFlagsWrapper"
"cli.FromAndBudResults" *-- "extends""common.BuildFlagsWrapper"
"cli.LayerResults" *-- "extends""common.BuildFlagsWrapper"
"cli.NameSpaceResults" *-- "extends""common.BuildFlagsWrapper"
"cli.UserNSResults" *-- "extends""common.BuildFlagsWrapper"


namespace compat {
    class CPUStats << (S,Aquamarine) >> {
        + CPUUsage container.CPUUsage
        + SystemUsage uint64
        + OnlineCPUs uint32
        + CPU float64
        + ThrottlingData container.ThrottlingData

    }
    class DockerStatsJSON << (S,Aquamarine) >> {
        + Name string
        + ID string
        + Networks <font color=blue>map</font>[string]container.NetworkStats

    }
    class Stats << (S,Aquamarine) >> {
        + Read time.Time
        + PreRead time.Time
        + PidsStats container.PidsStats
        + BlkioStats container.BlkioStats
        + NumProcs uint32
        + StorageStats container.StorageStats
        + CPUStats CPUStats
        + PreCPUStats CPUStats
        + MemoryStats container.MemoryStats

    }
    class StatsJSON << (S,Aquamarine) >> {
        + Name string
        + ID string
        + Networks <font color=blue>map</font>[string]container.NetworkStats

    }
}
"compat.Stats" *-- "extends""compat.DockerStatsJSON"
"compat.Stats" *-- "extends""compat.StatsJSON"


namespace compression {
    class ImageCompression << (S,Aquamarine) >> {
        + String() string

    }
    interface WriteSeekCloser  {
    }
    class compression.ImageCompression << (T, #FF7700) >>  {
    }
    interface decompressor  {
    }
    class genericDecompressor << (S,Aquamarine) >> {
    }
    class sparseWriter << (S,Aquamarine) >> {
        + Write(data []byte) (int, error)
        + Close() error

    }
    class uncompressedDecompressor << (S,Aquamarine) >> {
    }
    class zipDecompressor << (S,Aquamarine) >> {
    }
}
"compression.genericDecompressor" *-- "extends""compression.uncompressedDecompressor"
"compression.genericDecompressor" *-- "extends""compression.zipDecompressor"


namespace connection {
    class connection << (S,Aquamarine) >> {
    }
}


namespace containers {
    class AttachOptions << (S,Aquamarine) >> {
        + DetachKeys *string
        + Logs *bool
        + Stream *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithDetachKeys(value string) *AttachOptions
        + GetDetachKeys() string
        + WithLogs(value bool) *AttachOptions
        + GetLogs() bool
        + WithStream(value bool) *AttachOptions
        + GetStream() bool

    }
    class CheckpointOptions << (S,Aquamarine) >> {
        + Export *string
        + CreateImage *string
        + IgnoreRootfs *bool
        + Keep *bool
        + LeaveRunning *bool
        + TCPEstablished *bool
        + PrintStats *bool
        + PreCheckpoint *bool
        + WithPrevious *bool
        + FileLocks *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithExport(value string) *CheckpointOptions
        + GetExport() string
        + WithCreateImage(value string) *CheckpointOptions
        + GetCreateImage() string
        + WithIgnoreRootfs(value bool) *CheckpointOptions
        + GetIgnoreRootfs() bool
        + WithKeep(value bool) *CheckpointOptions
        + GetKeep() bool
        + WithLeaveRunning(value bool) *CheckpointOptions
        + GetLeaveRunning() bool
        + WithTCPEstablished(value bool) *CheckpointOptions
        + GetTCPEstablished() bool
        + WithPrintStats(value bool) *CheckpointOptions
        + GetPrintStats() bool
        + WithPreCheckpoint(value bool) *CheckpointOptions
        + GetPreCheckpoint() bool
        + WithWithPrevious(value bool) *CheckpointOptions
        + GetWithPrevious() bool
        + WithFileLocks(value bool) *CheckpointOptions
        + GetFileLocks() bool

    }
    interface CloseWriter  {
        + CloseWrite() error

    }
    class CommitOptions << (S,Aquamarine) >> {
        + Author *string
        + Changes []string
        + Config *io.Reader
        + Comment *string
        + Format *string
        + Pause *bool
        + Stream *bool
        + Squash *bool
        + Repo *string
        + Tag *string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAuthor(value string) *CommitOptions
        + GetAuthor() string
        + WithChanges(value []string) *CommitOptions
        + GetChanges() []string
        + WithConfig(value io.Reader) *CommitOptions
        + GetConfig() io.Reader
        + WithComment(value string) *CommitOptions
        + GetComment() string
        + WithFormat(value string) *CommitOptions
        + GetFormat() string
        + WithPause(value bool) *CommitOptions
        + GetPause() bool
        + WithStream(value bool) *CommitOptions
        + GetStream() bool
        + WithSquash(value bool) *CommitOptions
        + GetSquash() bool
        + WithRepo(value string) *CommitOptions
        + GetRepo() string
        + WithTag(value string) *CommitOptions
        + GetTag() string

    }
    class CopyOptions << (S,Aquamarine) >> {
        + Chown *bool
        + Rename <font color=blue>map</font>[string]string
        + NoOverwriteDirNonDir *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithChown(value bool) *CopyOptions
        + GetChown() bool
        + WithRename(value <font color=blue>map</font>[string]string) *CopyOptions
        + GetRename() <font color=blue>map</font>[string]string
        + WithNoOverwriteDirNonDir(value bool) *CopyOptions
        + GetNoOverwriteDirNonDir() bool

    }
    class CreateOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class DiffOptions << (S,Aquamarine) >> {
        + Parent *string
        + DiffType *string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithParent(value string) *DiffOptions
        + GetParent() string
        + WithDiffType(value string) *DiffOptions
        + GetDiffType() string

    }
    class ExecInspectOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class ExecRemoveOptions << (S,Aquamarine) >> {
        + Force *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithForce(value bool) *ExecRemoveOptions
        + GetForce() bool

    }
    class ExecStartAndAttachOptions << (S,Aquamarine) >> {
        + OutputStream *io.Writer
        + ErrorStream *io.Writer
        + InputStream *bufio.Reader
        + AttachOutput *bool
        + AttachError *bool
        + AttachInput *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithOutputStream(value io.Writer) *ExecStartAndAttachOptions
        + GetOutputStream() io.Writer
        + WithErrorStream(value io.Writer) *ExecStartAndAttachOptions
        + GetErrorStream() io.Writer
        + WithInputStream(value bufio.Reader) *ExecStartAndAttachOptions
        + GetInputStream() bufio.Reader
        + WithAttachOutput(value bool) *ExecStartAndAttachOptions
        + GetAttachOutput() bool
        + WithAttachError(value bool) *ExecStartAndAttachOptions
        + GetAttachError() bool
        + WithAttachInput(value bool) *ExecStartAndAttachOptions
        + GetAttachInput() bool

    }
    class ExecStartOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class ExistsOptions << (S,Aquamarine) >> {
        + External *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithExternal(value bool) *ExistsOptions
        + GetExternal() bool

    }
    class ExportOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class HealthCheckOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class InitOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class InspectOptions << (S,Aquamarine) >> {
        + Size *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithSize(value bool) *InspectOptions
        + GetSize() bool

    }
    class KillOptions << (S,Aquamarine) >> {
        + Signal *string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithSignal(value string) *KillOptions
        + GetSignal() string

    }
    class ListOptions << (S,Aquamarine) >> {
        + All *bool
        + External *bool
        + Filters <font color=blue>map</font>[string][]string
        + Last *int
        + Namespace *bool
        + Size *bool
        + Sync *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAll(value bool) *ListOptions
        + GetAll() bool
        + WithExternal(value bool) *ListOptions
        + GetExternal() bool
        + WithFilters(value <font color=blue>map</font>[string][]string) *ListOptions
        + GetFilters() <font color=blue>map</font>[string][]string
        + WithLast(value int) *ListOptions
        + GetLast() int
        + WithNamespace(value bool) *ListOptions
        + GetNamespace() bool
        + WithSize(value bool) *ListOptions
        + GetSize() bool
        + WithSync(value bool) *ListOptions
        + GetSync() bool

    }
    class LogOptions << (S,Aquamarine) >> {
        + Follow *bool
        + Since *string
        + Stderr *bool
        + Stdout *bool
        + Tail *string
        + Timestamps *bool
        + Until *string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithFollow(value bool) *LogOptions
        + GetFollow() bool
        + WithSince(value string) *LogOptions
        + GetSince() string
        + WithStderr(value bool) *LogOptions
        + GetStderr() bool
        + WithStdout(value bool) *LogOptions
        + GetStdout() bool
        + WithTail(value string) *LogOptions
        + GetTail() string
        + WithTimestamps(value bool) *LogOptions
        + GetTimestamps() bool
        + WithUntil(value string) *LogOptions
        + GetUntil() string

    }
    class MountOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class MountedContainerPathsOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class PauseOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class PruneOptions << (S,Aquamarine) >> {
        + Filters <font color=blue>map</font>[string][]string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithFilters(value <font color=blue>map</font>[string][]string) *PruneOptions
        + GetFilters() <font color=blue>map</font>[string][]string

    }
    class RemoveOptions << (S,Aquamarine) >> {
        + Depend *bool
        + Ignore *bool
        + Force *bool
        + Volumes *bool
        + Timeout *uint

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithDepend(value bool) *RemoveOptions
        + GetDepend() bool
        + WithIgnore(value bool) *RemoveOptions
        + GetIgnore() bool
        + WithForce(value bool) *RemoveOptions
        + GetForce() bool
        + WithVolumes(value bool) *RemoveOptions
        + GetVolumes() bool
        + WithTimeout(value uint) *RemoveOptions
        + GetTimeout() uint

    }
    class RenameOptions << (S,Aquamarine) >> {
        + Name *string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithName(value string) *RenameOptions
        + GetName() string

    }
    class ResizeExecTTYOptions << (S,Aquamarine) >> {
        + Height *int
        + Width *int

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithHeight(value int) *ResizeExecTTYOptions
        + GetHeight() int
        + WithWidth(value int) *ResizeExecTTYOptions
        + GetWidth() int

    }
    class ResizeTTYOptions << (S,Aquamarine) >> {
        + Height *int
        + Width *int
        + Running *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithHeight(value int) *ResizeTTYOptions
        + GetHeight() int
        + WithWidth(value int) *ResizeTTYOptions
        + GetWidth() int
        + WithRunning(value bool) *ResizeTTYOptions
        + GetRunning() bool

    }
    class RestartOptions << (S,Aquamarine) >> {
        + Timeout *int

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithTimeout(value int) *RestartOptions
        + GetTimeout() int

    }
    class RestoreOptions << (S,Aquamarine) >> {
        + IgnoreRootfs *bool
        + IgnoreVolumes *bool
        + IgnoreStaticIP *bool
        + IgnoreStaticMAC *bool
        + ImportAchive *string
        + ImportArchive *string
        + Keep *bool
        + Name *string
        + TCPEstablished *bool
        + Pod *string
        + PrintStats *bool
        + PublishPorts []string
        + FileLocks *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithIgnoreRootfs(value bool) *RestoreOptions
        + GetIgnoreRootfs() bool
        + WithIgnoreVolumes(value bool) *RestoreOptions
        + GetIgnoreVolumes() bool
        + WithIgnoreStaticIP(value bool) *RestoreOptions
        + GetIgnoreStaticIP() bool
        + WithIgnoreStaticMAC(value bool) *RestoreOptions
        + GetIgnoreStaticMAC() bool
        + WithImportAchive(value string) *RestoreOptions
        + GetImportAchive() string
        + WithImportArchive(value string) *RestoreOptions
        + GetImportArchive() string
        + WithKeep(value bool) *RestoreOptions
        + GetKeep() bool
        + WithName(value string) *RestoreOptions
        + GetName() string
        + WithTCPEstablished(value bool) *RestoreOptions
        + GetTCPEstablished() bool
        + WithPod(value string) *RestoreOptions
        + GetPod() string
        + WithPrintStats(value bool) *RestoreOptions
        + GetPrintStats() bool
        + WithPublishPorts(value []string) *RestoreOptions
        + GetPublishPorts() []string
        + WithFileLocks(value bool) *RestoreOptions
        + GetFileLocks() bool

    }
    class ShouldRestartOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class StartOptions << (S,Aquamarine) >> {
        + DetachKeys *string
        + Recursive *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithDetachKeys(value string) *StartOptions
        + GetDetachKeys() string
        + WithRecursive(value bool) *StartOptions
        + GetRecursive() bool

    }
    class StatsOptions << (S,Aquamarine) >> {
        + All *bool
        + Stream *bool
        + Interval *int

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAll(value bool) *StatsOptions
        + GetAll() bool
        + WithStream(value bool) *StatsOptions
        + GetStream() bool
        + WithInterval(value int) *StatsOptions
        + GetInterval() int

    }
    class StopOptions << (S,Aquamarine) >> {
        + Ignore *bool
        + Timeout *uint

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithIgnore(value bool) *StopOptions
        + GetIgnore() bool
        + WithTimeout(value uint) *StopOptions
        + GetTimeout() uint

    }
    class TopOptions << (S,Aquamarine) >> {
        + Descriptors *[]string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithDescriptors(value []string) *TopOptions
        + GetDescriptors() []string

    }
    class UnmountOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class UnpauseOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class WaitOptions << (S,Aquamarine) >> {
        + Conditions []string
        + Interval *string
        + Condition []define.ContainerStatus

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithConditions(value []string) *WaitOptions
        + GetConditions() []string
        + WithInterval(value string) *WaitOptions
        + GetInterval() string
        + WithCondition(value []define.ContainerStatus) *WaitOptions
        + GetCondition() []define.ContainerStatus

    }
    class checkpointStatistics << (S,Aquamarine) >> {
        + PodmanDuration int64
        + ContainerStatistics []*entities.CheckpointReport

    }
    class containerStats << (S,Aquamarine) >> {
        + ID() string
        + CPUPerc() string
        + AVGCPU() string
        + Up() string
        + MemPerc() string
        + NetIO() string
        + BlockIO() string
        + PIDS() string
        + MemUsage() string
        + MemUsageBytes() string

    }
    class exposedPort << (S,Aquamarine) >> {
    }
    class logsOptionsWrapper << (S,Aquamarine) >> {
        + SinceRaw string
        + UntilRaw string

    }
    class mountReporter << (S,Aquamarine) >> {
        + ID() string

    }
    class psReporter << (S,Aquamarine) >> {
        + ImageID() string
        + Label(name string) string
        + ID() string
        + Pod() string
        + Status() string
        + Restarts() string
        + RunningFor() string
        + Command() string
        + Size() string
        + Names() string
        + Networks() string
        + Ports() string
        + CreatedAt() string
        + CreatedHuman() string
        + Cgroup() string
        + IPC() string
        + MNT() string
        + NET() string
        + PIDNS() string
        + User() string
        + UTS() string

    }
    class rawFormatter << (S,Aquamarine) >> {
        + Format(entry *logrus.Entry) ([]byte, error)

    }
    class restoreStatistics << (S,Aquamarine) >> {
        + PodmanDuration int64
        + ContainerStatistics []*entities.RestoreReport

    }
    class runlabelOptionsWrapper << (S,Aquamarine) >> {
        + TLSVerifyCLI bool

    }
    class statsOptionsCLI << (S,Aquamarine) >> {
        + All bool
        + Format string
        + Latest bool
        + NoReset bool
        + NoStream bool
        + Interval int

    }
}
"define.ContainerStats" *-- "extends""containers.containerStats"
"entities.ContainerLogsOptions" *-- "extends""containers.logsOptionsWrapper"
"entities.ContainerMountReport" *-- "extends""containers.mountReporter"
"entities.ListContainer" *-- "extends""containers.psReporter"
"logrus.TextFormatter" *-- "extends""containers.rawFormatter"
"entities.ContainerRunlabelOptions" *-- "extends""containers.runlabelOptionsWrapper"


namespace copy {
    class copy.FileInfo << (T, #FF7700) >>  {
    }
    class "define.FileInfo" as defineFileInfo {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace define {
    class Address << (S,Aquamarine) >> {
        + Addr string
        + PrefixLength int

    }
    class Artifact << (S,Aquamarine) >> {
        + String() string

    }
    class AttachStreams << (S,Aquamarine) >> {
        + OutputStream io.Writer
        + ErrorStream io.Writer
        + InputStream *bufio.Reader
        + AttachOutput bool
        + AttachError bool
        + AttachInput bool

    }
    class CPUUsage << (S,Aquamarine) >> {
        + UserPercent float64
        + SystemPercent float64
        + IdlePercent float64

    }
    class CRIUCheckpointRestoreStatistics << (S,Aquamarine) >> {
        + FreezingTime uint32
        + FrozenTime uint32
        + MemdumpTime uint32
        + MemwriteTime uint32
        + PagesScanned uint64
        + PagesWritten uint64
        + PagesCompared uint64
        + PagesSkippedCow uint64
        + ForkingTime uint32
        + RestoreTime uint32
        + PagesRestored uint64

    }
    class ConmonInfo << (S,Aquamarine) >> {
        + Package string
        + Path string
        + Version string

    }
    class ContainerExecStatus << (S,Aquamarine) >> {
        + String() string

    }
    class ContainerNetworkStats << (S,Aquamarine) >> {
        + RxBytes uint64
        + RxDropped uint64
        + RxErrors uint64
        + RxPackets uint64
        + TxBytes uint64
        + TxDropped uint64
        + TxErrors uint64
        + TxPackets uint64

    }
    class ContainerSize << (S,Aquamarine) >> {
        + RootFsSize int64
        + RwSize int64

    }
    class ContainerStats << (S,Aquamarine) >> {
        + AvgCPU float64
        + ContainerID string
        + Name string
        + PerCPU []uint64
        + CPU float64
        + CPUNano uint64
        + CPUSystemNano uint64
        + SystemNano uint64
        + MemUsage uint64
        + MemLimit uint64
        + MemPerc float64
        + Network <font color=blue>map</font>[string]ContainerNetworkStats
        + BlockInput uint64
        + BlockOutput uint64
        + PIDs uint64
        + UpTime time.Duration
        + Duration uint64

    }
    class ContainerStatus << (S,Aquamarine) >> {
        + String() string

    }
    class ContainerStore << (S,Aquamarine) >> {
        + Number int
        + Paused int
        + Running int
        + Stopped int

    }
    class CreateVMOpts << (S,Aquamarine) >> {
        + Name string
        + Dirs *MachineDirs
        + ReExec bool
        + UserModeNetworking bool

    }
    class DiffType << (S,Aquamarine) >> {
        + String() string

    }
    class DistributionInfo << (S,Aquamarine) >> {
        + Distribution string
        + Variant string
        + Version string
        + Codename string

    }
    class DriverData << (S,Aquamarine) >> {
        + Name string
        + Data <font color=blue>map</font>[string]string

    }
    class ErrIncompatibleMachineConfig << (S,Aquamarine) >> {
        + Name string
        + Path string

        + Error() string

    }
    class ErrMultipleActiveVM << (S,Aquamarine) >> {
        + Name string
        + Provider string

        + Error() string

    }
    class ErrNewDiskSizeTooSmall << (S,Aquamarine) >> {
        + OldSize strongunits.GiB

        + Error() string

    }
    class ErrVMDoesNotExist << (S,Aquamarine) >> {
        + Name string

        + Error() string

    }
    class ErrVMRunningCannotDestroyed << (S,Aquamarine) >> {
        + Name string

        + Error() string

    }
    class FileInfo << (S,Aquamarine) >> {
        + Name string
        + Size int64
        + Mode os.FileMode
        + ModTime time.Time
        + IsDir bool
        + LinkTarget string

    }
    class GlobalHealthCheckOptions << (S,Aquamarine) >> {
        + HealthLogDestination *string
        + HealthMaxLogCount *uint
        + HealthMaxLogSize *uint
        + HealthCheckOnFailureAction *HealthCheckOnFailureAction

    }
    class HealthCheckLog << (S,Aquamarine) >> {
        + Start string
        + End string
        + ExitCode int
        + Output string

    }
    class HealthCheckOnFailureAction << (S,Aquamarine) >> {
        + String() string

    }
    class HealthCheckOptions << (S,Aquamarine) >> {
        + Cmd string
        + Interval string
        + Retries int
        + Timeout string
        + StartPeriod string
        + Successes int

    }
    class HealthCheckResults << (S,Aquamarine) >> {
        + Status string
        + FailingStreak int
        + Log []HealthCheckLog

    }
    class HostInfo << (S,Aquamarine) >> {
        + Arch string
        + BuildahVersion string
        + CgroupManager string
        + CgroupsVersion string
        + CgroupControllers []string
        + Conmon *ConmonInfo
        + CPUs int
        + CPUUtilization *CPUUsage
        + DatabaseBackend string
        + Distribution DistributionInfo
        + EventLogger string
        + FreeLocks *uint32
        + Hostname string
        + IDMappings IDMappings
        + Kernel string
        + LogDriver string
        + MemFree int64
        + MemTotal int64
        + NetworkBackend string
        + NetworkBackendInfo types.NetworkInfo
        + OCIRuntime *OCIRuntimeInfo
        + OS string
        + RemoteSocket *RemoteSocket
        + RootlessNetworkCmd string
        + RuntimeInfo <font color=blue>map</font>[string]<font color=blue>interface</font>{}
        + ServiceIsRemote bool
        + Security SecurityInfo
        + Slirp4NetNS SlirpInfo
        + Pasta PastaInfo
        + SwapFree int64
        + SwapTotal int64
        + Uptime string
        + Variant string
        + Linkmode string

    }
    class IDMappings << (S,Aquamarine) >> {
        + GIDMap []idtools.IDMap
        + UIDMap []idtools.IDMap

    }
    class ImageFormat << (S,Aquamarine) >> {
        + Kind() string
        + KindWithCompression() string

    }
    class ImageStore << (S,Aquamarine) >> {
        + Number int

    }
    class Info << (S,Aquamarine) >> {
        + Host *HostInfo
        + Store *StoreInfo
        + Registries <font color=blue>map</font>[string]<font color=blue>interface</font>{}
        + Plugins Plugins
        + Version Version

    }
    class InfoData << (S,Aquamarine) >> {
        + Type string
        + Data <font color=blue>map</font>[string]<font color=blue>interface</font>{}

    }
    class InitOptions << (S,Aquamarine) >> {
        + PlaybookPath string
        + CPUS uint64
        + DiskSize uint64
        + IgnitionPath string
        + Image string
        + Volumes []string
        + IsDefault bool
        + Memory uint64
        + Name string
        + TimeZone string
        + URI url.URL
        + Username string
        + ReExec bool
        + Rootful bool
        + UID string
        + UserModeNetworking *bool
        + USBs []string

    }
    class InspectAdditionalNetwork << (S,Aquamarine) >> {
        + NetworkID string
        + DriverOpts <font color=blue>map</font>[string]string
        + IPAMConfig <font color=blue>map</font>[string]string
        + Links []string
        + Aliases []string

    }
    class InspectBasicNetworkConfig << (S,Aquamarine) >> {
        + EndpointID string
        + Gateway string
        + IPAddress string
        + IPPrefixLen int
        + SecondaryIPAddresses []Address
        + IPv6Gateway string
        + GlobalIPv6Address string
        + GlobalIPv6PrefixLen int
        + SecondaryIPv6Addresses []Address
        + MacAddress string
        + AdditionalMacAddresses []string

    }
    class InspectBlkioThrottleDevice << (S,Aquamarine) >> {
        + Path string
        + Rate uint64

    }
    class InspectBlkioWeightDevice << (S,Aquamarine) >> {
        + Path string
        + Weight uint16

    }
    class InspectContainerConfig << (S,Aquamarine) >> {
        + Hostname string
        + DomainName string
        + User string
        + AttachStdin bool
        + AttachStdout bool
        + AttachStderr bool
        + Tty bool
        + OpenStdin bool
        + StdinOnce bool
        + Env []string
        + Cmd []string
        + Image string
        + Volumes <font color=blue>map</font>[string]<font color=blue>struct</font>{}
        + WorkingDir string
        + Entrypoint []string
        + OnBuild *string
        + Labels <font color=blue>map</font>[string]string
        + Annotations <font color=blue>map</font>[string]string
        + StopSignal string
        + StartupHealthCheck *StartupHealthCheck
        + Healthcheck *manifest.Schema2HealthConfig
        + HealthcheckOnFailureAction string
        + HealthLogDestination string
        + HealthMaxLogCount uint
        + HealthMaxLogSize uint
        + CreateCommand []string
        + Timezone string
        + SystemdMode bool
        + Umask string
        + Secrets []*InspectSecret
        + Timeout uint
        + StopTimeout uint
        + Passwd *bool
        + ChrootDirs []string
        + SdNotifyMode string
        + SdNotifySocket string
        + ExposedPorts <font color=blue>map</font>[string]<font color=blue>struct</font>{}
        + V4PodmanCompatMarshal bool

        + UnmarshalJSON(data []byte) error
        + MarshalJSON() ([]byte, error)

    }
    class InspectContainerData << (S,Aquamarine) >> {
        + ID string
        + Created time.Time
        + Path string
        + Args []string
        + State *InspectContainerState
        + Image string
        + ImageDigest string
        + ImageName string
        + Rootfs string
        + Pod string
        + ResolvConfPath string
        + HostnamePath string
        + HostsPath string
        + StaticDir string
        + OCIConfigPath string
        + OCIRuntime string
        + ConmonPidFile string
        + PidFile string
        + Name string
        + RestartCount int32
        + Driver string
        + MountLabel string
        + ProcessLabel string
        + AppArmorProfile string
        + EffectiveCaps []string
        + BoundingCaps []string
        + ExecIDs []string
        + GraphDriver *DriverData
        + SizeRw *int64
        + SizeRootFs int64
        + Mounts []InspectMount
        + Dependencies []string
        + NetworkSettings *InspectNetworkSettings
        + Namespace string
        + IsInfra bool
        + IsService bool
        + KubeExitCodePropagation string
        + LockNumber uint32
        + Config *InspectContainerConfig
        + HostConfig *InspectContainerHostConfig
        + UseImageHosts bool
        + UseImageHostname bool

    }
    class InspectContainerHostConfig << (S,Aquamarine) >> {
        + Binds []string
        + CgroupManager string
        + CgroupMode string
        + ContainerIDFile string
        + LogConfig *InspectLogConfig
        + NetworkMode string
        + PortBindings <font color=blue>map</font>[string][]InspectHostPort
        + RestartPolicy *InspectRestartPolicy
        + AutoRemove bool
        + AutoRemoveImage bool
        + Annotations <font color=blue>map</font>[string]string
        + VolumeDriver string
        + VolumesFrom []string
        + CapAdd []string
        + CapDrop []string
        + Dns []string
        + DnsOptions []string
        + DnsSearch []string
        + ExtraHosts []string
        + HostsFile string
        + GroupAdd []string
        + IpcMode string
        + Cgroup string
        + Cgroups string
        + Links []string
        + OomScoreAdj int
        + PidMode string
        + Privileged bool
        + PublishAllPorts bool
        + ReadonlyRootfs bool
        + SecurityOpt []string
        + Tmpfs <font color=blue>map</font>[string]string
        + UTSMode string
        + UsernsMode string
        + IDMappings *InspectIDMappings
        + ShmSize int64
        + Runtime string
        + ConsoleSize []uint
        + Isolation string
        + CpuShares uint64
        + Memory int64
        + NanoCpus int64
        + CgroupParent string
        + BlkioWeight uint16
        + BlkioWeightDevice []InspectBlkioWeightDevice
        + BlkioDeviceReadBps []InspectBlkioThrottleDevice
        + BlkioDeviceWriteBps []InspectBlkioThrottleDevice
        + BlkioDeviceReadIOps []InspectBlkioThrottleDevice
        + BlkioDeviceWriteIOps []InspectBlkioThrottleDevice
        + CpuPeriod uint64
        + CpuQuota int64
        + CpuRealtimePeriod uint64
        + CpuRealtimeRuntime int64
        + CpusetCpus string
        + CpusetMems string
        + Devices []InspectDevice
        + DiskQuota uint64
        + KernelMemory int64
        + MemoryReservation int64
        + MemorySwap int64
        + MemorySwappiness int64
        + OomKillDisable bool
        + Init bool
        + PidsLimit int64
        + Ulimits []InspectUlimit
        + CpuCount uint64
        + CpuPercent uint64
        + IOMaximumIOps uint64
        + IOMaximumBandwidth uint64
        + CgroupConf <font color=blue>map</font>[string]string
        + IntelRdtClosID string

    }
    class InspectContainerState << (S,Aquamarine) >> {
        + OciVersion string
        + Status string
        + Running bool
        + Paused bool
        + Restarting bool
        + OOMKilled bool
        + Dead bool
        + Pid int
        + ConmonPid int
        + ExitCode int32
        + Error string
        + StartedAt time.Time
        + FinishedAt time.Time
        + Health *HealthCheckResults
        + Checkpointed bool
        + CgroupPath string
        + CheckpointedAt time.Time
        + RestoredAt time.Time
        + CheckpointLog string
        + CheckpointPath string
        + RestoreLog string
        + Restored bool
        + StoppedByUser bool

        + Healthcheck() *HealthCheckResults

    }
    class InspectDevice << (S,Aquamarine) >> {
        + PathOnHost string
        + PathInContainer string
        + CgroupPermissions string

    }
    class InspectExecProcess << (S,Aquamarine) >> {
        + Arguments []string
        + Entrypoint string
        + Privileged bool
        + Tty bool
        + User string

    }
    class InspectExecSession << (S,Aquamarine) >> {
        + CanRemove bool
        + ContainerID string
        + DetachKeys string
        + ExitCode int
        + ID string
        + OpenStderr bool
        + OpenStdin bool
        + OpenStdout bool
        + Running bool
        + Pid int
        + ProcessConfig *InspectExecProcess

    }
    class InspectHostPort << (S,Aquamarine) >> {
        + HostIP string
        + HostPort string

    }
    class InspectIDMappings << (S,Aquamarine) >> {
        + UIDMap []string
        + GIDMap []string

    }
    class InspectLogConfig << (S,Aquamarine) >> {
        + Type string
        + Config <font color=blue>map</font>[string]string
        + Path string
        + Tag string
        + Size string

    }
    class InspectMount << (S,Aquamarine) >> {
        + Type string
        + Name string
        + Source string
        + Destination string
        + Driver string
        + Mode string
        + Options []string
        + RW bool
        + Propagation string
        + SubPath string

    }
    class InspectNetworkSettings << (S,Aquamarine) >> {
        + Bridge string
        + SandboxID string
        + HairpinMode bool
        + LinkLocalIPv6Address string
        + LinkLocalIPv6PrefixLen int
        + Ports <font color=blue>map</font>[string][]InspectHostPort
        + SandboxKey string
        + Networks <font color=blue>map</font>[string]*InspectAdditionalNetwork

    }
    class InspectPodContainerInfo << (S,Aquamarine) >> {
        + ID string
        + Name string
        + State string

    }
    class InspectPodData << (S,Aquamarine) >> {
        + ID string
        + Name string
        + Namespace string
        + Created time.Time
        + CreateCommand []string
        + ExitPolicy string
        + State string
        + Hostname string
        + Labels <font color=blue>map</font>[string]string
        + CreateCgroup bool
        + CgroupParent string
        + CgroupPath string
        + CreateInfra bool
        + InfraContainerID string
        + InfraConfig *InspectPodInfraConfig
        + SharedNamespaces []string
        + NumContainers uint
        + Containers []InspectPodContainerInfo
        + CPUPeriod uint64
        + CPUQuota int64
        + CPUShares uint64
        + CPUSetCPUs string
        + CPUSetMems string
        + Mounts []InspectMount
        + Devices []InspectDevice
        + BlkioDeviceReadBps []InspectBlkioThrottleDevice
        + BlkioDeviceWriteBps []InspectBlkioThrottleDevice
        + VolumesFrom []string
        + SecurityOpts []string
        + MemoryLimit uint64
        + MemorySwap uint64
        + BlkioWeight uint64
        + BlkioWeightDevice []InspectBlkioWeightDevice
        + RestartPolicy string
        + LockNumber uint32

    }
    class InspectPodInfraConfig << (S,Aquamarine) >> {
        + PortBindings <font color=blue>map</font>[string][]InspectHostPort
        + HostNetwork bool
        + StaticIP net.IP
        + StaticMAC string
        + NoManageResolvConf bool
        + DNSServer []string
        + DNSSearch []string
        + DNSOption []string
        + NoManageHostname bool
        + NoManageHosts bool
        + HostAdd []string
        + HostsFile string
        + Networks []string
        + NetworkOptions <font color=blue>map</font>[string][]string
        + CPUPeriod uint64
        + CPUQuota int64
        + CPUSetCPUs string
        + PidNS string
        + UserNS string
        + UtsNS string

    }
    class InspectRestartPolicy << (S,Aquamarine) >> {
        + Name string
        + MaximumRetryCount uint

    }
    class InspectSecret << (S,Aquamarine) >> {
        + Name string
        + ID string
        + UID uint32
        + GID uint32
        + Mode uint32

    }
    class InspectUlimit << (S,Aquamarine) >> {
        + Name string
        + Soft int64
        + Hard int64

    }
    class InspectVolumeData << (S,Aquamarine) >> {
        + Name string
        + Driver string
        + Mountpoint string
        + CreatedAt time.Time
        + Status <font color=blue>map</font>[string]<font color=blue>interface</font>{}
        + Labels <font color=blue>map</font>[string]string
        + Scope string
        + Options <font color=blue>map</font>[string]string
        + UID int
        + GID int
        + Anonymous bool
        + MountCount uint
        + NeedsCopyUp bool
        + NeedsChown bool
        + Timeout uint
        + StorageID string
        + LockNumber uint32

    }
    class KubeExitCodePropagation << (S,Aquamarine) >> {
        + String() string

    }
    class MachineDirs << (S,Aquamarine) >> {
        + ConfigDir *VMFile
        + DataDir *VMFile
        + ImageCacheDir *VMFile
        + RuntimeDir *VMFile

    }
    class OCIRuntimeInfo << (S,Aquamarine) >> {
        + Name string
        + Package string
        + Path string
        + Version string

    }
    class PastaInfo << (S,Aquamarine) >> {
        + Executable string
        + Package string
        + Version string

    }
    class Plugins << (S,Aquamarine) >> {
        + Volume []string
        + Network []string
        + Log []string
        + Authorization []string

    }
    class RemoteSocket << (S,Aquamarine) >> {
        + Path string
        + Exists bool

    }
    class SecurityInfo << (S,Aquamarine) >> {
        + AppArmorEnabled bool
        + DefaultCapabilities string
        + Rootless bool
        + SECCOMPEnabled bool
        + SECCOMPProfilePath string
        + SELinuxEnabled bool

    }
    class SetOptions << (S,Aquamarine) >> {
        + CPUs *uint64
        + DiskSize *strongunits.GiB
        + Memory *strongunits.MiB
        + Rootful *bool
        + UserModeNetworking *bool
        + USBs *[]string

    }
    class SlirpInfo << (S,Aquamarine) >> {
        + Executable string
        + Package string
        + Version string

    }
    class StartupHealthCheck << (S,Aquamarine) >> {
        + Successes int

    }
    class StoreInfo << (S,Aquamarine) >> {
        + ConfigFile string
        + ContainerStore ContainerStore
        + GraphDriverName string
        + GraphOptions <font color=blue>map</font>[string]<font color=blue>interface</font>{}
        + GraphRoot string
        + GraphRootAllocated uint64
        + GraphRootUsed uint64
        + GraphStatus <font color=blue>map</font>[string]string
        + ImageCopyTmpDir string
        + ImageStore ImageStore
        + RunRoot string
        + VolumePath string
        + TransientStore bool

    }
    class ThrottleDevice << (S,Aquamarine) >> {
        + Path string
        + Rate uint64

    }
    class USBConfig << (S,Aquamarine) >> {
        + Bus string
        + DevNumber string
        + Vendor int
        + Product int

    }
    class UpdateContainerDevicesLimits << (S,Aquamarine) >> {
        + BlkIOWeightDevice []WeightDevice
        + DeviceReadBPs []ThrottleDevice
        + DeviceWriteBPs []ThrottleDevice
        + DeviceReadIOPs []ThrottleDevice
        + DeviceWriteIOPs []ThrottleDevice

        + SetBlkIOWeightDevice(wd <font color=blue>map</font>[string]specs.LinuxWeightDevice) 
        + SetDeviceReadBPs(td <font color=blue>map</font>[string]specs.LinuxThrottleDevice) 
        + SetDeviceWriteBPs(td <font color=blue>map</font>[string]specs.LinuxThrottleDevice) 
        + SetDeviceReadIOPs(td <font color=blue>map</font>[string]specs.LinuxThrottleDevice) 
        + SetDeviceWriteIOPs(td <font color=blue>map</font>[string]specs.LinuxThrottleDevice) 
        + GetMapOfLinuxWeightDevice() <font color=blue>map</font>[string]specs.LinuxWeightDevice
        + GetMapOfDeviceReadBPs() <font color=blue>map</font>[string]specs.LinuxThrottleDevice
        + GetMapOfDeviceWriteBPs() <font color=blue>map</font>[string]specs.LinuxThrottleDevice
        + GetMapOfDeviceReadIOPs() <font color=blue>map</font>[string]specs.LinuxThrottleDevice
        + GetMapOfDeviceWriteIOPs() <font color=blue>map</font>[string]specs.LinuxThrottleDevice

    }
    class UpdateHealthCheckConfig << (S,Aquamarine) >> {
        + HealthLogDestination *string
        + HealthMaxLogSize *uint
        + HealthMaxLogCount *uint
        + HealthOnFailure *string
        + NoHealthCheck *bool
        + HealthCmd *string
        + HealthInterval *string
        + HealthRetries *uint
        + HealthTimeout *string
        + HealthStartPeriod *string
        + HealthStartupCmd *string
        + HealthStartupInterval *string
        + HealthStartupRetries *uint
        + HealthStartupTimeout *string
        + HealthStartupSuccess *uint

        + IsStartupHealthCheckCommandSet(startupHealthCheck *StartupHealthCheck) bool
        + IsHealthCheckCommandSet(healthCheck *manifest.Schema2HealthConfig) bool
        + SetNewStartupHealthCheckConfigTo(healthCheckOptions *HealthCheckOptions) bool
        + SetNewHealthCheckConfigTo(healthCheckOptions *HealthCheckOptions) bool
        + GetNewGlobalHealthCheck() (GlobalHealthCheckOptions, error)

    }
    class VMFile << (S,Aquamarine) >> {
        + Path string
        + Symlink *string

        + GetPath() string
        + Delete() error
        + Read() ([]byte, error)
        + ReadMagicNumber(n int) ([]byte, error)
        + ReadPIDFrom() (int, error)
        + AppendToNewVMFile(additionalPath string, symlink *string) (*VMFile, error)

    }
    class VMType << (S,Aquamarine) >> {
        + String() string
        + DiskType() string
        + ImageFormat() ImageFormat

    }
    class Version << (S,Aquamarine) >> {
        + APIVersion string
        + Version string
        + GoVersion string
        + GitCommit string
        + BuiltTime string
        + Built int64
        + BuildOrigin string
        + OsArch string
        + Os string

    }
    class VolumeReload << (S,Aquamarine) >> {
        + Added []string
        + Removed []string
        + Errors []error

    }
    class WeightDevice << (S,Aquamarine) >> {
        + Path string
        + Weight uint16

    }
    class define.Artifact << (T, #FF7700) >>  {
    }
    class define.ContainerExecStatus << (T, #FF7700) >>  {
    }
    class define.ContainerStatus << (T, #FF7700) >>  {
    }
    class define.DiffType << (T, #FF7700) >>  {
    }
    class define.HealthCheckOnFailureAction << (T, #FF7700) >>  {
    }
    class define.HealthCheckStatus << (T, #FF7700) >>  {
    }
    class define.ImageFormat << (T, #FF7700) >>  {
    }
    class define.KubeExitCodePropagation << (T, #FF7700) >>  {
    }
    class define.RuntimeStateStore << (T, #FF7700) >>  {
    }
    class define.Status << (T, #FF7700) >>  {
    }
    class define.VMType << (T, #FF7700) >>  {
    }
}
"define.InspectBasicNetworkConfig" *-- "extends""define.InspectAdditionalNetwork"
"define.InspectBasicNetworkConfig" *-- "extends""define.InspectNetworkSettings"
"manifest.Schema2HealthConfig" *-- "extends""define.StartupHealthCheck"


namespace diff {
    class ChangesReportJSON << (S,Aquamarine) >> {
        + Changed []string
        + Added []string
        + Deleted []string

    }
}


namespace emulation {
    class elfPlatform << (S,Aquamarine) >> {
    }
}


namespace entities {
    class ApplyOptions << (S,Aquamarine) >> {
        + Kubeconfig string
        + Namespace string
        + CACertFile string
        + File string
        + Service bool

    }
    class ArtifactAddOptions << (S,Aquamarine) >> {
        + Annotations <font color=blue>map</font>[string]string
        + ArtifactType string

    }
    class ArtifactAddReport << (S,Aquamarine) >> {
        + ArtifactDigest *digest.Digest

    }
    class ArtifactInspectOptions << (S,Aquamarine) >> {
        + Remote bool

    }
    class ArtifactInspectReport << (S,Aquamarine) >> {
        + Digest string

    }
    class ArtifactListOptions << (S,Aquamarine) >> {
    }
    class ArtifactListReport << (S,Aquamarine) >> {
    }
    class ArtifactPullOptions << (S,Aquamarine) >> {
        + Architecture string
        + AuthFilePath string
        + CertDirPath string
        + InsecureSkipTLSVerify types.OptionalBool
        + MaxRetries *uint
        + OciDecryptConfig *config.DecryptConfig
        + Password string
        + Quiet bool
        + RetryDelay string
        + SignaturePolicyPath string
        + Username string
        + Writer io.Writer

    }
    class ArtifactPullReport << (S,Aquamarine) >> {
    }
    class ArtifactPushOptions << (S,Aquamarine) >> {
        + CredentialsCLI string
        + DigestFile string
        + EncryptLayers []int
        + EncryptionKeys []string
        + SignBySigstoreParamFileCLI string
        + SignPassphraseFileCLI string
        + TLSVerifyCLI bool

    }
    class ArtifactPushReport << (S,Aquamarine) >> {
    }
    class ArtifactRemoveOptions << (S,Aquamarine) >> {
    }
    class ArtifactRemoveReport << (S,Aquamarine) >> {
        + ArtfactDigest *digest.Digest

    }
    class AttachOptions << (S,Aquamarine) >> {
        + DetachKeys string
        + Latest bool
        + NoStdin bool
        + SigProxy bool
        + Stdin *os.File
        + Stdout *os.File
        + Stderr *os.File

    }
    class AutoUpdateOptions << (S,Aquamarine) >> {
        + Authfile string
        + DryRun bool
        + Rollback bool
        + InsecureSkipTLSVerify types.OptionalBool

    }
    class AutoUpdateReport << (S,Aquamarine) >> {
        + ContainerID string
        + ContainerName string
        + ImageName string
        + Policy string
        + SystemdUnit string
        + Updated string

    }
    class BoolReport << (S,Aquamarine) >> {
        + Value bool

    }
    class CheckpointOptions << (S,Aquamarine) >> {
        + All bool
        + Export string
        + CreateImage string
        + IgnoreRootFS bool
        + IgnoreVolumes bool
        + Keep bool
        + Latest bool
        + LeaveRunning bool
        + TCPEstablished bool
        + PreCheckPoint bool
        + WithPrevious bool
        + Compression archive.Compression
        + PrintStats bool
        + FileLocks bool

    }
    class CommitOptions << (S,Aquamarine) >> {
        + Author string
        + Changes []string
        + Config []byte
        + Format string
        + ImageName string
        + IncludeVolumes bool
        + Message string
        + Pause bool
        + Quiet bool
        + Squash bool
        + Writer io.Writer

    }
    class CommitReport << (S,Aquamarine) >> {
        + Id string

    }
    class Container << (S,Aquamarine) >> {
    }
    class ContainerCleanupOptions << (S,Aquamarine) >> {
        + All bool
        + Exec string
        + Latest bool
        + Remove bool
        + RemoveImage bool
        + StoppedOnly bool

    }
    class ContainerCleanupReport << (S,Aquamarine) >> {
        + CleanErr error
        + Id string
        + RawInput string
        + RmErr error
        + RmiErr error

    }
    class ContainerCloneOptions << (S,Aquamarine) >> {
        + ID string
        + Destroy bool
        + CreateOpts ContainerCreateOptions
        + Image string
        + RawImageName string
        + Run bool
        + Force bool

    }
    class ContainerCpOptions << (S,Aquamarine) >> {
        + Pause bool
        + Extract bool
        + OverwriteDirNonDir bool

    }
    class ContainerCreateOptions << (S,Aquamarine) >> {
        + Annotation []string
        + Attach []string
        + Authfile string
        + BlkIOWeight string
        + BlkIOWeightDevice []string
        + CapAdd []string
        + CapDrop []string
        + CgroupNS string
        + CgroupsMode string
        + CgroupParent string
        + CIDFile string
        + ConmonPIDFile string
        + CPUPeriod uint64
        + CPUQuota int64
        + CPURTPeriod uint64
        + CPURTRuntime int64
        + CPUShares uint64
        + CPUS float64
        + CPUSetCPUs string
        + CPUSetMems string
        + Devices []string
        + DeviceCgroupRule []string
        + DeviceReadBPs []string
        + DeviceReadIOPs []string
        + DeviceWriteBPs []string
        + DeviceWriteIOPs []string
        + Entrypoint *string
        + Env []string
        + EnvHost bool
        + EnvFile []string
        + Expose []string
        + GIDMap []string
        + GPUs []string
        + GroupAdd []string
        + HealthCmd string
        + HealthInterval string
        + HealthRetries uint
        + HealthLogDestination string
        + HealthMaxLogCount uint
        + HealthMaxLogSize uint
        + HealthStartPeriod string
        + HealthTimeout string
        + HealthOnFailure string
        + Hostname string
        + HTTPProxy bool
        + HostUsers []string
        + ImageVolume string
        + Init bool
        + InitContainerType string
        + InitPath string
        + IntelRdtClosID string
        + Interactive bool
        + IPC string
        + Label []string
        + LabelFile []string
        + LogDriver string
        + LogOptions []string
        + Memory string
        + MemoryReservation string
        + MemorySwap string
        + MemorySwappiness int64
        + Name string
        + NoHealthCheck bool
        + OOMKillDisable bool
        + OOMScoreAdj *int
        + Arch string
        + OS string
        + Variant string
        + PID string
        + PIDsLimit *int64
        + Platform string
        + Pod string
        + PodIDFile string
        + Personality string
        + PreserveFDs uint
        + PreserveFD []uint
        + Privileged bool
        + PublishAll bool
        + Pull string
        + Quiet bool
        + ReadOnly bool
        + ReadWriteTmpFS bool
        + Restart string
        + Replace bool
        + Requires []string
        + Retry *uint
        + RetryDelay string
        + Rm bool
        + RootFS bool
        + Secrets []string
        + SecurityOpt []string
        + SdNotifyMode string
        + ShmSize string
        + ShmSizeSystemd string
        + SignaturePolicy string
        + StartupHCCmd string
        + StartupHCInterval string
        + StartupHCRetries uint
        + StartupHCSuccesses uint
        + StartupHCTimeout string
        + StopSignal string
        + StopTimeout uint
        + StorageOpts []string
        + SubGIDName string
        + SubUIDName string
        + Sysctl []string
        + Systemd string
        + Timeout uint
        + TLSVerify flag.OptionalBool
        + TmpFS []string
        + TTY bool
        + Timezone string
        + Umask string
        + EnvMerge []string
        + UnsetEnv []string
        + UnsetEnvAll bool
        + UIDMap []string
        + Ulimit []string
        + User string
        + UserNS string
        + UTS string
        + Mount []string
        + Volume []string
        + VolumesFrom []string
        + Workdir string
        + SeccompPolicy string
        + PidFile string
        + ChrootDirs []string
        + IsInfra bool
        + IsClone bool
        + DecryptionKeys []string
        + Net *NetOptions
        + CgroupConf []string
        + GroupEntry string
        + PasswdEntry string

    }
    class ContainerCreateReport << (S,Aquamarine) >> {
        + Id string

    }
    interface ContainerEngine  {
        + AutoUpdate(ctx context.Context, options AutoUpdateOptions) ([]*AutoUpdateReport, []error)
        + Config(ctx context.Context) (*config.Config, error)
        + ContainerAttach(ctx context.Context, nameOrID string, options AttachOptions) error
        + ContainerCheckpoint(ctx context.Context, namesOrIds []string, options CheckpointOptions) ([]*CheckpointReport, error)
        + ContainerCleanup(ctx context.Context, namesOrIds []string, options ContainerCleanupOptions) ([]*ContainerCleanupReport, error)
        + ContainerClone(ctx context.Context, ctrClone ContainerCloneOptions) (*ContainerCreateReport, error)
        + ContainerCommit(ctx context.Context, nameOrID string, options CommitOptions) (*CommitReport, error)
        + ContainerCopyFromArchive(ctx context.Context, nameOrID string, path string, reader io.Reader, options CopyOptions) (ContainerCopyFunc, error)
        + ContainerCopyToArchive(ctx context.Context, nameOrID string, path string, writer io.Writer) (ContainerCopyFunc, error)
        + ContainerCreate(ctx context.Context, s *specgen.SpecGenerator) (*ContainerCreateReport, error)
        + ContainerExec(ctx context.Context, nameOrID string, options ExecOptions, streams define.AttachStreams) (int, error)
        + ContainerExecDetached(ctx context.Context, nameOrID string, options ExecOptions) (string, error)
        + ContainerExists(ctx context.Context, nameOrID string, options ContainerExistsOptions) (*BoolReport, error)
        + ContainerExport(ctx context.Context, nameOrID string, options ContainerExportOptions) error
        + ContainerInit(ctx context.Context, namesOrIds []string, options ContainerInitOptions) ([]*ContainerInitReport, error)
        + ContainerInspect(ctx context.Context, namesOrIds []string, options InspectOptions) ([]*ContainerInspectReport, []error, error)
        + ContainerKill(ctx context.Context, namesOrIds []string, options KillOptions) ([]*KillReport, error)
        + ContainerList(ctx context.Context, options ContainerListOptions) ([]ListContainer, error)
        + ContainerListExternal(ctx context.Context) ([]ListContainer, error)
        + ContainerLogs(ctx context.Context, containers []string, options ContainerLogsOptions) error
        + ContainerMount(ctx context.Context, nameOrIDs []string, options ContainerMountOptions) ([]*ContainerMountReport, error)
        + ContainerPause(ctx context.Context, namesOrIds []string, options PauseUnPauseOptions) ([]*PauseUnpauseReport, error)
        + ContainerPort(ctx context.Context, nameOrID string, options ContainerPortOptions) ([]*ContainerPortReport, error)
        + ContainerPrune(ctx context.Context, options ContainerPruneOptions) ([]*reports.PruneReport, error)
        + ContainerRename(ctr context.Context, nameOrID string, options ContainerRenameOptions) error
        + ContainerRestart(ctx context.Context, namesOrIds []string, options RestartOptions) ([]*RestartReport, error)
        + ContainerRestore(ctx context.Context, namesOrIds []string, options RestoreOptions) ([]*RestoreReport, error)
        + ContainerRm(ctx context.Context, namesOrIds []string, options RmOptions) ([]*reports.RmReport, error)
        + ContainerRun(ctx context.Context, opts ContainerRunOptions) (*ContainerRunReport, error)
        + ContainerRunlabel(ctx context.Context, label string, image string, args []string, opts ContainerRunlabelOptions) error
        + ContainerStart(ctx context.Context, namesOrIds []string, options ContainerStartOptions) ([]*ContainerStartReport, error)
        + ContainerStat(ctx context.Context, nameOrDir string, path string) (*ContainerStatReport, error)
        + ContainerStats(ctx context.Context, namesOrIds []string, options ContainerStatsOptions) (<font color=blue>chan</font> ContainerStatsReport, error)
        + ContainerStop(ctx context.Context, namesOrIds []string, options StopOptions) ([]*StopReport, error)
        + ContainerTop(ctx context.Context, options TopOptions) (*StringSliceReport, error)
        + ContainerUnmount(ctx context.Context, nameOrIDs []string, options ContainerUnmountOptions) ([]*ContainerUnmountReport, error)
        + ContainerUnpause(ctx context.Context, namesOrIds []string, options PauseUnPauseOptions) ([]*PauseUnpauseReport, error)
        + ContainerUpdate(ctx context.Context, options *ContainerUpdateOptions) (string, error)
        + ContainerWait(ctx context.Context, namesOrIds []string, options WaitOptions) ([]WaitReport, error)
        + Diff(ctx context.Context, namesOrIds []string, options DiffOptions) (*DiffReport, error)
        + Events(ctx context.Context, opts EventsOptions) error
        + GenerateSpec(ctx context.Context, opts *GenerateSpecOptions) (*GenerateSpecReport, error)
        + GenerateSystemd(ctx context.Context, nameOrID string, opts GenerateSystemdOptions) (*GenerateSystemdReport, error)
        + GenerateKube(ctx context.Context, nameOrIDs []string, opts GenerateKubeOptions) (*GenerateKubeReport, error)
        + SystemPrune(ctx context.Context, options SystemPruneOptions) (*SystemPruneReport, error)
        + HealthCheckRun(ctx context.Context, nameOrID string, options HealthCheckOptions) (*define.HealthCheckResults, error)
        + Info(ctx context.Context) (*define.Info, error)
        + KubeApply(ctx context.Context, body io.Reader, opts ApplyOptions) error
        + Locks(ctx context.Context) (*LocksReport, error)
        + Migrate(ctx context.Context, options SystemMigrateOptions) error
        + NetworkConnect(ctx context.Context, networkname string, options NetworkConnectOptions) error
        + NetworkCreate(ctx context.Context, network types.Network, createOptions *types.NetworkCreateOptions) (*types.Network, error)
        + NetworkUpdate(ctx context.Context, networkname string, options NetworkUpdateOptions) error
        + NetworkDisconnect(ctx context.Context, networkname string, options NetworkDisconnectOptions) error
        + NetworkExists(ctx context.Context, networkname string) (*BoolReport, error)
        + NetworkInspect(ctx context.Context, namesOrIds []string, options InspectOptions) ([]NetworkInspectReport, []error, error)
        + NetworkList(ctx context.Context, options NetworkListOptions) ([]types.Network, error)
        + NetworkPrune(ctx context.Context, options NetworkPruneOptions) ([]*NetworkPruneReport, error)
        + NetworkReload(ctx context.Context, names []string, options NetworkReloadOptions) ([]*NetworkReloadReport, error)
        + NetworkRm(ctx context.Context, namesOrIds []string, options NetworkRmOptions) ([]*NetworkRmReport, error)
        + PlayKube(ctx context.Context, body io.Reader, opts PlayKubeOptions) (*PlayKubeReport, error)
        + PlayKubeDown(ctx context.Context, body io.Reader, opts PlayKubeDownOptions) (*PlayKubeReport, error)
        + PodCreate(ctx context.Context, specg PodSpec) (*PodCreateReport, error)
        + PodClone(ctx context.Context, podClone PodCloneOptions) (*PodCloneReport, error)
        + PodExists(ctx context.Context, nameOrID string) (*BoolReport, error)
        + PodInspect(ctx context.Context, namesOrID []string, options InspectOptions) ([]*PodInspectReport, []error, error)
        + PodKill(ctx context.Context, namesOrIds []string, options PodKillOptions) ([]*PodKillReport, error)
        + PodLogs(ctx context.Context, pod string, options PodLogsOptions) error
        + PodPause(ctx context.Context, namesOrIds []string, options PodPauseOptions) ([]*PodPauseReport, error)
        + PodPrune(ctx context.Context, options PodPruneOptions) ([]*PodPruneReport, error)
        + PodPs(ctx context.Context, options PodPSOptions) ([]*ListPodsReport, error)
        + PodRestart(ctx context.Context, namesOrIds []string, options PodRestartOptions) ([]*PodRestartReport, error)
        + PodRm(ctx context.Context, namesOrIds []string, options PodRmOptions) ([]*PodRmReport, error)
        + PodStart(ctx context.Context, namesOrIds []string, options PodStartOptions) ([]*PodStartReport, error)
        + PodStats(ctx context.Context, namesOrIds []string, options PodStatsOptions) ([]*PodStatsReport, error)
        + PodStop(ctx context.Context, namesOrIds []string, options PodStopOptions) ([]*PodStopReport, error)
        + PodTop(ctx context.Context, options PodTopOptions) (*StringSliceReport, error)
        + PodUnpause(ctx context.Context, namesOrIds []string, options PodunpauseOptions) ([]*PodUnpauseReport, error)
        + Renumber(ctx context.Context) error
        + Reset(ctx context.Context) error
        + SetupRootless(ctx context.Context, noMoveProcess bool, cgroupMode string) error
        + SecretCreate(ctx context.Context, name string, reader io.Reader, options SecretCreateOptions) (*SecretCreateReport, error)
        + SecretInspect(ctx context.Context, nameOrIDs []string, options SecretInspectOptions) ([]*SecretInfoReport, []error, error)
        + SecretList(ctx context.Context, opts SecretListRequest) ([]*SecretInfoReport, error)
        + SecretRm(ctx context.Context, nameOrID []string, opts SecretRmOptions) ([]*SecretRmReport, error)
        + SecretExists(ctx context.Context, nameOrID string) (*BoolReport, error)
        + Shutdown(ctx context.Context) 
        + SystemDf(ctx context.Context, options SystemDfOptions) (*SystemDfReport, error)
        + SystemCheck(ctx context.Context, options SystemCheckOptions) (*SystemCheckReport, error)
        + Unshare(ctx context.Context, args []string, options SystemUnshareOptions) error
        + Version(ctx context.Context) (*SystemVersionReport, error)
        + VolumeCreate(ctx context.Context, opts VolumeCreateOptions) (*IDOrNameResponse, error)
        + VolumeExists(ctx context.Context, namesOrID string) (*BoolReport, error)
        + VolumeMounted(ctx context.Context, namesOrID string) (*BoolReport, error)
        + VolumeInspect(ctx context.Context, namesOrIds []string, opts InspectOptions) ([]*VolumeInspectReport, []error, error)
        + VolumeList(ctx context.Context, opts VolumeListOptions) ([]*VolumeListReport, error)
        + VolumeMount(ctx context.Context, namesOrIds []string) ([]*VolumeMountReport, error)
        + VolumePrune(ctx context.Context, options VolumePruneOptions) ([]*reports.PruneReport, error)
        + VolumeRm(ctx context.Context, namesOrIds []string, opts VolumeRmOptions) ([]*VolumeRmReport, error)
        + VolumeUnmount(ctx context.Context, namesOrIds []string) ([]*VolumeUnmountReport, error)
        + VolumeReload(ctx context.Context) (*VolumeReloadReport, error)

    }
    class ContainerExistsOptions << (S,Aquamarine) >> {
        + External bool

    }
    class ContainerExportOptions << (S,Aquamarine) >> {
        + Output io.Writer

    }
    class ContainerInitOptions << (S,Aquamarine) >> {
        + All bool
        + Latest bool

    }
    class ContainerInitReport << (S,Aquamarine) >> {
        + Err error
        + Id string
        + RawInput string

    }
    class ContainerInspectReport << (S,Aquamarine) >> {
    }
    class ContainerListOptions << (S,Aquamarine) >> {
        + All bool
        + Filters <font color=blue>map</font>[string][]string
        + Format string
        + Last int
        + Latest bool
        + Namespace bool
        + Pod bool
        + Quiet bool
        + Size bool
        + External bool
        + Sort string
        + Sync bool
        + Watch uint

    }
    class ContainerLogsOptions << (S,Aquamarine) >> {
        + Details bool
        + Follow bool
        + Latest bool
        + Names bool
        + Since time.Time
        + Until time.Time
        + Tail int64
        + Timestamps bool
        + Colors bool
        + StdoutWriter io.Writer
        + StderrWriter io.Writer

    }
    class ContainerMountOptions << (S,Aquamarine) >> {
        + All bool
        + Format string
        + Latest bool
        + NoTruncate bool

    }
    class ContainerMountReport << (S,Aquamarine) >> {
        + Err error
        + Id string
        + Name string
        + Path string

    }
    class ContainerPortOptions << (S,Aquamarine) >> {
        + All bool
        + Latest bool

    }
    class ContainerPortReport << (S,Aquamarine) >> {
        + Id string
        + Ports []types.PortMapping

    }
    class ContainerPruneOptions << (S,Aquamarine) >> {
        + Filters url.Values

    }
    class ContainerRenameOptions << (S,Aquamarine) >> {
        + NewName string

    }
    class ContainerRunOptions << (S,Aquamarine) >> {
        + CIDFile string
        + Detach bool
        + DetachKeys string
        + ErrorStream *os.File
        + InputStream *os.File
        + OutputStream *os.File
        + PreserveFDs uint
        + PreserveFD []uint
        + Rm bool
        + SigProxy bool
        + Spec *specgen.SpecGenerator
        + Passwd bool

    }
    class ContainerRunReport << (S,Aquamarine) >> {
        + ExitCode int
        + Id string

    }
    class ContainerRunlabelOptions << (S,Aquamarine) >> {
        + Authfile string
        + CertDir string
        + Credentials string
        + Display bool
        + Replace bool
        + Name string
        + Optional1 string
        + Optional2 string
        + Optional3 string
        + Pull bool
        + Quiet bool
        + SignaturePolicy string
        + SkipTLSVerify types.OptionalBool

    }
    class ContainerRunlabelReport << (S,Aquamarine) >> {
    }
    class ContainerStartOptions << (S,Aquamarine) >> {
        + Filters <font color=blue>map</font>[string][]string
        + All bool
        + Attach bool
        + DetachKeys string
        + Interactive bool
        + Latest bool
        + SigProxy bool
        + Stdout *os.File
        + Stderr *os.File
        + Stdin *os.File

    }
    class ContainerStartReport << (S,Aquamarine) >> {
        + Id string
        + RawInput string
        + Err error
        + ExitCode int

    }
    class ContainerStatsOptions << (S,Aquamarine) >> {
        + All bool
        + Latest bool
        + Stream bool
        + Interval int

    }
    class ContainerUnmountOptions << (S,Aquamarine) >> {
        + All bool
        + Force bool
        + Latest bool

    }
    class ContainerUnmountReport << (S,Aquamarine) >> {
        + Err error
        + Id string

    }
    class CopyOptions << (S,Aquamarine) >> {
        + Chown bool
        + Rename <font color=blue>map</font>[string]string
        + NoOverwriteDirNonDir bool

    }
    class CreateContainerDataOptions << (S,Aquamarine) >> {
        + ID string
        + Data <font color=blue>map</font>[string][]byte

    }
    class CreateContainerDataReport << (S,Aquamarine) >> {
    }
    class CreateContainerOptions << (S,Aquamarine) >> {
        + Layer string
        + Image string
        + Names []string
        + ID string

    }
    class CreateContainerReport << (S,Aquamarine) >> {
        + ID string

    }
    class CreateImageDataOptions << (S,Aquamarine) >> {
        + ID string
        + Data <font color=blue>map</font>[string][]byte

    }
    class CreateImageDataReport << (S,Aquamarine) >> {
    }
    class CreateImageOptions << (S,Aquamarine) >> {
        + Layer string
        + Names []string
        + ID string

    }
    class CreateImageReport << (S,Aquamarine) >> {
        + ID string

    }
    class CreateLayerDataOptions << (S,Aquamarine) >> {
        + ID string
        + Data <font color=blue>map</font>[string][]byte

    }
    class CreateLayerDataReport << (S,Aquamarine) >> {
    }
    class CreateLayerOptions << (S,Aquamarine) >> {
        + Parent string
        + ID string

    }
    class CreateLayerReport << (S,Aquamarine) >> {
        + ID string

    }
    class CreateStorageLayerOptions << (S,Aquamarine) >> {
        + Parent string
        + ID string
        + ContentsArchive []byte

    }
    class CreateStorageLayerReport << (S,Aquamarine) >> {
        + ID string

    }
    class DiffOptions << (S,Aquamarine) >> {
        + Format string
        + Latest bool
        + Type define.DiffType

    }
    class DiffReport << (S,Aquamarine) >> {
        + Changes []archive.Change

    }
    class EngineMode << (S,Aquamarine) >> {
        + String() string

    }
    class EventsOptions << (S,Aquamarine) >> {
        + FromStart bool
        + EventChan <font color=blue>chan</font> events.ReadResult
        + Filter []string
        + Stream bool
        + Since string
        + Until string

    }
    class ExecOptions << (S,Aquamarine) >> {
        + Cmd []string
        + DetachKeys string
        + Envs <font color=blue>map</font>[string]string
        + Interactive bool
        + Latest bool
        + PreserveFDs uint
        + PreserveFD []uint
        + Privileged bool
        + Tty bool
        + User string
        + WorkDir string

    }
    class GenerateKubeOptions << (S,Aquamarine) >> {
        + PodmanOnly bool
        + Service bool
        + Type string
        + Replicas int32
        + UseLongAnnotations bool

    }
    class GenerateSpecOptions << (S,Aquamarine) >> {
        + ID string
        + FileName string
        + Compact bool
        + Name bool

    }
    class GenerateSystemdOptions << (S,Aquamarine) >> {
        + Name bool
        + New bool
        + RestartPolicy *string
        + RestartSec *uint
        + StartTimeout *uint
        + StopTimeout *uint
        + ContainerPrefix string
        + PodPrefix string
        + Separator string
        + NoHeader bool
        + TemplateUnitFile bool
        + Wants []string
        + After []string
        + Requires []string
        + AdditionalEnvVariables []string

    }
    class HealthCheckOptions << (S,Aquamarine) >> {
    }
    class IDOrNameResponse << (S,Aquamarine) >> {
        + IDOrName string

    }
    interface IDOrNamed  {
    }
    interface Identifier  {
        + Id() string

    }
    class Image << (S,Aquamarine) >> {
        + ID string
        + RepoTags []string
        + RepoDigests []string
        + Parent string
        + Comment string
        + Created string
        + Container string
        + ContainerConfig *container.Config
        + DockerVersion string
        + Author string
        + Config *container.Config
        + Architecture string
        + Variant string
        + Os string
        + OsVersion string
        + Size int64
        + VirtualSize int64
        + GraphDriver string
        + RootFS string
        + Metadata string
        + Digest digest.Digest
        + PodmanVersion string
        + ManifestType string
        + User string
        + History []v1.History
        + NamesHistory []string
        + HealthCheck *manifest.Schema2HealthConfig

        + Id() string

    }
    interface ImageEngine  {
        + ArtifactAdd(ctx context.Context, name string, paths []string, opts *ArtifactAddOptions) (*ArtifactAddReport, error)
        + ArtifactInspect(ctx context.Context, name string, opts ArtifactInspectOptions) (*ArtifactInspectReport, error)
        + ArtifactList(ctx context.Context, opts ArtifactListOptions) ([]*ArtifactListReport, error)
        + ArtifactPull(ctx context.Context, name string, opts ArtifactPullOptions) (*ArtifactPullReport, error)
        + ArtifactPush(ctx context.Context, name string, opts ArtifactPushOptions) (*ArtifactPushReport, error)
        + ArtifactRm(ctx context.Context, name string, opts ArtifactRemoveOptions) (*ArtifactRemoveReport, error)
        + Build(ctx context.Context, containerFiles []string, opts BuildOptions) (*BuildReport, error)
        + Config(ctx context.Context) (*config.Config, error)
        + Exists(ctx context.Context, nameOrID string) (*BoolReport, error)
        + History(ctx context.Context, nameOrID string, opts ImageHistoryOptions) (*ImageHistoryReport, error)
        + Import(ctx context.Context, opts ImageImportOptions) (*ImageImportReport, error)
        + Inspect(ctx context.Context, namesOrIDs []string, opts InspectOptions) ([]*ImageInspectReport, []error, error)
        + List(ctx context.Context, opts ImageListOptions) ([]*ImageSummary, error)
        + Load(ctx context.Context, opts ImageLoadOptions) (*ImageLoadReport, error)
        + Mount(ctx context.Context, images []string, options ImageMountOptions) ([]*ImageMountReport, error)
        + Prune(ctx context.Context, opts ImagePruneOptions) ([]*reports.PruneReport, error)
        + Pull(ctx context.Context, rawImage string, opts ImagePullOptions) (*ImagePullReport, error)
        + Push(ctx context.Context, source string, destination string, opts ImagePushOptions) (*ImagePushReport, error)
        + Remove(ctx context.Context, images []string, opts ImageRemoveOptions) (*ImageRemoveReport, []error)
        + Save(ctx context.Context, nameOrID string, tags []string, options ImageSaveOptions) error
        + Scp(ctx context.Context, src string, dst string, opts ImageScpOptions) (*ImageScpReport, error)
        + Search(ctx context.Context, term string, opts ImageSearchOptions) ([]ImageSearchReport, error)
        + SetTrust(ctx context.Context, args []string, options SetTrustOptions) error
        + ShowTrust(ctx context.Context, args []string, options ShowTrustOptions) (*ShowTrustReport, error)
        + Shutdown(ctx context.Context) 
        + Tag(ctx context.Context, nameOrID string, tags []string, options ImageTagOptions) error
        + Tree(ctx context.Context, nameOrID string, options ImageTreeOptions) (*ImageTreeReport, error)
        + Unmount(ctx context.Context, images []string, options ImageUnmountOptions) ([]*ImageUnmountReport, error)
        + Untag(ctx context.Context, nameOrID string, tags []string, options ImageUntagOptions) error
        + ManifestCreate(ctx context.Context, name string, images []string, opts ManifestCreateOptions) (string, error)
        + ManifestExists(ctx context.Context, name string) (*BoolReport, error)
        + ManifestInspect(ctx context.Context, name string, opts ManifestInspectOptions) (*define.ManifestListData, error)
        + ManifestAdd(ctx context.Context, listName string, imageNames []string, opts ManifestAddOptions) (string, error)
        + ManifestAddArtifact(ctx context.Context, name string, files []string, opts ManifestAddArtifactOptions) (string, error)
        + ManifestAnnotate(ctx context.Context, names string, image string, opts ManifestAnnotateOptions) (string, error)
        + ManifestRemoveDigest(ctx context.Context, names string, image string) (string, error)
        + ManifestRm(ctx context.Context, names []string, imageRmOpts ImageRemoveOptions) (*ImageRemoveReport, []error)
        + ManifestPush(ctx context.Context, name string, destination string, imagePushOpts ImagePushOptions) (string, error)
        + ManifestListClear(ctx context.Context, name string) (string, error)
        + Sign(ctx context.Context, names []string, options SignOptions) (*SignReport, error)
        + FarmNodeName(ctx context.Context) string
        + FarmNodeDriver(ctx context.Context) string
        + FarmNodeInspect(ctx context.Context) (*FarmInspectReport, error)

    }
    class ImageHistoryOptions << (S,Aquamarine) >> {
    }
    class ImageImportOptions << (S,Aquamarine) >> {
        + Architecture string
        + Variant string
        + Changes []string
        + Message string
        + OS string
        + Quiet bool
        + Reference string
        + SignaturePolicy string
        + Source string
        + SourceIsURL bool

    }
    class ImageListOptions << (S,Aquamarine) >> {
        + All bool
        + ExtendedAttributes bool
        + Filter []string

    }
    class ImageLoadOptions << (S,Aquamarine) >> {
        + Input string
        + Quiet bool
        + SignaturePolicy string

    }
    class ImageMountOptions << (S,Aquamarine) >> {
        + All bool
        + Format string

    }
    class ImagePruneOptions << (S,Aquamarine) >> {
        + All bool
        + External bool
        + BuildCache bool
        + Filter []string

    }
    class ImagePullOptions << (S,Aquamarine) >> {
        + AllTags bool
        + Authfile string
        + CertDir string
        + Username string
        + Password string
        + Arch string
        + OS string
        + Variant string
        + Quiet bool
        + Retry *uint
        + RetryDelay string
        + SignaturePolicy string
        + SkipTLSVerify types.OptionalBool
        + PullPolicy config.PullPolicy
        + Writer io.Writer
        + OciDecryptConfig *config.DecryptConfig

    }
    class ImagePushOptions << (S,Aquamarine) >> {
        + All bool
        + Authfile string
        + CertDir string
        + Compress bool
        + Username string
        + Password string
        + Format string
        + Quiet bool
        + Rm bool
        + RemoveSignatures bool
        + Retry *uint
        + RetryDelay string
        + SignaturePolicy string
        + Signers []*signer.Signer
        + SignBy string
        + SignPassphrase string
        + SignBySigstorePrivateKeyFile string
        + SignSigstorePrivateKeyPassphrase []byte
        + SkipTLSVerify types.OptionalBool
        + Progress <font color=blue>chan</font> types.ProgressProperties
        + CompressionFormat string
        + CompressionLevel *int
        + Writer io.Writer
        + OciEncryptConfig *config.EncryptConfig
        + OciEncryptLayers *[]int
        + AddCompression []string
        + ForceCompressionFormat bool

    }
    class ImagePushReport << (S,Aquamarine) >> {
        + ManifestDigest string

    }
    class ImageRemoveOptions << (S,Aquamarine) >> {
        + All bool
        + Force bool
        + Ignore bool
        + LookupManifest bool
        + NoPrune bool

    }
    class ImageSaveOptions << (S,Aquamarine) >> {
        + Compress bool
        + Format string
        + MultiImageArchive bool
        + OciAcceptUncompressedLayers bool
        + Output string
        + Quiet bool
        + SignaturePolicy string

    }
    class ImageScpConnections << (S,Aquamarine) >> {
        + Connections []string
        + URI []*url.URL
        + Identities []string

    }
    class ImageScpOptions << (S,Aquamarine) >> {
    }
    class ImageScpReport << (S,Aquamarine) >> {
    }
    class ImageSearchOptions << (S,Aquamarine) >> {
        + Authfile string
        + CertDir string
        + Username string
        + Password string
        + IdentityToken string
        + Filters []string
        + Limit int
        + SkipTLSVerify types.OptionalBool
        + ListTags bool

    }
    class ImageTagOptions << (S,Aquamarine) >> {
    }
    class ImageTreeOptions << (S,Aquamarine) >> {
        + WhatRequires bool

    }
    class ImageUnmountOptions << (S,Aquamarine) >> {
        + All bool
        + Force bool

    }
    class ImageUntagOptions << (S,Aquamarine) >> {
    }
    class InspectOptions << (S,Aquamarine) >> {
        + Format string
        + Latest bool
        + Size bool
        + Type string
        + All bool

    }
    class KillOptions << (S,Aquamarine) >> {
        + All bool
        + Latest bool
        + Signal string

    }
    class KillReport << (S,Aquamarine) >> {
        + Err error
        + Id string
        + RawInput string

    }
    class ListReporter << (S,Aquamarine) >> {
        + Name string
        + Default bool
        + Created string
        + Running bool
        + Starting bool
        + LastUp string
        + Stream string
        + VMType string
        + CPUs uint64
        + Memory string
        + DiskSize string
        + Port int
        + RemoteUsername string
        + IdentityPath string
        + UserModeNetworking bool

    }
    class MachineHostInfo << (S,Aquamarine) >> {
        + Arch string
        + CurrentMachine string
        + DefaultMachine string
        + EventsDir string
        + MachineConfigDir string
        + MachineImageDir string
        + MachineState string
        + NumberOfMachines int
        + OS string
        + VMType string

    }
    class MachineInfo << (S,Aquamarine) >> {
        + Host *MachineHostInfo
        + Version define.Version

    }
    class ManifestAddArtifactOptions << (S,Aquamarine) >> {
        + Type *string
        + LayerType string
        + ConfigType string
        + Config string
        + ExcludeTitles bool
        + Annotations <font color=blue>map</font>[string]string
        + Subject string
        + Files []string

    }
    class ManifestAddOptions << (S,Aquamarine) >> {
        + All bool
        + Authfile string
        + CertDir string
        + Password string
        + SkipTLSVerify types.OptionalBool
        + Username string
        + Images []string

    }
    class ManifestAnnotateOptions << (S,Aquamarine) >> {
        + Annotation []string
        + Annotations <font color=blue>map</font>[string]string
        + Arch string
        + Features []string
        + OS string
        + OSFeatures []string
        + OSVersion string
        + Variant string
        + IndexAnnotation []string
        + IndexAnnotations <font color=blue>map</font>[string]string
        + IndexSubject string

    }
    class ManifestCreateOptions << (S,Aquamarine) >> {
        + All bool
        + Amend bool
        + SkipTLSVerify types.OptionalBool
        + Annotations <font color=blue>map</font>[string]string

    }
    class ManifestInspectOptions << (S,Aquamarine) >> {
        + Authfile string
        + SkipTLSVerify types.OptionalBool

    }
    class ManifestModifyOptions << (S,Aquamarine) >> {
        + Operation string
        + ArtifactType *string
        + ArtifactLayerType string
        + ArtifactConfigType string
        + ArtifactConfig string
        + ArtifactExcludeTitles bool
        + ArtifactAnnotations <font color=blue>map</font>[string]string
        + ArtifactSubject string
        + ArtifactFiles []string

    }
    class ManifestRemoveOptions << (S,Aquamarine) >> {
    }
    class ModifyContainerDataOptions << (S,Aquamarine) >> {
        + ID string
        + Key string
        + Data []byte

    }
    class ModifyContainerDataReport << (S,Aquamarine) >> {
    }
    class ModifyImageDataOptions << (S,Aquamarine) >> {
        + ID string
        + Key string
        + Data []byte

    }
    class ModifyImageDataReport << (S,Aquamarine) >> {
    }
    class ModifyLayerDataOptions << (S,Aquamarine) >> {
        + ID string
        + Key string
        + Data []byte

    }
    class ModifyLayerDataReport << (S,Aquamarine) >> {
    }
    class ModifyLayerOptions << (S,Aquamarine) >> {
        + ID string
        + ContentsArchive []byte

    }
    class ModifyLayerReport << (S,Aquamarine) >> {
    }
    interface Named  {
        + Name() string

    }
    interface Names  {
        + Names() []string

    }
    class NetFlags << (S,Aquamarine) >> {
        + AddHosts []string
        + DNS []string
        + DNSOpt []string
        + DNDSearch []string
        + MacAddr string
        + Publish []string
        + IP string
        + NoHostname bool
        + NoHosts bool
        + Network string
        + NetworkAlias []string

    }
    class NetOptions << (S,Aquamarine) >> {
        + AddHosts []string
        + Aliases []string
        + Networks <font color=blue>map</font>[string]types.PerNetworkOptions
        + UseImageResolvConf bool
        + DNSOptions []string
        + DNSSearch []string
        + DNSServers []net.IP
        + HostsFile string
        + Network specgen.Namespace
        + NoHostname bool
        + NoHosts bool
        + PublishPorts []types.PortMapping
        + NetworkOptions <font color=blue>map</font>[string][]string

    }
    class NetworkCreateOptions << (S,Aquamarine) >> {
        + DisableDNS bool
        + Driver string
        + Gateways []net.IP
        + Internal bool
        + Labels <font color=blue>map</font>[string]string
        + MacVLAN string
        + NetworkDNSServers []string
        + Ranges []string
        + Subnets []string
        + Routes []string
        + IPv6 bool
        + Options <font color=blue>map</font>[string]string
        + IgnoreIfExists bool
        + InterfaceName string

    }
    class NetworkDisconnectOptions << (S,Aquamarine) >> {
        + Container string
        + Force bool

    }
    class NetworkListOptions << (S,Aquamarine) >> {
        + Format string
        + Quiet bool
        + Filters <font color=blue>map</font>[string][]string

    }
    class NetworkPruneOptions << (S,Aquamarine) >> {
        + Filters <font color=blue>map</font>[string][]string

    }
    class NetworkReloadOptions << (S,Aquamarine) >> {
        + All bool
        + Latest bool

    }
    class NetworkRmOptions << (S,Aquamarine) >> {
        + Force bool
        + Timeout *uint

    }
    class NetworkUpdateOptions << (S,Aquamarine) >> {
        + AddDNSServers []string
        + RemoveDNSServers []string

    }
    class PauseUnPauseOptions << (S,Aquamarine) >> {
        + Filters <font color=blue>map</font>[string][]string
        + All bool
        + Latest bool

    }
    class PauseUnpauseReport << (S,Aquamarine) >> {
        + Err error
        + Id string
        + RawInput string

    }
    class PlayKubeDownOptions << (S,Aquamarine) >> {
        + Force bool

    }
    class PlayKubeOptions << (S,Aquamarine) >> {
        + Annotations <font color=blue>map</font>[string]string
        + Authfile string
        + Build types.OptionalBool
        + CertDir string
        + ContextDir string
        + Down bool
        + ExitCodePropagation string
        + Replace bool
        + NoHostname bool
        + NoHosts bool
        + Username string
        + Password string
        + Networks []string
        + Quiet bool
        + SignaturePolicy string
        + SkipTLSVerify types.OptionalBool
        + SeccompProfileRoot string
        + StaticIPs []net.IP
        + StaticMACs []net.HardwareAddr
        + ConfigMaps []string
        + LogDriver string
        + LogOptions []string
        + Start types.OptionalBool
        + ServiceContainer bool
        + UseLongAnnotations bool
        + Userns string
        + IsRemote bool
        + Force bool
        + PublishPorts []string
        + PublishAllPorts bool
        + Wait bool
        + SystemContext *types.SystemContext

    }
    class PodCloneOptions << (S,Aquamarine) >> {
        + ID string
        + Destroy bool
        + CreateOpts PodCreateOptions
        + InfraOptions ContainerCreateOptions
        + PerContainerOptions ContainerCreateOptions
        + Start bool

    }
    class PodCreateOptions << (S,Aquamarine) >> {
        + CgroupParent string
        + CreateCommand []string
        + Devices []string
        + DeviceReadBPs []string
        + ExitPolicy string
        + Hostname string
        + Infra bool
        + InfraImage string
        + InfraName string
        + InfraCommand *string
        + InfraConmonPidFile string
        + Ipc string
        + Labels <font color=blue>map</font>[string]string
        + Name string
        + Net *NetOptions
        + Share []string
        + ShareParent *bool
        + Restart string
        + Pid string
        + Cpus float64
        + CpusetCpus string
        + Userns specgen.Namespace
        + Volume []string
        + VolumesFrom []string
        + SecurityOpt []string
        + Sysctl []string
        + Uts string

        + CPULimits() *specs.LinuxCPU

    }
    class PodDeleteReport << (S,Aquamarine) >> {
    }
    class PodKillOptions << (S,Aquamarine) >> {
        + All bool
        + Latest bool
        + Signal string

    }
    class PodLogsOptions << (S,Aquamarine) >> {
        + ContainerName string
        + Color bool

    }
    class PodPSOptions << (S,Aquamarine) >> {
        + CtrNames bool
        + CtrIds bool
        + CtrStatus bool
        + Filters <font color=blue>map</font>[string][]string
        + Format string
        + Latest bool
        + Namespace bool
        + Quiet bool
        + Sort string

    }
    class PodPauseOptions << (S,Aquamarine) >> {
        + All bool
        + Latest bool

    }
    class PodPruneOptions << (S,Aquamarine) >> {
        + Force bool

    }
    class PodRestartOptions << (S,Aquamarine) >> {
        + All bool
        + Latest bool

    }
    class PodRmOptions << (S,Aquamarine) >> {
        + All bool
        + Force bool
        + Ignore bool
        + Latest bool
        + Timeout *uint

    }
    class PodStartOptions << (S,Aquamarine) >> {
        + All bool
        + Latest bool

    }
    class PodStatsOptions << (S,Aquamarine) >> {
        + All bool
        + Latest bool

    }
    class PodStopOptions << (S,Aquamarine) >> {
        + All bool
        + Ignore bool
        + Latest bool
        + Timeout int

    }
    class PodTopOptions << (S,Aquamarine) >> {
        + ListDescriptors bool
        + Latest bool
        + Descriptors []string
        + NameOrID string

    }
    class PodmanConfig << (S,Aquamarine) >> {
        + ContainersConf *config.Config
        + ContainersConfDefaultsRO *config.Config
        + DBBackend string
        + DockerConfig string
        + CgroupUsage string
        + ConmonPath string
        + CPUProfile string
        + EngineMode EngineMode
        + HooksDir []string
        + Identity string
        + IsRenumber bool
        + IsReset bool
        + MaxWorks int
        + MemoryProfile string
        + RegistriesConf string
        + Remote bool
        + RuntimePath string
        + RuntimeFlags []string
        + Syslog bool
        + Trace bool
        + URI string
        + FarmNodeName string
        + ConnectionError error
        + Runroot string
        + ImageStore string
        + StorageDriver string
        + StorageOpts []string
        + SSHMode string
        + MachineMode bool
        + TransientStore bool
        + GraphRoot string
        + PullOptions []string

    }
    class PodunpauseOptions << (S,Aquamarine) >> {
        + All bool
        + Latest bool

    }
    class PopulateLayerOptions << (S,Aquamarine) >> {
        + ID string
        + ContentsArchive []byte

    }
    class PopulateLayerReport << (S,Aquamarine) >> {
    }
    class PsSortedCreateTime << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class RemoveContainerDataOptions << (S,Aquamarine) >> {
        + ID string
        + Key string

    }
    class RemoveContainerDataReport << (S,Aquamarine) >> {
    }
    class RemoveContainerOptions << (S,Aquamarine) >> {
        + ID string

    }
    class RemoveContainerReport << (S,Aquamarine) >> {
        + ID string

    }
    class RemoveImageDataOptions << (S,Aquamarine) >> {
        + ID string
        + Key string

    }
    class RemoveImageDataReport << (S,Aquamarine) >> {
    }
    class RemoveImageOptions << (S,Aquamarine) >> {
        + ID string

    }
    class RemoveImageReport << (S,Aquamarine) >> {
        + ID string

    }
    class RemoveLayerDataOptions << (S,Aquamarine) >> {
        + ID string
        + Key string

    }
    class RemoveLayerDataReport << (S,Aquamarine) >> {
    }
    class RemoveLayerOptions << (S,Aquamarine) >> {
        + ID string

    }
    class RemoveLayerReport << (S,Aquamarine) >> {
        + ID string

    }
    class RemoveStorageLayerOptions << (S,Aquamarine) >> {
        + ID string

    }
    class RemoveStorageLayerReport << (S,Aquamarine) >> {
        + ID string

    }
    class Report << (S,Aquamarine) >> {
        + Id []string
        + Err <font color=blue>map</font>[string]error

    }
    class RestartOptions << (S,Aquamarine) >> {
        + Filters <font color=blue>map</font>[string][]string
        + All bool
        + Latest bool
        + Running bool
        + Timeout *uint

    }
    class RestartReport << (S,Aquamarine) >> {
        + Err error
        + Id string
        + RawInput string

    }
    class RestoreOptions << (S,Aquamarine) >> {
        + All bool
        + IgnoreRootFS bool
        + IgnoreVolumes bool
        + IgnoreStaticIP bool
        + IgnoreStaticMAC bool
        + Import string
        + CheckpointImage bool
        + Keep bool
        + Latest bool
        + Name string
        + TCPEstablished bool
        + ImportPrevious string
        + PublishPorts []string
        + Pod string
        + PrintStats bool
        + FileLocks bool

    }
    class RmOptions << (S,Aquamarine) >> {
        + Filters <font color=blue>map</font>[string][]string
        + All bool
        + Depend bool
        + Force bool
        + Ignore bool
        + Latest bool
        + Timeout *uint
        + Volumes bool

    }
    class ScpCreateCommandsOptions << (S,Aquamarine) >> {
        + ParentFlags []string
        + Podman string

    }
    class ScpExecuteTransferOptions << (S,Aquamarine) >> {
        + ParentFlags []string
        + Quiet bool
        + SSHMode ssh.EngineMode

    }
    class ScpExecuteTransferReport << (S,Aquamarine) >> {
        + LoadReport *ScpLoadReport
        + Source *ScpTransferImageOptions
        + Dest *ScpTransferImageOptions
        + ParentFlags []string

    }
    class ScpLoadToRemoteOptions << (S,Aquamarine) >> {
        + Dest ScpTransferImageOptions
        + LocalFile string
        + Tag string
        + URL *url.URL
        + Iden string
        + SSHMode ssh.EngineMode

    }
    class ScpLoadToRemoteReport << (S,Aquamarine) >> {
        + Response string
        + ID string

    }
    class ScpSaveToRemoteOptions << (S,Aquamarine) >> {
        + Image string
        + LocalFile string
        + Tag string
        + URL *url.URL
        + Iden string
        + SSHMode ssh.EngineMode

    }
    class ScpSaveToRemoteReport << (S,Aquamarine) >> {
    }
    class ScpTransferImageOptions << (S,Aquamarine) >> {
        + Remote bool
        + File string
        + Quiet bool
        + Image string
        + User string
        + Tag string

    }
    class ScpTransferOptions << (S,Aquamarine) >> {
        + ParentFlags []string

    }
    class ScpTransferReport << (S,Aquamarine) >> {
    }
    class SecretCreateOptions << (S,Aquamarine) >> {
        + Driver string
        + DriverOpts <font color=blue>map</font>[string]string
        + Labels <font color=blue>map</font>[string]string
        + Replace bool

    }
    class SecretCreateRequest << (S,Aquamarine) >> {
        + Name string
        + Data string
        + Driver SecretDriverSpec
        + Labels <font color=blue>map</font>[string]string

    }
    class SecretInspectOptions << (S,Aquamarine) >> {
        + ShowSecret bool

    }
    class SecretListRequest << (S,Aquamarine) >> {
        + Filters <font color=blue>map</font>[string][]string

    }
    class SecretRmOptions << (S,Aquamarine) >> {
        + All bool
        + Ignore bool

    }
    class SetTrustOptions << (S,Aquamarine) >> {
        + PolicyPath string
        + PubKeysFile []string
        + Type string

    }
    class ShowTrustOptions << (S,Aquamarine) >> {
        + JSON bool
        + PolicyPath string
        + Raw bool
        + RegistryPath string

    }
    class SignOptions << (S,Aquamarine) >> {
        + Directory string
        + SignBy string
        + CertDir string
        + Authfile string
        + All bool

    }
    class SignReport << (S,Aquamarine) >> {
    }
    class SortListContainers << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, j int) 

    }
    class StopOptions << (S,Aquamarine) >> {
        + Filters <font color=blue>map</font>[string][]string
        + All bool
        + Ignore bool
        + Latest bool
        + Timeout *uint

    }
    class StopReport << (S,Aquamarine) >> {
        + Err error
        + Id string
        + RawInput string

    }
    class StringSet << (S,Aquamarine) >> {
        + Add(elem string) 
        + Remove(elem string) 
        + Contains(elem string) bool
        + Elements() []string
        + String() string

    }
    class StringSliceReport << (S,Aquamarine) >> {
        + Value []string

    }
    class SwagErrNoSuchSecret << (S,Aquamarine) >> {
        + Body <font color=blue>struct</font>{errorhandling.ErrorModel}

    }
    class SwagErrSecretInUse << (S,Aquamarine) >> {
        + Body <font color=blue>struct</font>{errorhandling.ErrorModel}

    }
    class SwagSecretCreateResponse << (S,Aquamarine) >> {
        + Body <font color=blue>struct</font>{SecretCreateReport}

    }
    class SwagSecretInspectCompatResponse << (S,Aquamarine) >> {
        + Body SecretInfoReportCompat

    }
    class SwagSecretInspectResponse << (S,Aquamarine) >> {
        + Body SecretInfoReport

    }
    class SwagSecretListCompatResponse << (S,Aquamarine) >> {
        + Body []*SecretInfoReportCompat

    }
    class SwagSecretListResponse << (S,Aquamarine) >> {
        + Body []*SecretInfoReport

    }
    interface TestingEngine  {
        + CreateStorageLayer(ctx context.Context, opts CreateStorageLayerOptions) (*CreateStorageLayerReport, error)
        + CreateLayer(ctx context.Context, opts CreateLayerOptions) (*CreateLayerReport, error)
        + CreateLayerData(ctx context.Context, opts CreateLayerDataOptions) (*CreateLayerDataReport, error)
        + CreateImage(ctx context.Context, opts CreateImageOptions) (*CreateImageReport, error)
        + CreateImageData(ctx context.Context, opts CreateImageDataOptions) (*CreateImageDataReport, error)
        + CreateContainer(ctx context.Context, opts CreateContainerOptions) (*CreateContainerReport, error)
        + CreateContainerData(ctx context.Context, opts CreateContainerDataOptions) (*CreateContainerDataReport, error)
        + ModifyLayer(ctx context.Context, opts ModifyLayerOptions) (*ModifyLayerReport, error)
        + PopulateLayer(ctx context.Context, opts PopulateLayerOptions) (*PopulateLayerReport, error)
        + RemoveStorageLayer(ctx context.Context, opts RemoveStorageLayerOptions) (*RemoveStorageLayerReport, error)
        + RemoveLayer(ctx context.Context, opts RemoveLayerOptions) (*RemoveLayerReport, error)
        + RemoveImage(ctx context.Context, opts RemoveImageOptions) (*RemoveImageReport, error)
        + RemoveContainer(ctx context.Context, opts RemoveContainerOptions) (*RemoveContainerReport, error)
        + RemoveLayerData(ctx context.Context, opts RemoveLayerDataOptions) (*RemoveLayerDataReport, error)
        + RemoveImageData(ctx context.Context, opts RemoveImageDataOptions) (*RemoveImageDataReport, error)
        + RemoveContainerData(ctx context.Context, opts RemoveContainerDataOptions) (*RemoveContainerDataReport, error)
        + ModifyLayerData(ctx context.Context, opts ModifyLayerDataOptions) (*ModifyLayerDataReport, error)
        + ModifyImageData(ctx context.Context, opts ModifyImageDataOptions) (*ModifyImageDataReport, error)
        + ModifyContainerData(ctx context.Context, opts ModifyContainerDataOptions) (*ModifyContainerDataReport, error)

    }
    class TopOptions << (S,Aquamarine) >> {
        + ListDescriptors bool
        + Latest bool
        + Descriptors []string
        + NameOrID string

    }
    class Volume << (S,Aquamarine) >> {
    }
    class VolumeDeleteOptions << (S,Aquamarine) >> {
    }
    class VolumeDeleteReport << (S,Aquamarine) >> {
    }
    class VolumeListOptions << (S,Aquamarine) >> {
        + Filter <font color=blue>map</font>[string][]string

    }
    class VolumePruneOptions << (S,Aquamarine) >> {
        + Filters url.Values

    }
    class VolumeRmOptions << (S,Aquamarine) >> {
        + All bool
        + Force bool
        + Ignore bool
        + Timeout *uint

    }
    class WaitOptions << (S,Aquamarine) >> {
        + Conditions []string
        + Interval time.Duration
        + Ignore bool
        + Latest bool

    }
    class WaitReport << (S,Aquamarine) >> {
        + Error error
        + ExitCode int32

    }
    class entities.AuthConfig << (T, #FF7700) >>  {
    }
    class entities.AuthReport << (T, #FF7700) >>  {
    }
    class entities.BuildOptions << (T, #FF7700) >>  {
    }
    class entities.BuildReport << (T, #FF7700) >>  {
    }
    class entities.CheckpointReport << (T, #FF7700) >>  {
    }
    class entities.ComponentVersion << (T, #FF7700) >>  {
    }
    class entities.ContainerCopyFunc << (T, #FF7700) >>  {
    }
    class entities.ContainerCreateResponse << (T, #FF7700) >>  {
    }
    class entities.ContainerFilter << (T, #FF7700) >>  {
    }
    class entities.ContainerMode << (T, #FF7700) >>  {
    }
    class entities.ContainerStatReport << (T, #FF7700) >>  {
    }
    class entities.ContainerStatsReport << (T, #FF7700) >>  {
    }
    class entities.ContainerUpdateOptions << (T, #FF7700) >>  {
    }
    class entities.EngineMode << (T, #FF7700) >>  {
    }
    class entities.EngineSetup << (T, #FF7700) >>  {
    }
    class entities.Event << (T, #FF7700) >>  {
    }
    class entities.FarmBuildOptions << (T, #FF7700) >>  {
    }
    class entities.FarmInspectReport << (T, #FF7700) >>  {
    }
    class entities.GenerateKubeReport << (T, #FF7700) >>  {
    }
    class entities.GenerateSpecReport << (T, #FF7700) >>  {
    }
    class entities.GenerateSystemdReport << (T, #FF7700) >>  {
    }
    class entities.IDResponse << (T, #FF7700) >>  {
    }
    class entities.ImageFilter << (T, #FF7700) >>  {
    }
    class entities.ImageHistoryLayer << (T, #FF7700) >>  {
    }
    class entities.ImageHistoryReport << (T, #FF7700) >>  {
    }
    class entities.ImageImportReport << (T, #FF7700) >>  {
    }
    class entities.ImageInspectReport << (T, #FF7700) >>  {
    }
    class entities.ImageLoadReport << (T, #FF7700) >>  {
    }
    class entities.ImageMountReport << (T, #FF7700) >>  {
    }
    class entities.ImagePullReport << (T, #FF7700) >>  {
    }
    class entities.ImagePushStream << (T, #FF7700) >>  {
    }
    class entities.ImageRemoveReport << (T, #FF7700) >>  {
    }
    class entities.ImageSearchReport << (T, #FF7700) >>  {
    }
    class entities.ImageSummary << (T, #FF7700) >>  {
    }
    class entities.ImageTreeReport << (T, #FF7700) >>  {
    }
    class entities.ImageUnmountReport << (T, #FF7700) >>  {
    }
    class entities.KubeGenerateOptions << (T, #FF7700) >>  {
    }
    class entities.KubePlayReport << (T, #FF7700) >>  {
    }
    class entities.ListContainer << (T, #FF7700) >>  {
    }
    class entities.ListContainerNamespaces << (T, #FF7700) >>  {
    }
    class entities.ListPodContainer << (T, #FF7700) >>  {
    }
    class entities.ListPodsReport << (T, #FF7700) >>  {
    }
    class entities.ListRegistriesReport << (T, #FF7700) >>  {
    }
    class entities.LocksReport << (T, #FF7700) >>  {
    }
    class entities.ManifestModifyReport << (T, #FF7700) >>  {
    }
    class entities.ManifestPushReport << (T, #FF7700) >>  {
    }
    class entities.ManifestRemoveReport << (T, #FF7700) >>  {
    }
    class entities.NetworkConnectOptions << (T, #FF7700) >>  {
    }
    class entities.NetworkContainerInfo << (T, #FF7700) >>  {
    }
    class entities.NetworkCreateReport << (T, #FF7700) >>  {
    }
    class entities.NetworkInspectReport << (T, #FF7700) >>  {
    }
    class entities.NetworkPruneReport << (T, #FF7700) >>  {
    }
    class entities.NetworkReloadReport << (T, #FF7700) >>  {
    }
    class entities.NetworkRmReport << (T, #FF7700) >>  {
    }
    class entities.PlayKubePod << (T, #FF7700) >>  {
    }
    class entities.PlayKubeReport << (T, #FF7700) >>  {
    }
    class entities.PlayKubeTeardown << (T, #FF7700) >>  {
    }
    class entities.PlayKubeVolume << (T, #FF7700) >>  {
    }
    class entities.PlaySecret << (T, #FF7700) >>  {
    }
    class entities.PodCloneReport << (T, #FF7700) >>  {
    }
    class entities.PodCreateReport << (T, #FF7700) >>  {
    }
    class entities.PodInspectReport << (T, #FF7700) >>  {
    }
    class entities.PodKillReport << (T, #FF7700) >>  {
    }
    class entities.PodPauseReport << (T, #FF7700) >>  {
    }
    class entities.PodPruneReport << (T, #FF7700) >>  {
    }
    class entities.PodRestartReport << (T, #FF7700) >>  {
    }
    class entities.PodRmReport << (T, #FF7700) >>  {
    }
    class entities.PodSpec << (T, #FF7700) >>  {
    }
    class entities.PodStartReport << (T, #FF7700) >>  {
    }
    class entities.PodStatsReport << (T, #FF7700) >>  {
    }
    class entities.PodStopReport << (T, #FF7700) >>  {
    }
    class entities.PodUnpauseReport << (T, #FF7700) >>  {
    }
    class entities.RestoreReport << (T, #FF7700) >>  {
    }
    class entities.ScpLoadReport << (T, #FF7700) >>  {
    }
    class entities.SecretCreateReport << (T, #FF7700) >>  {
    }
    class entities.SecretDriverSpec << (T, #FF7700) >>  {
    }
    class entities.SecretInfoReport << (T, #FF7700) >>  {
    }
    class entities.SecretInfoReportCompat << (T, #FF7700) >>  {
    }
    class entities.SecretListReport << (T, #FF7700) >>  {
    }
    class entities.SecretRmReport << (T, #FF7700) >>  {
    }
    class entities.SecretSpec << (T, #FF7700) >>  {
    }
    class entities.SecretVersion << (T, #FF7700) >>  {
    }
    class entities.ServiceOptions << (T, #FF7700) >>  {
    }
    class entities.ShowTrustReport << (T, #FF7700) >>  {
    }
    class entities.SortListContainers << (T, #FF7700) >>  {
    }
    class entities.SystemCheckOptions << (T, #FF7700) >>  {
    }
    class entities.SystemCheckReport << (T, #FF7700) >>  {
    }
    class entities.SystemDfContainerReport << (T, #FF7700) >>  {
    }
    class entities.SystemDfImageReport << (T, #FF7700) >>  {
    }
    class entities.SystemDfOptions << (T, #FF7700) >>  {
    }
    class entities.SystemDfReport << (T, #FF7700) >>  {
    }
    class entities.SystemDfVolumeReport << (T, #FF7700) >>  {
    }
    class entities.SystemMigrateOptions << (T, #FF7700) >>  {
    }
    class entities.SystemPruneOptions << (T, #FF7700) >>  {
    }
    class entities.SystemPruneReport << (T, #FF7700) >>  {
    }
    class entities.SystemUnshareOptions << (T, #FF7700) >>  {
    }
    class entities.SystemVersionReport << (T, #FF7700) >>  {
    }
    class entities.VolumeConfigResponse << (T, #FF7700) >>  {
    }
    class entities.VolumeCreateOptions << (T, #FF7700) >>  {
    }
    class entities.VolumeFilter << (T, #FF7700) >>  {
    }
    class entities.VolumeInspectReport << (T, #FF7700) >>  {
    }
    class entities.VolumeListReport << (T, #FF7700) >>  {
    }
    class entities.VolumeMountReport << (T, #FF7700) >>  {
    }
    class entities.VolumeReloadReport << (T, #FF7700) >>  {
    }
    class entities.VolumeRmReport << (T, #FF7700) >>  {
    }
    class entities.VolumeUnmountReport << (T, #FF7700) >>  {
    }
    class psSortedCommand << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class psSortedID << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class psSortedImage << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class psSortedNames << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class psSortedPod << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class psSortedRunningFor << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class psSortedSize << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class psSortedStatus << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class "types.AuthConfig" as typesAuthConfig {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.AuthReport" as typesAuthReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.BuildOptions" as typesBuildOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.BuildReport" as typesBuildReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.CheckpointReport" as typesCheckpointReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ContainerCopyFunc" as typesContainerCopyFunc {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ContainerCreateResponse" as typesContainerCreateResponse {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ContainerStatReport" as typesContainerStatReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ContainerStatsReport" as typesContainerStatsReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ContainerUpdateOptions" as typesContainerUpdateOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.Event" as typesEvent {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.FarmBuildOptions" as typesFarmBuildOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.FarmInspectReport" as typesFarmInspectReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.GenerateKubeReport" as typesGenerateKubeReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.GenerateSpecReport" as typesGenerateSpecReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.GenerateSystemdReport" as typesGenerateSystemdReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.IDResponse" as typesIDResponse {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ImageHistoryLayer" as typesImageHistoryLayer {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ImageHistoryReport" as typesImageHistoryReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ImageImportReport" as typesImageImportReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ImageInspectReport" as typesImageInspectReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ImageLoadReport" as typesImageLoadReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ImageMountReport" as typesImageMountReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ImagePullReport" as typesImagePullReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ImagePushStream" as typesImagePushStream {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ImageRemoveReport" as typesImageRemoveReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ImageSearchReport" as typesImageSearchReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ImageSummary" as typesImageSummary {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ImageTreeReport" as typesImageTreeReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ImageUnmountReport" as typesImageUnmountReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.KubePlayReport" as typesKubePlayReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ListContainer" as typesListContainer {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ListContainerNamespaces" as typesListContainerNamespaces {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ListPodContainer" as typesListPodContainer {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ListPodsReport" as typesListPodsReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ListRegistriesReport" as typesListRegistriesReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.LocksReport" as typesLocksReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ManifestModifyReport" as typesManifestModifyReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ManifestPushReport" as typesManifestPushReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ManifestRemoveReport" as typesManifestRemoveReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.NetworkConnectOptions" as typesNetworkConnectOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.NetworkContainerInfo" as typesNetworkContainerInfo {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.NetworkCreateReport" as typesNetworkCreateReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.NetworkInspectReport" as typesNetworkInspectReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.NetworkPruneReport" as typesNetworkPruneReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.NetworkReloadReport" as typesNetworkReloadReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.NetworkRmReport" as typesNetworkRmReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PlayKubePod" as typesPlayKubePod {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PlayKubeReport" as typesPlayKubeReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PlayKubeTeardown" as typesPlayKubeTeardown {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PlayKubeVolume" as typesPlayKubeVolume {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PlaySecret" as typesPlaySecret {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PodCloneReport" as typesPodCloneReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PodCreateReport" as typesPodCreateReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PodInspectReport" as typesPodInspectReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PodKillReport" as typesPodKillReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PodPauseReport" as typesPodPauseReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PodPruneReport" as typesPodPruneReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PodRestartReport" as typesPodRestartReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PodRmReport" as typesPodRmReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PodSpec" as typesPodSpec {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PodStartReport" as typesPodStartReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PodStatsReport" as typesPodStatsReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PodStopReport" as typesPodStopReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.PodUnpauseReport" as typesPodUnpauseReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.RestoreReport" as typesRestoreReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SecretCreateReport" as typesSecretCreateReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SecretDriverSpec" as typesSecretDriverSpec {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SecretInfoReport" as typesSecretInfoReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SecretInfoReportCompat" as typesSecretInfoReportCompat {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SecretListReport" as typesSecretListReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SecretRmReport" as typesSecretRmReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SecretSpec" as typesSecretSpec {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SecretVersion" as typesSecretVersion {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ServiceOptions" as typesServiceOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.ShowTrustReport" as typesShowTrustReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SystemCheckOptions" as typesSystemCheckOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SystemCheckReport" as typesSystemCheckReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SystemComponentVersion" as typesSystemComponentVersion {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SystemDfContainerReport" as typesSystemDfContainerReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SystemDfImageReport" as typesSystemDfImageReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SystemDfOptions" as typesSystemDfOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SystemDfReport" as typesSystemDfReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SystemDfVolumeReport" as typesSystemDfVolumeReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SystemMigrateOptions" as typesSystemMigrateOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SystemPruneOptions" as typesSystemPruneOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SystemPruneReport" as typesSystemPruneReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SystemUnshareOptions" as typesSystemUnshareOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.SystemVersionReport" as typesSystemVersionReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.VolumeConfigResponse" as typesVolumeConfigResponse {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.VolumeCreateOptions" as typesVolumeCreateOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.VolumeInspectReport" as typesVolumeInspectReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.VolumeListReport" as typesVolumeListReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.VolumeMountReport" as typesVolumeMountReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.VolumeReloadReport" as typesVolumeReloadReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.VolumeRmReport" as typesVolumeRmReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "types.VolumeUnmountReport" as typesVolumeUnmountReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"libartifact.Artifact" *-- "extends""entities.ArtifactInspectReport"
"entities.ImagePushOptions" *-- "extends""entities.ArtifactListOptions"
"libartifact.Artifact" *-- "extends""entities.ArtifactListReport"
"entities.ImagePushOptions" *-- "extends""entities.ArtifactPushOptions"
"entities.IDOrNamed" *-- "extends""entities.Container"
"define.InspectContainerData" *-- "extends""entities.ContainerInspectReport"
"entities.Identifier" *-- "extends""entities.IDOrNamed"
"entities.Named" *-- "extends""entities.IDOrNamed"
"entities.ScpExecuteTransferOptions" *-- "extends""entities.ImageScpOptions"
"entities.ManifestAnnotateOptions" *-- "extends""entities.ManifestAddArtifactOptions"
"entities.ManifestAnnotateOptions" *-- "extends""entities.ManifestAddOptions"
"entities.ManifestAddOptions" *-- "extends""entities.ManifestModifyOptions"
"entities.ManifestRemoveOptions" *-- "extends""entities.ManifestModifyOptions"
"entities.Report" *-- "extends""entities.PodDeleteReport"
"entities.ContainerLogsOptions" *-- "extends""entities.PodLogsOptions"
"pflag.FlagSet" *-- "extends""entities.PodmanConfig"
"entities.SortListContainers" *-- "extends""entities.PsSortedCreateTime"
"entities.Identifier" *-- "extends""entities.Volume"
"entities.Report" *-- "extends""entities.VolumeDeleteReport"
"entities.SortListContainers" *-- "extends""entities.psSortedCommand"
"entities.SortListContainers" *-- "extends""entities.psSortedID"
"entities.SortListContainers" *-- "extends""entities.psSortedImage"
"entities.SortListContainers" *-- "extends""entities.psSortedNames"
"entities.SortListContainers" *-- "extends""entities.psSortedPod"
"entities.SortListContainers" *-- "extends""entities.psSortedRunningFor"
"entities.SortListContainers" *-- "extends""entities.psSortedSize"
"entities.SortListContainers" *-- "extends""entities.psSortedStatus"

"entities.Identifier" <|-- "implements""entities.Image"

namespace errorhandling {
    class ErrorModel << (S,Aquamarine) >> {
        + Because string
        + Message string
        + ResponseCode int

        + Error() string
        + Cause() error
        + Code() int

    }
    class PodConflictErrorModel << (S,Aquamarine) >> {
        + Errs []string
        + Id string

        + Error() string
        + Code() int

    }
}


namespace events {
    class Details << (S,Aquamarine) >> {
        + ContainerInspectData string
        + PodID string
        + Attributes <font color=blue>map</font>[string]string

    }
    class Event << (S,Aquamarine) >> {
        + ContainerExitCode *int
        + ID string
        + Image string
        + Name string
        + Network string
        + Status Status
        + Time time.Time
        + Type Type
        + HealthStatus string
        + HealthLog string
        + HealthFailingStreak int
        + Error string

        + ToJSONString() (string, error)
        + ToHumanReadable(truncate bool) string

    }
    class EventJournalD << (S,Aquamarine) >> {
        + Write(ee Event) error
        + Read(ctx context.Context, options ReadOptions) error
        + String() string

    }
    class EventLogFile << (S,Aquamarine) >> {
        + Write(ee Event) error
        + Read(ctx context.Context, options ReadOptions) error
        + String() string

    }
    class EventToNull << (S,Aquamarine) >> {
        + Write(ee Event) error
        + Read(ctx context.Context, options ReadOptions) error
        + String() string

    }
    interface Eventer  {
        + Write(event Event) error
        + Read(ctx context.Context, options ReadOptions) error
        + String() string

    }
    class EventerOptions << (S,Aquamarine) >> {
        + EventerType string
        + LogFilePath string
        + LogFileMaxSize uint64

    }
    class EventerType << (S,Aquamarine) >> {
        + String() string

    }
    class ReadOptions << (S,Aquamarine) >> {
        + EventChannel <font color=blue>chan</font> ReadResult
        + Filters []string
        + FromStart bool
        + Since string
        + Stream bool
        + Until string

    }
    class ReadResult << (S,Aquamarine) >> {
        + Event *Event
        + Error error

    }
    class Status << (S,Aquamarine) >> {
        + String() string

    }
    class Type << (S,Aquamarine) >> {
        + String() string

    }
    class events.EventFilter << (T, #FF7700) >>  {
    }
    class events.EventerType << (T, #FF7700) >>  {
    }
    class events.Status << (T, #FF7700) >>  {
    }
    class events.Type << (T, #FF7700) >>  {
    }
}
"events.Details" *-- "extends""events.Event"

"events.Eventer" <|-- "implements""events.EventJournalD"
"events.Eventer" <|-- "implements""events.EventLogFile"
"events.Eventer" <|-- "implements""events.EventToNull"

namespace farm {
    class Farm << (S,Aquamarine) >> {
        + Done(ctx context.Context) error
        + Status(ctx context.Context) (<font color=blue>map</font>[string]error, error)
        + NativePlatforms(ctx context.Context) ([]string, error)
        + EmulatedPlatforms(ctx context.Context) ([]string, error)
        + Schedule(ctx context.Context, platforms []string) (Schedule, error)
        + Build(ctx context.Context, schedule Schedule, options entities.BuildOptions, reference string, localEngine entities.ImageEngine) error

    }
    class Schedule << (S,Aquamarine) >> {
    }
    class buildOptions << (S,Aquamarine) >> {
    }
    class listBuilderOptions << (S,Aquamarine) >> {
    }
    class listLocal << (S,Aquamarine) >> {
    }
}


namespace file {
    class FileLocks << (S,Aquamarine) >> {
        + Close() error
        + AllocateLock() (uint32, error)
        + AllocateGivenLock(lck uint32) error
        + DeallocateLock(lck uint32) error
        + DeallocateAllLocks() error
        + LockFileLock(lck uint32) error
        + UnlockFileLock(lck uint32) error

    }
}


namespace framework {
    class TestFramework << (S,Aquamarine) >> {
        + TestError error

        + Setup() 
        + Teardown() 
        + Describe(text string, body <font color=blue>func</font>() ) bool

    }
}


namespace generate {
    class KubeOptions << (S,Aquamarine) >> {
        + PodmanOnly *bool
        + Service *bool
        + Type *string
        + Replicas *int32
        + NoTrunc *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithPodmanOnly(value bool) *KubeOptions
        + GetPodmanOnly() bool
        + WithService(value bool) *KubeOptions
        + GetService() bool
        + WithType(value string) *KubeOptions
        + GetType() string
        + WithReplicas(value int32) *KubeOptions
        + GetReplicas() int32
        + WithNoTrunc(value bool) *KubeOptions
        + GetNoTrunc() bool

    }
    class SystemdOptions << (S,Aquamarine) >> {
        + UseName *bool
        + New *bool
        + NoHeader *bool
        + TemplateUnitFile *bool
        + RestartPolicy *string
        + RestartSec *uint
        + StartTimeout *uint
        + StopTimeout *uint
        + ContainerPrefix *string
        + PodPrefix *string
        + Separator *string
        + Wants *[]string
        + After *[]string
        + Requires *[]string
        + AdditionalEnvVariables *[]string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithUseName(value bool) *SystemdOptions
        + GetUseName() bool
        + WithNew(value bool) *SystemdOptions
        + GetNew() bool
        + WithNoHeader(value bool) *SystemdOptions
        + GetNoHeader() bool
        + WithTemplateUnitFile(value bool) *SystemdOptions
        + GetTemplateUnitFile() bool
        + WithRestartPolicy(value string) *SystemdOptions
        + GetRestartPolicy() string
        + WithRestartSec(value uint) *SystemdOptions
        + GetRestartSec() uint
        + WithStartTimeout(value uint) *SystemdOptions
        + GetStartTimeout() uint
        + WithStopTimeout(value uint) *SystemdOptions
        + GetStopTimeout() uint
        + WithContainerPrefix(value string) *SystemdOptions
        + GetContainerPrefix() string
        + WithPodPrefix(value string) *SystemdOptions
        + GetPodPrefix() string
        + WithSeparator(value string) *SystemdOptions
        + GetSeparator() string
        + WithWants(value []string) *SystemdOptions
        + GetWants() []string
        + WithAfter(value []string) *SystemdOptions
        + GetAfter() []string
        + WithRequires(value []string) *SystemdOptions
        + GetRequires() []string
        + WithAdditionalEnvVariables(value []string) *SystemdOptions
        + GetAdditionalEnvVariables() []string

    }
    class containerInfo << (S,Aquamarine) >> {
        + ServiceName string
        + ContainerNameOrID string
        + Type string
        + NotifyAccess string
        + StopTimeout uint
        + RestartPolicy string
        + RestartSec uint
        + StartLimitBurst string
        + PIDFile string
        + ContainerIDFile string
        + GenerateTimestamp bool
        + BoundToServices []string
        + PodmanVersion string
        + Executable string
        + RootFlags string
        + TimeStamp string
        + CreateCommand []string
        + ExtraEnvs []string
        + EnvVariable string
        + AdditionalEnvVariables []string
        + ExecStart string
        + TimeoutStartSec uint
        + TimeoutStopSec uint
        + ExecStartPre string
        + ExecStop string
        + ExecStopPost string
        + GenerateNoHeader bool
        + Pod *podInfo
        + GraphRoot string
        + RunRoot string
        + IdentifySpecifier bool
        + Wants []string
        + After []string
        + Requires []string

    }
    class podInfo << (S,Aquamarine) >> {
        + ServiceName string
        + InfraNameOrID string
        + StopTimeout uint
        + RestartPolicy string
        + RestartSec uint
        + PIDFile string
        + PodIDFile string
        + GenerateTimestamp bool
        + RequiredServices []string
        + PodmanVersion string
        + Executable string
        + RootFlags string
        + TimeStamp string
        + CreateCommand []string
        + PodCreateCommand string
        + EnvVariable string
        + ExecStartPre string
        + ExecStart string
        + TimeoutStopSec uint
        + ExecStop string
        + ExecStopPost string
        + GenerateNoHeader bool
        + GraphRoot string
        + RunRoot string
        + IdentifySpecifier bool
        + Wants []string
        + After []string
        + Requires []string

    }
}


namespace handlers {
    class AuthConfig << (S,Aquamarine) >> {
    }
    class BuildCachePruneReport << (S,Aquamarine) >> {
    }
    class BuildResult << (S,Aquamarine) >> {
    }
    class ConfigCreateResponse << (S,Aquamarine) >> {
    }
    class Container << (S,Aquamarine) >> {
    }
    class ContainerConfig << (S,Aquamarine) >> {
    }
    class ContainerTopOKBody << (S,Aquamarine) >> {
    }
    class ContainerWaitOKBody << (S,Aquamarine) >> {
        + StatusCode int
        + Error *<font color=blue>struct</font>{string}

    }
    class ContainersPruneReport << (S,Aquamarine) >> {
    }
    class ContainersPruneReportLibpod << (S,Aquamarine) >> {
        + ID string
        + SpaceReclaimed int64
        + PruneError string

    }
    class CreateContainerConfig << (S,Aquamarine) >> {
        + Name string
        + HostConfig container.HostConfig
        + NetworkingConfig network.NetworkingConfig
        + EnvMerge []string
        + UnsetEnv []string
        + UnsetEnvAll bool

    }
    class DiskUsage << (S,Aquamarine) >> {
    }
    class ExecCreateConfig << (S,Aquamarine) >> {
    }
    class ExecRemoveConfig << (S,Aquamarine) >> {
        + Force bool

    }
    class ExecStartConfig << (S,Aquamarine) >> {
        + Detach bool
        + Tty bool
        + Height uint16
        + Width uint16

    }
    class HistoryResponse << (S,Aquamarine) >> {
        + ID string
        + Created int64
        + CreatedBy string
        + Tags []string
        + Size int64
        + Comment string

    }
    class ImageInspect << (S,Aquamarine) >> {
        + Container string

    }
    class ImagesPruneReport << (S,Aquamarine) >> {
    }
    class Info << (S,Aquamarine) >> {
        + BuildahVersion string
        + CPURealtimePeriod bool
        + CPURealtimeRuntime bool
        + CgroupVersion string
        + Rootless bool
        + SwapFree int64
        + SwapTotal int64
        + Uptime string

    }
    class LibpodContainersRmReport << (S,Aquamarine) >> {
        + ID string
        + RmError string

    }
    class LibpodImagesPullReport << (S,Aquamarine) >> {
    }
    class LibpodImagesRemoveReport << (S,Aquamarine) >> {
        + Errors []string

    }
    class LibpodImagesResolveReport << (S,Aquamarine) >> {
        + Names []string

    }
    class NetworkPruneReport << (S,Aquamarine) >> {
    }
    class PodTopOKBody << (S,Aquamarine) >> {
    }
    class PushResult << (S,Aquamarine) >> {
    }
    class UpdateEntities << (S,Aquamarine) >> {
    }
    class VolumesPruneReport << (S,Aquamarine) >> {
    }
}
"registry.AuthConfig" *-- "extends""handlers.AuthConfig"
"types.BuildCachePruneReport" *-- "extends""handlers.BuildCachePruneReport"
"types.BuildResult" *-- "extends""handlers.BuildResult"
"types.ConfigCreateResponse" *-- "extends""handlers.ConfigCreateResponse"
"backend.ContainerCreateConfig" *-- "extends""handlers.Container"
"types.Container" *-- "extends""handlers.Container"
"container.Config" *-- "extends""handlers.ContainerConfig"
"container.ContainerTopOKBody" *-- "extends""handlers.ContainerTopOKBody"
"types.ContainersPruneReport" *-- "extends""handlers.ContainersPruneReport"
"container.Config" *-- "extends""handlers.CreateContainerConfig"
"types.DiskUsage" *-- "extends""handlers.DiskUsage"
"types.ExecConfig" *-- "extends""handlers.ExecCreateConfig"
"types.ImageInspect" *-- "extends""handlers.ImageInspect"
"types.ImagesPruneReport" *-- "extends""handlers.ImagesPruneReport"
"system.Info" *-- "extends""handlers.Info"
"entities.ImagePullReport" *-- "extends""handlers.LibpodImagesPullReport"
"entities.ImageRemoveReport" *-- "extends""handlers.LibpodImagesRemoveReport"
"types.NetworksPruneReport" *-- "extends""handlers.NetworkPruneReport"
"container.ContainerTopOKBody" *-- "extends""handlers.PodTopOKBody"
"types.PushResult" *-- "extends""handlers.PushResult"
"define.UpdateContainerDevicesLimits" *-- "extends""handlers.UpdateEntities"
"define.UpdateHealthCheckConfig" *-- "extends""handlers.UpdateEntities"
"specs.LinuxResources" *-- "extends""handlers.UpdateEntities"
"types.VolumesPruneReport" *-- "extends""handlers.VolumesPruneReport"


namespace hyperv {
    class HyperVStubber << (S,Aquamarine) >> {
        + UserModeNetworkEnabled(mc *vmconfigs.MachineConfig) bool
        + UseProviderNetworkSetup() bool
        + RequireExclusiveActive() bool
        + CreateVM(opts define.CreateVMOpts, mc *vmconfigs.MachineConfig, builder *ignition.IgnitionBuilder) error
        + Exists(name string) (bool, error)
        + MountType() vmconfigs.VolumeMountType
        + MountVolumesToVM(mc *vmconfigs.MachineConfig, quiet bool) error
        + Remove(mc *vmconfigs.MachineConfig) ([]string, <font color=blue>func</font>() error, error)
        + RemoveAndCleanMachines(_ *define.MachineDirs) error
        + StartNetworking(mc *vmconfigs.MachineConfig, cmd *types.GvproxyCommand) error
        + StartVM(mc *vmconfigs.MachineConfig) (<font color=blue>func</font>() error, <font color=blue>func</font>() error, error)
        + State(mc *vmconfigs.MachineConfig, bypass bool) (define.Status, error)
        + StopVM(mc *vmconfigs.MachineConfig, hardStop bool) error
        + StopHostNetworking(mc *vmconfigs.MachineConfig, vmType define.VMType) error
        + VMType() define.VMType
        + SetProviderAttrs(mc *vmconfigs.MachineConfig, opts define.SetOptions) error
        + PrepareIgnition(mc *vmconfigs.MachineConfig, ignBuilder *ignition.IgnitionBuilder) (*ignition.ReadyUnitOpts, error)
        + PostStartNetworking(mc *vmconfigs.MachineConfig, noInfo bool) error
        + UpdateSSHPort(mc *vmconfigs.MachineConfig, port int) error
        + GetRosetta(mc *vmconfigs.MachineConfig) (bool, error)

    }
}
"vmconfigs.HyperVConfig" *-- "extends""hyperv.HyperVStubber"

"vmconfigs.VMProvider" <|-- "implements""hyperv.HyperVStubber"

namespace idle {
    class Tracker << (S,Aquamarine) >> {
        + Duration time.Duration

        + ConnState(conn net.Conn, state http.ConnState) 
        + Close() 
        + ActiveConnections() int
        + TotalConnections() int
        + Done() <font color=blue>chan</font> time.Time

    }
}


namespace ignition {
    class Clevis << (S,Aquamarine) >> {
        + Custom *Custom
        + Tang []Tang
        + Threshold *int
        + Tpm2 *bool

    }
    class Config << (S,Aquamarine) >> {
        + Ignition Ignition
        + Passwd Passwd
        + Storage Storage
        + Systemd Systemd

    }
    class Custom << (S,Aquamarine) >> {
        + Config string
        + NeedsNetwork *bool
        + Pin string

    }
    class Directory << (S,Aquamarine) >> {
    }
    class DirectoryEmbedded1 << (S,Aquamarine) >> {
        + Mode *int

    }
    class Disk << (S,Aquamarine) >> {
        + Device string
        + Partitions []Partition
        + WipeTable *bool

    }
    class Dropin << (S,Aquamarine) >> {
        + Contents *string
        + Name string

    }
    class DynamicIgnition << (S,Aquamarine) >> {
        + Name string
        + Key string
        + TimeZone string
        + UID int
        + VMName string
        + VMType define.VMType
        + WritePath string
        + Cfg Config
        + Rootful bool
        + NetRecover bool
        + Rosetta bool

        + Write() error
        + GenerateIgnitionConfig() error

    }
    class File << (S,Aquamarine) >> {
    }
    class FileEmbedded1 << (S,Aquamarine) >> {
        + Append []Resource
        + Contents Resource
        + Mode *int

    }
    class Filesystem << (S,Aquamarine) >> {
        + Device string
        + Format *string
        + Label *string
        + MountOptions []MountOption
        + Options []FilesystemOption
        + Path *string
        + UUID *string
        + WipeFilesystem *bool

    }
    class HTTPHeader << (S,Aquamarine) >> {
        + Name string
        + Value *string

    }
    class Ignition << (S,Aquamarine) >> {
        + Config IgnitionConfig
        + Proxy Proxy
        + Security Security
        + Timeouts Timeouts
        + Version string

    }
    class IgnitionBuilder << (S,Aquamarine) >> {
        + GenerateIgnitionConfig() error
        + WithUnit(units ...Unit) 
        + WithFile(files ...File) 
        + BuildWithIgnitionFile(ignPath string) error
        + Build() error
        + AddPlaybook(contents string, destPath string, username string) error

    }
    class IgnitionConfig << (S,Aquamarine) >> {
        + Merge []Resource
        + Replace Resource

    }
    class Link << (S,Aquamarine) >> {
    }
    class LinkEmbedded1 << (S,Aquamarine) >> {
        + Hard *bool
        + Target string

    }
    class Luks << (S,Aquamarine) >> {
        + Clevis *Clevis
        + Device *string
        + KeyFile Resource
        + Label *string
        + Name string
        + Options []LuksOption
        + UUID *string
        + WipeVolume *bool

    }
    class Node << (S,Aquamarine) >> {
        + Group NodeGroup
        + Overwrite *bool
        + Path string
        + User NodeUser

    }
    class NodeGroup << (S,Aquamarine) >> {
        + ID *int
        + Name *string

    }
    class NodeUser << (S,Aquamarine) >> {
        + ID *int
        + Name *string

    }
    class Partition << (S,Aquamarine) >> {
        + GUID *string
        + Label *string
        + Number int
        + Resize *bool
        + ShouldExist *bool
        + SizeMiB *int
        + StartMiB *int
        + TypeGUID *string
        + WipePartitionEntry *bool

    }
    class Passwd << (S,Aquamarine) >> {
        + Groups []PasswdGroup
        + Users []PasswdUser

    }
    class PasswdGroup << (S,Aquamarine) >> {
        + Gid *int
        + Name string
        + PasswordHash *string
        + ShouldExist *bool
        + System *bool

    }
    class PasswdUser << (S,Aquamarine) >> {
        + Gecos *string
        + Groups []Group
        + HomeDir *string
        + Name string
        + NoCreateHome *bool
        + NoLogInit *bool
        + NoUserGroup *bool
        + PasswordHash *string
        + PrimaryGroup *string
        + SSHAuthorizedKeys []SSHAuthorizedKey
        + Shell *string
        + ShouldExist *bool
        + System *bool
        + UID *int

    }
    class Proxy << (S,Aquamarine) >> {
        + HTTPProxy *string
        + HTTPSProxy *string
        + NoProxy []NoProxyItem

    }
    class Raid << (S,Aquamarine) >> {
        + Devices []Device
        + Level string
        + Name string
        + Options []RaidOption
        + Spares *int

    }
    class ReadyUnitOpts << (S,Aquamarine) >> {
        + Port uint64

    }
    class Resource << (S,Aquamarine) >> {
        + Compression *string
        + HTTPHeaders HTTPHeaders
        + Source *string
        + Verification Verification

    }
    class Security << (S,Aquamarine) >> {
        + TLS TLS

    }
    class Storage << (S,Aquamarine) >> {
        + Directories []Directory
        + Disks []Disk
        + Files []File
        + Filesystems []Filesystem
        + Links []Link
        + Luks []Luks
        + Raid []Raid

    }
    class Systemd << (S,Aquamarine) >> {
        + Units []Unit

    }
    class TLS << (S,Aquamarine) >> {
        + CertificateAuthorities []Resource

    }
    class Tang << (S,Aquamarine) >> {
        + Thumbprint *string
        + URL string

    }
    class Timeouts << (S,Aquamarine) >> {
        + HTTPResponseHeaders *int
        + HTTPTotal *int

    }
    class Unit << (S,Aquamarine) >> {
        + Contents *string
        + Dropins []Dropin
        + Enabled *bool
        + Mask *bool
        + Name string

    }
    class Verification << (S,Aquamarine) >> {
        + Hash *string

    }
    class ignition.Device << (T, #FF7700) >>  {
    }
    class ignition.FilesystemOption << (T, #FF7700) >>  {
    }
    class ignition.Group << (T, #FF7700) >>  {
    }
    class ignition.HTTPHeaders << (T, #FF7700) >>  {
    }
    class ignition.LuksOption << (T, #FF7700) >>  {
    }
    class ignition.MountOption << (T, #FF7700) >>  {
    }
    class ignition.NoProxyItem << (T, #FF7700) >>  {
    }
    class ignition.RaidOption << (T, #FF7700) >>  {
    }
    class ignition.SSHAuthorizedKey << (T, #FF7700) >>  {
    }
}
"ignition.DirectoryEmbedded1" *-- "extends""ignition.Directory"
"ignition.Node" *-- "extends""ignition.Directory"
"ignition.FileEmbedded1" *-- "extends""ignition.File"
"ignition.Node" *-- "extends""ignition.File"
"ignition.LinkEmbedded1" *-- "extends""ignition.Link"
"ignition.Node" *-- "extends""ignition.Link"


namespace images {
    class BuildResponse << (S,Aquamarine) >> {
        + Stream string
        + Error *jsonmessage.JSONError
        + ErrorMessage string
        + Aux json.RawMessage

    }
    class DiffOptions << (S,Aquamarine) >> {
        + Parent *string
        + DiffType *string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithParent(value string) *DiffOptions
        + GetParent() string
        + WithDiffType(value string) *DiffOptions
        + GetDiffType() string

    }
    class ExistsOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class ExportOptions << (S,Aquamarine) >> {
        + Compress *bool
        + Format *string
        + OciAcceptUncompressedLayers *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithCompress(value bool) *ExportOptions
        + GetCompress() bool
        + WithFormat(value string) *ExportOptions
        + GetFormat() string
        + WithOciAcceptUncompressedLayers(value bool) *ExportOptions
        + GetOciAcceptUncompressedLayers() bool

    }
    class GetOptions << (S,Aquamarine) >> {
        + Size *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithSize(value bool) *GetOptions
        + GetSize() bool

    }
    class HistoryOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class ImportOptions << (S,Aquamarine) >> {
        + Changes *[]string
        + Message *string
        + Reference *string
        + URL *string
        + OS *string
        + Architecture *string
        + Variant *string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithChanges(value []string) *ImportOptions
        + GetChanges() []string
        + WithMessage(value string) *ImportOptions
        + GetMessage() string
        + WithReference(value string) *ImportOptions
        + GetReference() string
        + WithURL(value string) *ImportOptions
        + GetURL() string
        + WithOS(value string) *ImportOptions
        + GetOS() string
        + WithArchitecture(value string) *ImportOptions
        + GetArchitecture() string
        + WithVariant(value string) *ImportOptions
        + GetVariant() string

    }
    class ListOptions << (S,Aquamarine) >> {
        + All *bool
        + Filters <font color=blue>map</font>[string][]string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAll(value bool) *ListOptions
        + GetAll() bool
        + WithFilters(value <font color=blue>map</font>[string][]string) *ListOptions
        + GetFilters() <font color=blue>map</font>[string][]string

    }
    class LoadOptions << (S,Aquamarine) >> {
        + Reference *string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithReference(value string) *LoadOptions
        + GetReference() string

    }
    class PruneOptions << (S,Aquamarine) >> {
        + All *bool
        + External *bool
        + BuildCache *bool
        + Filters <font color=blue>map</font>[string][]string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAll(value bool) *PruneOptions
        + GetAll() bool
        + WithExternal(value bool) *PruneOptions
        + GetExternal() bool
        + WithBuildCache(value bool) *PruneOptions
        + GetBuildCache() bool
        + WithFilters(value <font color=blue>map</font>[string][]string) *PruneOptions
        + GetFilters() <font color=blue>map</font>[string][]string

    }
    class PullOptions << (S,Aquamarine) >> {
        + AllTags *bool
        + Arch *string
        + Authfile *string
        + OS *string
        + Policy *string
        + Password *string
        + ProgressWriter *io.Writer
        + Quiet *bool
        + Retry *uint
        + RetryDelay *string
        + SkipTLSVerify *bool
        + Username *string
        + Variant *string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAllTags(value bool) *PullOptions
        + GetAllTags() bool
        + WithArch(value string) *PullOptions
        + GetArch() string
        + WithAuthfile(value string) *PullOptions
        + GetAuthfile() string
        + WithOS(value string) *PullOptions
        + GetOS() string
        + WithPolicy(value string) *PullOptions
        + GetPolicy() string
        + WithPassword(value string) *PullOptions
        + GetPassword() string
        + WithProgressWriter(value io.Writer) *PullOptions
        + GetProgressWriter() io.Writer
        + WithQuiet(value bool) *PullOptions
        + GetQuiet() bool
        + WithRetry(value uint) *PullOptions
        + GetRetry() uint
        + WithRetryDelay(value string) *PullOptions
        + GetRetryDelay() string
        + WithSkipTLSVerify(value bool) *PullOptions
        + GetSkipTLSVerify() bool
        + WithUsername(value string) *PullOptions
        + GetUsername() string
        + WithVariant(value string) *PullOptions
        + GetVariant() string

    }
    class PushOptions << (S,Aquamarine) >> {
        + All *bool
        + Authfile *string
        + Compress *bool
        + CompressionFormat *string
        + CompressionLevel *int
        + ForceCompressionFormat *bool
        + AddCompression []string
        + Format *string
        + Password *string
        + ProgressWriter *io.Writer
        + SkipTLSVerify *bool
        + RemoveSignatures *bool
        + Retry *uint
        + RetryDelay *string
        + Username *string
        + Quiet *bool
        + ManifestDigest *string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAll(value bool) *PushOptions
        + GetAll() bool
        + WithAuthfile(value string) *PushOptions
        + GetAuthfile() string
        + WithCompress(value bool) *PushOptions
        + GetCompress() bool
        + WithCompressionFormat(value string) *PushOptions
        + GetCompressionFormat() string
        + WithCompressionLevel(value int) *PushOptions
        + GetCompressionLevel() int
        + WithForceCompressionFormat(value bool) *PushOptions
        + GetForceCompressionFormat() bool
        + WithAddCompression(value []string) *PushOptions
        + GetAddCompression() []string
        + WithFormat(value string) *PushOptions
        + GetFormat() string
        + WithPassword(value string) *PushOptions
        + GetPassword() string
        + WithProgressWriter(value io.Writer) *PushOptions
        + GetProgressWriter() io.Writer
        + WithSkipTLSVerify(value bool) *PushOptions
        + GetSkipTLSVerify() bool
        + WithRemoveSignatures(value bool) *PushOptions
        + GetRemoveSignatures() bool
        + WithRetry(value uint) *PushOptions
        + GetRetry() uint
        + WithRetryDelay(value string) *PushOptions
        + GetRetryDelay() string
        + WithUsername(value string) *PushOptions
        + GetUsername() string
        + WithQuiet(value bool) *PushOptions
        + GetQuiet() bool
        + WithManifestDigest(value string) *PushOptions
        + GetManifestDigest() string

    }
    class RemoveOptions << (S,Aquamarine) >> {
        + All *bool
        + Force *bool
        + Ignore *bool
        + LookupManifest *bool
        + NoPrune *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAll(value bool) *RemoveOptions
        + GetAll() bool
        + WithForce(value bool) *RemoveOptions
        + GetForce() bool
        + WithIgnore(value bool) *RemoveOptions
        + GetIgnore() bool
        + WithLookupManifest(value bool) *RemoveOptions
        + GetLookupManifest() bool
        + WithNoPrune(value bool) *RemoveOptions
        + GetNoPrune() bool

    }
    class ScpOptions << (S,Aquamarine) >> {
        + Quiet *bool
        + Destination *string

        + ToParams() (url.Values, error)

    }
    class SearchOptions << (S,Aquamarine) >> {
        + Authfile *string
        + Filters <font color=blue>map</font>[string][]string
        + Limit *int
        + SkipTLSVerify *bool
        + ListTags *bool
        + Username *string
        + Password *string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAuthfile(value string) *SearchOptions
        + GetAuthfile() string
        + WithFilters(value <font color=blue>map</font>[string][]string) *SearchOptions
        + GetFilters() <font color=blue>map</font>[string][]string
        + WithLimit(value int) *SearchOptions
        + GetLimit() int
        + WithSkipTLSVerify(value bool) *SearchOptions
        + GetSkipTLSVerify() bool
        + WithListTags(value bool) *SearchOptions
        + GetListTags() bool
        + WithUsername(value string) *SearchOptions
        + GetUsername() string
        + WithPassword(value string) *SearchOptions
        + GetPassword() string

    }
    class TagOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class TreeOptions << (S,Aquamarine) >> {
        + WhatRequires *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithWhatRequires(value bool) *TreeOptions
        + GetWhatRequires() bool

    }
    class UntagOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class devino << (S,Aquamarine) >> {
        + Dev uint64
        + Ino uint64

    }
    class historyReporter << (S,Aquamarine) >> {
        + Created() string
        + Size() string
        + CreatedBy() string
        + ID() string
        + CreatedAt() string
        + CreatedSince() string

    }
    class imageReporter << (S,Aquamarine) >> {
        + Repository string
        + Tag string

        + ID() string
        + Created() string
        + Size() string
        + History() string
        + CreatedAt() string
        + CreatedSince() string
        + CreatedTime() string

    }
    class images.BuildOptions << (T, #FF7700) >>  {
    }
    class listEntryTag << (S,Aquamarine) >> {
        + Name string
        + Tags []string

    }
    class listFlagType << (S,Aquamarine) >> {
    }
    class mountReporter << (S,Aquamarine) >> {
        + ID() string

    }
    class pullOptionsWrapper << (S,Aquamarine) >> {
        + TLSVerifyCLI bool
        + CredentialsCLI string
        + DecryptionKeys []string

    }
    class pushOptionsWrapper << (S,Aquamarine) >> {
        + TLSVerifyCLI bool
        + CredentialsCLI string
        + SignPassphraseFileCLI string
        + SignBySigstoreParamFileCLI string
        + EncryptionKeys []string
        + EncryptLayers []int
        + DigestFile string

    }
    class searchOptionsWrapper << (S,Aquamarine) >> {
        + Compatible bool
        + CredentialsCLI string
        + TLSVerifyCLI bool
        + Format string
        + NoTrunc bool

    }
    class "types.BuildOptions" as typesBuildOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"entities.ImageHistoryLayer" *-- "extends""images.historyReporter"
"entities.ImageSummary" *-- "extends""images.imageReporter"
"entities.ImageMountReport" *-- "extends""images.mountReporter"
"entities.ImagePullOptions" *-- "extends""images.pullOptionsWrapper"
"entities.ImagePushOptions" *-- "extends""images.pushOptionsWrapper"
"entities.ImageSearchOptions" *-- "extends""images.searchOptionsWrapper"


namespace infra {
    class engineOpts << (S,Aquamarine) >> {
    }
}


namespace inspect {
    class ImageData << (S,Aquamarine) >> {
        + ID string
        + Digest digest.Digest
        + RepoTags []string
        + RepoDigests []string
        + Parent string
        + Comment string
        + Created *time.Time
        + Config *v1.ImageConfig
        + Version string
        + Author string
        + Architecture string
        + Os string
        + Size int64
        + VirtualSize int64
        + GraphDriver *define.DriverData
        + RootFS *RootFS
        + Labels <font color=blue>map</font>[string]string
        + Annotations <font color=blue>map</font>[string]string
        + ManifestType string
        + User string
        + History []v1.History
        + NamesHistory []string
        + HealthCheck *manifest.Schema2HealthConfig

    }
    class RootFS << (S,Aquamarine) >> {
        + Type string
        + Layers []digest.Digest

    }
    class inspector << (S,Aquamarine) >> {
    }
}


namespace intstr {
    class IntOrString << (S,Aquamarine) >> {
        + Type Type
        + IntVal int32
        + StrVal string

        + Fuzz(c gofuzz.Continue) 
        + UnmarshalJSON(value []byte) error
        + String() string
        + IntValue() int
        + MarshalJSON() ([]byte, error)

    }
    class intstr.Type << (T, #FF7700) >>  {
    }
}


namespace kube {
    class ApplyOptions << (S,Aquamarine) >> {
        + Kubeconfig *string
        + Namespace *string
        + CACertFile *string
        + File *string
        + Service *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithKubeconfig(value string) *ApplyOptions
        + GetKubeconfig() string
        + WithNamespace(value string) *ApplyOptions
        + GetNamespace() string
        + WithCACertFile(value string) *ApplyOptions
        + GetCACertFile() string
        + WithFile(value string) *ApplyOptions
        + GetFile() string
        + WithService(value bool) *ApplyOptions
        + GetService() bool

    }
    class CtrSpecGenOptions << (S,Aquamarine) >> {
        + Annotations <font color=blue>map</font>[string]string
        + Container v1.Container
        + Image *libimage.Image
        + IpcNSIsHost bool
        + Volumes <font color=blue>map</font>[string]*KubeVolume
        + VolumesFrom []string
        + ImageVolumes []*specgen.ImageVolume
        + PodID string
        + PodName string
        + PodInfraID string
        + ConfigMaps []v1.ConfigMap
        + SeccompPaths *KubeSeccompPaths
        + ReadOnly types.OptionalBool
        + RestartPolicy string
        + NetNSIsHost bool
        + UserNSIsHost bool
        + PidNSIsHost bool
        + UtsNSIsHost bool
        + SecretsManager *secrets.SecretsManager
        + LogDriver string
        + LogOptions []string
        + Labels <font color=blue>map</font>[string]string
        + IsInfra bool
        + InitContainerType string
        + PodSecurityContext *v1.PodSecurityContext
        + TerminationGracePeriodSeconds *int64

    }
    class DownOptions << (S,Aquamarine) >> {
        + Force *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithForce(value bool) *DownOptions
        + GetForce() bool

    }
    class KubeSeccompPaths << (S,Aquamarine) >> {
        + FindForContainer(ctrName string) string

    }
    class KubeVolume << (S,Aquamarine) >> {
        + Type KubeVolumeType
        + Source string
        + Items <font color=blue>map</font>[string][]byte
        + Optional bool
        + DefaultMode int32
        + ImagePullPolicy v1.PullPolicy

    }
    class PlayOptions << (S,Aquamarine) >> {
        + Annotations <font color=blue>map</font>[string]string
        + Authfile *string
        + CertDir *string
        + Username *string
        + Password *string
        + Network *[]string
        + NoHostname *bool
        + NoHosts *bool
        + Quiet *bool
        + SignaturePolicy *string
        + SkipTLSVerify *bool
        + SeccompProfileRoot *string
        + StaticIPs *[]net.IP
        + StaticMACs *[]net.HardwareAddr
        + ConfigMaps *[]string
        + LogDriver *string
        + LogOptions *[]string
        + Replace *bool
        + Start *bool
        + NoTrunc *bool
        + Userns *string
        + Force *bool
        + PublishPorts []string
        + PublishAllPorts *bool
        + Wait *bool
        + ServiceContainer *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAnnotations(value <font color=blue>map</font>[string]string) *PlayOptions
        + GetAnnotations() <font color=blue>map</font>[string]string
        + WithAuthfile(value string) *PlayOptions
        + GetAuthfile() string
        + WithCertDir(value string) *PlayOptions
        + GetCertDir() string
        + WithUsername(value string) *PlayOptions
        + GetUsername() string
        + WithPassword(value string) *PlayOptions
        + GetPassword() string
        + WithNetwork(value []string) *PlayOptions
        + GetNetwork() []string
        + WithNoHostname(value bool) *PlayOptions
        + GetNoHostname() bool
        + WithNoHosts(value bool) *PlayOptions
        + GetNoHosts() bool
        + WithQuiet(value bool) *PlayOptions
        + GetQuiet() bool
        + WithSignaturePolicy(value string) *PlayOptions
        + GetSignaturePolicy() string
        + WithSkipTLSVerify(value bool) *PlayOptions
        + GetSkipTLSVerify() bool
        + WithSeccompProfileRoot(value string) *PlayOptions
        + GetSeccompProfileRoot() string
        + WithStaticIPs(value []net.IP) *PlayOptions
        + GetStaticIPs() []net.IP
        + WithStaticMACs(value []net.HardwareAddr) *PlayOptions
        + GetStaticMACs() []net.HardwareAddr
        + WithConfigMaps(value []string) *PlayOptions
        + GetConfigMaps() []string
        + WithLogDriver(value string) *PlayOptions
        + GetLogDriver() string
        + WithLogOptions(value []string) *PlayOptions
        + GetLogOptions() []string
        + WithReplace(value bool) *PlayOptions
        + GetReplace() bool
        + WithStart(value bool) *PlayOptions
        + GetStart() bool
        + WithNoTrunc(value bool) *PlayOptions
        + GetNoTrunc() bool
        + WithUserns(value string) *PlayOptions
        + GetUserns() string
        + WithForce(value bool) *PlayOptions
        + GetForce() bool
        + WithPublishPorts(value []string) *PlayOptions
        + GetPublishPorts() []string
        + WithPublishAllPorts(value bool) *PlayOptions
        + GetPublishAllPorts() bool
        + WithWait(value bool) *PlayOptions
        + GetWait() bool
        + WithServiceContainer(value bool) *PlayOptions
        + GetServiceContainer() bool

    }
    class downKubeOptions << (S,Aquamarine) >> {
        + Force bool

    }
    class kube.KubeVolumeType << (T, #FF7700) >>  {
    }
    class playKubeOptionsWrapper << (S,Aquamarine) >> {
        + TLSVerifyCLI bool
        + CredentialsCLI string
        + StartCLI bool
        + BuildCLI bool

    }
}
"entities.PlayKubeOptions" *-- "extends""kube.playKubeOptionsWrapper"


namespace libartifact {
    class Artifact << (S,Aquamarine) >> {
        + Manifest *manifest.OCI1
        + Name string

        + TotalSizeBytes() int64
        + GetName() (string, error)
        + SetName(name string) 
        + GetDigest() (*digest.Digest, error)

    }
    class ArtifactList << (S,Aquamarine) >> {
        + GetByNameOrDigest(nameOrDigest string) (*Artifact, bool, error)

    }
    class libartifact.ArtifactList << (T, #FF7700) >>  {
    }
}


namespace libkrun {
    class LibKrunStubber << (S,Aquamarine) >> {
        + CreateVM(opts define.CreateVMOpts, mc *vmconfigs.MachineConfig, builder *ignition.IgnitionBuilder) error
        + PrepareIgnition(mc *vmconfigs.MachineConfig, ignBuilder *ignition.IgnitionBuilder) (*ignition.ReadyUnitOpts, error)
        + Exists(name string) (bool, error)
        + MountType() vmconfigs.VolumeMountType
        + MountVolumesToVM(mc *vmconfigs.MachineConfig, quiet bool) error
        + Remove(mc *vmconfigs.MachineConfig) ([]string, <font color=blue>func</font>() error, error)
        + RemoveAndCleanMachines(dirs *define.MachineDirs) error
        + SetProviderAttrs(mc *vmconfigs.MachineConfig, opts define.SetOptions) error
        + StartNetworking(mc *vmconfigs.MachineConfig, cmd *types.GvproxyCommand) error
        + PostStartNetworking(mc *vmconfigs.MachineConfig, noInfo bool) error
        + StartVM(mc *vmconfigs.MachineConfig) (<font color=blue>func</font>() error, <font color=blue>func</font>() error, error)
        + State(mc *vmconfigs.MachineConfig, bypass bool) (define.Status, error)
        + StopVM(mc *vmconfigs.MachineConfig, hardStop bool) error
        + StopHostNetworking(mc *vmconfigs.MachineConfig, vmType define.VMType) error
        + VMType() define.VMType
        + UserModeNetworkEnabled(mc *vmconfigs.MachineConfig) bool
        + UseProviderNetworkSetup() bool
        + RequireExclusiveActive() bool
        + UpdateSSHPort(mc *vmconfigs.MachineConfig, port int) error
        + GetRosetta(mc *vmconfigs.MachineConfig) (bool, error)

    }
}
"vmconfigs.AppleHVConfig" *-- "extends""libkrun.LibKrunStubber"

"vmconfigs.VMProvider" <|-- "implements""libkrun.LibKrunStubber"

namespace libpod {
    class AttachOptions << (S,Aquamarine) >> {
        + Streams *define.AttachStreams
        + DetachKeys *string
        + InitialSize *resize.TerminalSize
        + AttachReady <font color=blue>chan</font> bool
        + Start bool
        + Started <font color=blue>chan</font> bool

    }
    class BoltState << (S,Aquamarine) >> {
        + Close() error
        + Refresh() error
        + GetDBConfig() (*DBConfig, error)
        + ValidateDBConfig(runtime *Runtime) error
        + GetContainerName(id string) (string, error)
        + GetPodName(id string) (string, error)
        + Container(id string) (*Container, error)
        + LookupContainerID(idOrName string) (string, error)
        + LookupContainer(idOrName string) (*Container, error)
        + HasContainer(id string) (bool, error)
        + AddContainer(ctr *Container) error
        + RemoveContainer(ctr *Container) error
        + UpdateContainer(ctr *Container) error
        + SaveContainer(ctr *Container) error
        + ContainerInUse(ctr *Container) ([]string, error)
        + AllContainers(loadState bool) ([]*Container, error)
        + GetNetworks(ctr *Container) (<font color=blue>map</font>[string]types.PerNetworkOptions, error)
        + NetworkConnect(ctr *Container, network string, opts types.PerNetworkOptions) error
        + NetworkModify(ctr *Container, network string, opts types.PerNetworkOptions) error
        + NetworkDisconnect(ctr *Container, network string) error
        + GetContainerConfig(id string) (*ContainerConfig, error)
        + AddContainerExitCode(id string, exitCode int32) error
        + GetContainerExitCode(id string) (int32, error)
        + GetContainerExitCodeTimeStamp(id string) (*time.Time, error)
        + PruneContainerExitCodes() error
        + AddExecSession(ctr *Container, session *ExecSession) error
        + GetExecSession(id string) (string, error)
        + RemoveExecSession(session *ExecSession) error
        + GetContainerExecSessions(ctr *Container) ([]string, error)
        + RemoveContainerExecSessions(ctr *Container) error
        + RewriteContainerConfig(ctr *Container, newCfg *ContainerConfig) error
        + SafeRewriteContainerConfig(ctr *Container, oldName string, newName string, newCfg *ContainerConfig) error
        + RewritePodConfig(pod *Pod, newCfg *PodConfig) error
        + RewriteVolumeConfig(volume *Volume, newCfg *VolumeConfig) error
        + Pod(id string) (*Pod, error)
        + LookupPod(idOrName string) (*Pod, error)
        + HasPod(id string) (bool, error)
        + PodHasContainer(pod *Pod, id string) (bool, error)
        + PodContainersByID(pod *Pod) ([]string, error)
        + PodContainers(pod *Pod) ([]*Container, error)
        + AddVolume(volume *Volume) error
        + RemoveVolume(volume *Volume) error
        + UpdateVolume(volume *Volume) error
        + SaveVolume(volume *Volume) error
        + AllVolumes() ([]*Volume, error)
        + Volume(name string) (*Volume, error)
        + LookupVolume(name string) (*Volume, error)
        + HasVolume(name string) (bool, error)
        + VolumeInUse(volume *Volume) ([]string, error)
        + AddPod(pod *Pod) error
        + RemovePod(pod *Pod) error
        + RemovePodContainers(pod *Pod) error
        + AddContainerToPod(pod *Pod, ctr *Container) error
        + RemoveContainerFromPod(pod *Pod, ctr *Container) error
        + UpdatePod(pod *Pod) error
        + SavePod(pod *Pod) error
        + AllPods() ([]*Pod, error)
        + ContainerIDIsVolume(id string) (bool, error)

    }
    class ConmonOCIRuntime << (S,Aquamarine) >> {
        + Attach(c *Container, params *AttachOptions) error
        + Name() string
        + Path() string
        + CreateContainer(ctr *Container, restoreOptions *ContainerCheckpointOptions) (int64, error)
        + StartContainer(ctr *Container) error
        + UpdateContainer(ctr *Container, resources *specs-go.LinuxResources) error
        + KillContainer(ctr *Container, signal uint, all bool) error
        + StopContainer(ctr *Container, timeout uint, all bool) error
        + DeleteContainer(ctr *Container) error
        + PauseContainer(ctr *Container) error
        + UnpauseContainer(ctr *Container) error
        + HTTPAttach(ctr *Container, req *http.Request, w http.ResponseWriter, streams *HTTPAttachStreams, detachKeys *string, cancel <font color=blue>chan</font> bool, hijackDone <font color=blue>chan</font> bool, streamAttach bool, streamLogs bool) error
        + AttachResize(ctr *Container, newSize resize.TerminalSize) error
        + CheckpointContainer(ctr *Container, options ContainerCheckpointOptions) (int64, error)
        + CheckConmonRunning(ctr *Container) (bool, error)
        + SupportsCheckpoint() bool
        + SupportsJSONErrors() bool
        + SupportsNoCgroups() bool
        + SupportsKVM() bool
        + AttachSocketPath(ctr *Container) (string, error)
        + ExitFilePath(ctr *Container) (string, error)
        + OOMFilePath(ctr *Container) (string, error)
        + PersistDirectoryPath(ctr *Container) (string, error)
        + RuntimeInfo() (*define.ConmonInfo, *define.OCIRuntimeInfo, error)
        + ExecContainer(c *Container, sessionID string, options *ExecOptions, streams *define.AttachStreams, newSize *resize.TerminalSize) (int, <font color=blue>chan</font> error, error)
        + ExecContainerHTTP(ctr *Container, sessionID string, options *ExecOptions, req *http.Request, w http.ResponseWriter, streams *HTTPAttachStreams, cancel <font color=blue>chan</font> bool, hijackDone <font color=blue>chan</font> bool, holdConnOpen <font color=blue>chan</font> bool, newSize *resize.TerminalSize) (int, <font color=blue>chan</font> error, error)
        + ExecContainerDetached(ctr *Container, sessionID string, options *ExecOptions, stdin bool) (int, error)
        + ExecAttachResize(ctr *Container, sessionID string, newSize resize.TerminalSize) error
        + ExecStopContainer(ctr *Container, sessionID string, timeout uint) error
        + ExecUpdateStatus(ctr *Container, sessionID string) (bool, error)
        + ExecAttachSocketPath(ctr *Container, sessionID string) (string, error)

    }
    class Container << (S,Aquamarine) >> {
        + Config() *ContainerConfig
        + ConfigWithNetworks() *ContainerConfig
        + ConfigNoCopy() *ContainerConfig
        + DeviceHostSrc() []specs-go.LinuxDevice
        + Runtime() *Runtime
        + Spec() *specs-go.Spec
        + ID() string
        + Name() string
        + PodID() string
        + Namespace() string
        + Image() (string, string)
        + RawImageName() string
        + ShmDir() string
        + ShmSize() int64
        + StaticDir() string
        + NamedVolumes() []*ContainerNamedVolume
        + Privileged() bool
        + ProcessLabel() string
        + MountLabel() string
        + Systemd() bool
        + User() string
        + Dependencies() []string
        + NewNetNS() bool
        + PortMappings() ([]types.PortMapping, error)
        + DNSServers() []net.IP
        + DNSSearch() []string
        + DNSOption() []string
        + HostsAdd() []string
        + UserVolumes() []string
        + Entrypoint() []string
        + Command() []string
        + Stdin() bool
        + Labels() <font color=blue>map</font>[string]string
        + StopSignal() uint
        + StopTimeout() uint
        + CreatedTime() time.Time
        + CgroupParent() string
        + LogPath() string
        + LogTag() string
        + RestartPolicy() string
        + RestartRetries() uint
        + LogDriver() string
        + RuntimeName() string
        + Hostname() string
        + NetworkHostname() string
        + WorkingDir() string
        + Terminal() bool
        + LinuxResources() *specs-go.LinuxResources
        + Env() []string
        + State() (define.ContainerStatus, error)
        + RestartCount() (uint, error)
        + Mounted() (bool, string, error)
        + StartedTime() (time.Time, error)
        + FinishedTime() (time.Time, error)
        + ExitCode() (int32, bool, error)
        + OOMKilled() (bool, error)
        + PID() (int, error)
        + ConmonPID() (int, error)
        + ExecSessions() ([]string, error)
        + ExecSession(id string) (*ExecSession, error)
        + BindMounts() (<font color=blue>map</font>[string]string, error)
        + StoppedByUser() (bool, error)
        + StartupHCPassed() (bool, error)
        + NamespacePath(linuxNS LinuxNS) (string, error)
        + CgroupManager() string
        + CgroupPath() (string, error)
        + RootFsSize() (int64, error)
        + RWSize() (int64, error)
        + IDMappings() storage.IDMappingOptions
        + RootUID() int
        + RootGID() int
        + IsInfra() bool
        + IsInitCtr() bool
        + IsReadOnly() bool
        + NetworkDisabled() (bool, error)
        + HostNetwork() bool
        + HasHealthCheck() bool
        + HealthCheckConfig() *manifest.Schema2HealthConfig
        + HealthCheckLogDestination() string
        + HealthCheckMaxLogCount() uint
        + HealthCheckMaxLogSize() uint
        + AutoRemove() bool
        + AutoRemoveImage() bool
        + Timezone() string
        + Umask() string
        + Secrets() []*ContainerSecret
        + Networks() ([]string, error)
        + NetworkMode() string
        + GetNetworkStatus() (<font color=blue>map</font>[string]types.StatusBlock, error)
        + NamespaceMode(ns specs-go.LinuxNamespaceType, ctrSpec *specs-go.Spec) string
        + Init(ctx context.Context, recursive bool) error
        + Start(ctx context.Context, recursive bool) error
        + Update(resources *specs-go.LinuxResources, restartPolicy *string, restartRetries *uint, changedHealthCheckConfiguration *define.UpdateHealthCheckConfig) error
        + Attach(ctx context.Context, streams *define.AttachStreams, keys string, resize <font color=blue>chan</font> resize.TerminalSize, start bool) (<font color=blue>chan</font> error, error)
        + RestartWithTimeout(ctx context.Context, timeout uint) error
        + Stop() error
        + StopWithTimeout(timeout uint) error
        + Kill(signal uint) error
        + HTTPAttach(r *http.Request, w http.ResponseWriter, streams *HTTPAttachStreams, detachKeys *string, cancel <font color=blue>chan</font> bool, streamAttach bool, streamLogs bool, hijackDone <font color=blue>chan</font> bool) error
        + AttachResize(newSize resize.TerminalSize) error
        + Mount() (string, error)
        + Unmount(force bool) error
        + Pause() error
        + Unpause() error
        + Export(out io.Writer) error
        + AddArtifact(name string, data []byte) error
        + GetArtifact(name string) ([]byte, error)
        + RemoveArtifact(name string) error
        + Wait(ctx context.Context) (int32, error)
        + WaitForExit(ctx context.Context, pollInterval time.Duration) (int32, error)
        + WaitForConditionWithInterval(ctx context.Context, waitTimeout time.Duration, conditions ...string) (int32, error)
        + Cleanup(ctx context.Context, onlyStopped bool) error
        + Batch(batchFunc <font color=blue>func</font>(*Container) error) error
        + Sync() error
        + ReloadNetwork() error
        + Refresh(ctx context.Context) error
        + Checkpoint(ctx context.Context, options ContainerCheckpointOptions) (*define.CRIUCheckpointRestoreStatistics, int64, error)
        + Restore(ctx context.Context, options ContainerCheckpointOptions) (*define.CRIUCheckpointRestoreStatistics, int64, error)
        + ShouldRestart(ctx context.Context) bool
        + CopyFromArchive(_ context.Context, containerPath string, chown bool, noOverwriteDirNonDir bool, rename <font color=blue>map</font>[string]string, tarStream io.Reader) (<font color=blue>func</font>() error, error)
        + CopyToArchive(ctx context.Context, containerPath string, tarStream io.Writer) (<font color=blue>func</font>() error, error)
        + Stat(ctx context.Context, containerPath string) (*define.FileInfo, error)
        + Commit(ctx context.Context, destImage string, options ContainerCommitOptions) (*libimage.Image, error)
        + ExecCreate(config *ExecConfig) (string, error)
        + ExecStart(sessionID string) error
        + ExecHTTPStartAndAttach(sessionID string, r *http.Request, w http.ResponseWriter, streams *HTTPAttachStreams, detachKeys *string, cancel <font color=blue>chan</font> bool, hijackDone <font color=blue>chan</font> bool, newSize *resize.TerminalSize) error
        + ExecStop(sessionID string, timeout *uint) error
        + ExecCleanup(sessionID string) error
        + ExecRemove(sessionID string, force bool) error
        + ExecResize(sessionID string, newSize resize.TerminalSize) error
        + Exec(config *ExecConfig, streams *define.AttachStreams, resize <font color=blue>chan</font> resize.TerminalSize) (int, error)
        + Inspect(size bool) (*define.InspectContainerData, error)
        + GetMounts(namedVolumes []*ContainerNamedVolume, imageVolumes []*ContainerImageVolume, mounts []specs-go.Mount) ([]define.InspectMount, error)
        + GetSecurityOptions() []string
        + GetDevices(priv bool, ctrSpec specs-go.Spec, deviceNodes <font color=blue>map</font>[string]string) ([]define.InspectDevice, error)
        + ControlSocketPath() string
        + CheckpointVolumesPath() string
        + CheckpointPath() string
        + PreCheckPointPath() string
        + AttachSocketPath() (string, error)
        + SortUserVolumes(ctrSpec *specs-go.Spec) ([]*ContainerNamedVolume, []specs-go.Mount)
        + ChangeHostPathOwnership(src string, recurse bool, uid int, gid int) error
        + ReadLog(ctx context.Context, options *logs.LogOptions, logChannel <font color=blue>chan</font> *logs.LogLine, colorID int64) error
        + Top(descriptors []string) ([]string, error)
        + Top(descriptors []string) ([]string, error)
        + GetContainerPidInformation(descriptors []string) ([]string, error)
        + Top(descriptors []string) ([]string, error)
        + HealthCheckStatus() (string, error)
        + NetworkDisconnect(nameOrID string, netName string, force bool) error
        + NetworkConnect(nameOrID string, netName string, netOpts types.PerNetworkOptions) error
        + IsService() bool
        + GetContainerStats(previousStats *define.ContainerStats) (*define.ContainerStats, error)

    }
    class ContainerCheckpointOptions << (S,Aquamarine) >> {
        + Keep bool
        + KeepRunning bool
        + TCPEstablished bool
        + TargetFile string
        + CheckpointImageID string
        + Name string
        + IgnoreRootfs bool
        + IgnoreStaticIP bool
        + IgnoreStaticMAC bool
        + IgnoreVolumes bool
        + PreCheckPoint bool
        + WithPrevious bool
        + ImportPrevious string
        + CreateImage string
        + Compression archive.Compression
        + Pod string
        + PrintStats bool
        + FileLocks bool

    }
    class ContainerCommitOptions << (S,Aquamarine) >> {
        + Pause bool
        + IncludeVolumes bool
        + Author string
        + Message string
        + Changes []string
        + Squash bool

    }
    class ContainerConfig << (S,Aquamarine) >> {
        + Spec *specs-go.Spec
        + ID string
        + Name string
        + Pod string
        + Namespace string
        + LockID uint32
        + CreateCommand []string
        + RawImageName string
        + IDMappings storage.IDMappingOptions
        + Dependencies []string

    }
    class ContainerGraph << (S,Aquamarine) >> {
        + DependencyMap() <font color=blue>map</font>[*Container][]*{packageName}Container

    }
    class ContainerImageConfig << (S,Aquamarine) >> {
        + UserVolumes []string
        + Entrypoint []string
        + Command []string

    }
    class ContainerImageVolume << (S,Aquamarine) >> {
        + Source string
        + Dest string
        + ReadWrite bool
        + SubPath string

    }
    class ContainerInfo << (S,Aquamarine) >> {
        + Dir string
        + RunDir string
        + Config *v1.Image
        + ProcessLabel string
        + MountLabel string
        + UIDMap []idtools.IDMap
        + GIDMap []idtools.IDMap

    }
    class ContainerMiscConfig << (S,Aquamarine) >> {
        + Stdin bool
        + Labels <font color=blue>map</font>[string]string
        + StopSignal uint
        + StopTimeout uint
        + Timeout uint
        + CreatedTime time.Time
        + CgroupManager string
        + NoCgroups bool
        + CgroupsMode string
        + CgroupParent string
        + GroupEntry string
        + KubeExitCodePropagation define.KubeExitCodePropagation
        + LogPath string
        + LogTag string
        + LogSize int64
        + LogDriver string
        + ConmonPidFile string
        + RestartPolicy string
        + RestartRetries uint
        + PostConfigureNetNS bool
        + OCIRuntime string
        + IsInfra bool
        + IsService bool
        + SdNotifyMode string
        + SdNotifySocket string
        + Systemd *bool
        + HealthCheckConfig *manifest.Schema2HealthConfig
        + HealthCheckOnFailureAction define.HealthCheckOnFailureAction
        + HealthLogDestination *string
        + HealthMaxLogCount *uint
        + HealthMaxLogSize *uint
        + StartupHealthCheckConfig *define.StartupHealthCheck
        + PreserveFDs uint
        + PreserveFD []uint
        + Timezone string
        + Umask string
        + PidFile string
        + CDIDevices []string
        + DeviceHostSrc []specs-go.LinuxDevice
        + EnvSecrets <font color=blue>map</font>[string]*secrets.Secret
        + InitContainerType string
        + PasswdEntry string
        + MountAllDevices bool
        + ReadWriteTmpfs bool

    }
    class ContainerNameSpaceConfig << (S,Aquamarine) >> {
        + IPCNsCtr string
        + MountNsCtr string
        + NetNsCtr string
        + PIDNsCtr string
        + UserNsCtr string
        + UTSNsCtr string
        + CgroupNsCtr string

    }
    class ContainerNamedVolume << (S,Aquamarine) >> {
        + Name string
        + Dest string
        + Options []string
        + IsAnonymous bool
        + SubPath string

    }
    class ContainerNetworkConfig << (S,Aquamarine) >> {
        + CreateNetNS bool
        + StaticIP net.IP
        + StaticMAC types.HardwareAddr
        + PortMappings []types.PortMapping
        + OldPortMappings []types.OCICNIPortMapping
        + ExposedPorts <font color=blue>map</font>[uint16][]string
        + UseImageResolvConf bool
        + DNSServer []net.IP
        + DNSSearch []string
        + DNSOption []string
        + UseImageHostname bool
        + UseImageHosts bool
        + BaseHostsFile string
        + HostAdd []string
        + Networks <font color=blue>map</font>[string]types.PerNetworkOptions
        + NetworksDeprecated []string
        + NetMode namespaces.NetworkMode
        + NetworkOptions <font color=blue>map</font>[string][]string

    }
    class ContainerNetworkDescriptions << (S,Aquamarine) >> {
    }
    class ContainerOverlayVolume << (S,Aquamarine) >> {
        + Dest string
        + Source string
        + Options []string

    }
    class ContainerRootFSConfig << (S,Aquamarine) >> {
        + RootfsImageID string
        + RootfsImageName string
        + Rootfs string
        + RootfsOverlay bool
        + RootfsMapping *string
        + ShmDir string
        + NoShmShare bool
        + NoShm bool
        + ShmSize int64
        + ShmSizeSystemd int64
        + StaticDir string
        + Mounts []string
        + NamedVolumes []*ContainerNamedVolume
        + OverlayVolumes []*ContainerOverlayVolume
        + ImageVolumes []*ContainerImageVolume
        + CreateWorkingDir bool
        + Secrets []*ContainerSecret
        + SecretsPath string
        + StorageOpts <font color=blue>map</font>[string]string
        + Volatile bool
        + Passwd *bool
        + ChrootDirs []string

    }
    class ContainerSecret << (S,Aquamarine) >> {
        + UID uint32
        + GID uint32
        + Mode uint32
        + Target string

    }
    class ContainerSecurityConfig << (S,Aquamarine) >> {
        + Privileged bool
        + ProcessLabel string
        + MountLabel string
        + LabelOpts []string
        + User string
        + Groups []string
        + HostUsers []string
        + AddCurrentUserPasswdEntry bool
        + LabelNested bool

    }
    class ContainerState << (S,Aquamarine) >> {
        + State define.ContainerStatus
        + ConfigPath string
        + RunDir string
        + Mounted bool
        + Mountpoint string
        + StartedTime time.Time
        + FinishedTime time.Time
        + ExitCode int32
        + Exited bool
        + Error string
        + OOMKilled bool
        + Checkpointed bool
        + PID int
        + ConmonPID int
        + ExecSessions <font color=blue>map</font>[string]*ExecSession
        + LegacyExecSessions <font color=blue>map</font>[string]*legacyExecSession
        + NetNS string
        + NetworkStatus <font color=blue>map</font>[string]types.StatusBlock
        + BindMounts <font color=blue>map</font>[string]string
        + StoppedByUser bool
        + RestartPolicyMatch bool
        + RestartCount uint
        + StartupHCPassed bool
        + StartupHCSuccessCount int
        + StartupHCFailureCount int
        + HCUnitName string
        + ExtensionStageHooks <font color=blue>map</font>[string][]specs-go.Hook
        + NetInterfaceDescriptions ContainerNetworkDescriptions
        + Service Service
        + CheckpointedTime time.Time
        + RestoredTime time.Time
        + CheckpointLog string
        + CheckpointPath string
        + RestoreLog string
        + Restored bool

    }
    class DBConfig << (S,Aquamarine) >> {
        + LibpodRoot string
        + LibpodTmp string
        + StorageRoot string
        + StorageTmp string
        + GraphDriver string
        + VolumePath string

    }
    class ExecConfig << (S,Aquamarine) >> {
        + Command []string
        + Terminal bool
        + AttachStdin bool
        + AttachStdout bool
        + AttachStderr bool
        + DetachKeys *string
        + Environment <font color=blue>map</font>[string]string
        + Privileged bool
        + User string
        + WorkDir string
        + PreserveFDs uint
        + PreserveFD []uint
        + ExitCommand []string
        + ExitCommandDelay uint

    }
    class ExecOptions << (S,Aquamarine) >> {
        + Cmd []string
        + Env <font color=blue>map</font>[string]string
        + Terminal bool
        + Cwd string
        + User string
        + Streams *define.AttachStreams
        + PreserveFDs uint
        + PreserveFD []uint
        + DetachKeys *string
        + ExitCommand []string
        + ExitCommandDelay uint
        + Privileged bool

    }
    class ExecSession << (S,Aquamarine) >> {
        + Id string
        + ContainerId string
        + State define.ContainerExecStatus
        + PID int
        + ExitCode int
        + Config *ExecConfig

        + ID() string
        + ContainerID() string
        + Inspect() (*define.InspectExecSession, error)

    }
    class HTTPAttachStreams << (S,Aquamarine) >> {
        + Stdin bool
        + Stdout bool
        + Stderr bool

    }
    class HealthCheckConfig << (S,Aquamarine) >> {
        + SetTo(config *ContainerConfig) 
        + IsNil() bool
        + IsStartup() bool
        + IsTimeChanged(oldInterval time.Duration) bool
        + GetInterval() time.Duration
        + SetCurrentConfigTo(healthCheckOptions *define.HealthCheckOptions) 
        + IsHealthCheckCommandSet(updateHealthCheckConfig define.UpdateHealthCheckConfig) bool
        + SetNewHealthCheckOptions(updateHealthCheckConfig define.UpdateHealthCheckConfig, healthCheckOptions *define.HealthCheckOptions) bool

    }
    interface IHealthCheckConfig  {
        + SetTo(config *ContainerConfig) 
        + IsStartup() bool
        + IsNil() bool
        + IsTimeChanged(oldInterval time.Duration) bool
        + GetInterval() time.Duration
        + SetCurrentConfigTo(healthCheckOptions *define.HealthCheckOptions) 
        + IsHealthCheckCommandSet(updateHealthCheckConfig define.UpdateHealthCheckConfig) bool
        + SetNewHealthCheckOptions(updateHealthCheckConfig define.UpdateHealthCheckConfig, healthCheckOptions *define.HealthCheckOptions) bool

    }
    class InfraInherit << (S,Aquamarine) >> {
        + ApparmorProfile string
        + CapAdd []string
        + CapDrop []string
        + HostDeviceList []specs-go.LinuxDevice
        + ImageVolumes []*specgen.ImageVolume
        + Mounts []specs-go.Mount
        + NoNewPrivileges bool
        + OverlayVolumes []*specgen.OverlayVolume
        + SeccompPolicy string
        + SeccompProfilePath string
        + SelinuxOpts []string
        + Volumes []*specgen.NamedVolume
        + ShmSize *int64
        + ShmSizeSystemd *int64
        + UseImageHosts bool
        + UseImageHostname bool

        + IsDefaultShmSize() bool

    }
    class LinuxNS << (S,Aquamarine) >> {
        + String() string

    }
    class MissingRuntime << (S,Aquamarine) >> {
        + Name() string
        + Path() string
        + CreateContainer(ctr *Container, restoreOptions *ContainerCheckpointOptions) (int64, error)
        + StartContainer(ctr *Container) error
        + UpdateContainer(ctr *Container, resources *specs-go.LinuxResources) error
        + KillContainer(ctr *Container, signal uint, all bool) error
        + StopContainer(ctr *Container, timeout uint, all bool) error
        + DeleteContainer(ctr *Container) error
        + PauseContainer(ctr *Container) error
        + UnpauseContainer(ctr *Container) error
        + Attach(ctr *Container, params *AttachOptions) error
        + HTTPAttach(ctr *Container, req *http.Request, w http.ResponseWriter, streams *HTTPAttachStreams, detachKeys *string, cancel <font color=blue>chan</font> bool, hijackDone <font color=blue>chan</font> bool, streamAttach bool, streamLogs bool) error
        + AttachResize(ctr *Container, newSize resize.TerminalSize) error
        + ExecContainer(ctr *Container, sessionID string, options *ExecOptions, streams *define.AttachStreams, newSize *resize.TerminalSize) (int, <font color=blue>chan</font> error, error)
        + ExecContainerHTTP(ctr *Container, sessionID string, options *ExecOptions, req *http.Request, w http.ResponseWriter, streams *HTTPAttachStreams, cancel <font color=blue>chan</font> bool, hijackDone <font color=blue>chan</font> bool, holdConnOpen <font color=blue>chan</font> bool, newSize *resize.TerminalSize) (int, <font color=blue>chan</font> error, error)
        + ExecContainerDetached(ctr *Container, sessionID string, options *ExecOptions, stdin bool) (int, error)
        + ExecAttachResize(ctr *Container, sessionID string, newSize resize.TerminalSize) error
        + ExecStopContainer(ctr *Container, sessionID string, timeout uint) error
        + ExecUpdateStatus(ctr *Container, sessionID string) (bool, error)
        + CheckpointContainer(ctr *Container, options ContainerCheckpointOptions) (int64, error)
        + CheckConmonRunning(ctr *Container) (bool, error)
        + SupportsCheckpoint() bool
        + SupportsJSONErrors() bool
        + SupportsNoCgroups() bool
        + SupportsKVM() bool
        + AttachSocketPath(ctr *Container) (string, error)
        + ExecAttachSocketPath(ctr *Container, sessionID string) (string, error)
        + ExitFilePath(ctr *Container) (string, error)
        + OOMFilePath(ctr *Container) (string, error)
        + PersistDirectoryPath(ctr *Container) (string, error)
        + RuntimeInfo() (*define.ConmonInfo, *define.OCIRuntimeInfo, error)

    }
    class Netstat << (S,Aquamarine) >> {
        + Statistics NetstatInterface

    }
    class NetstatAddress << (S,Aquamarine) >> {
        + Name string
        + Flags string
        + Mtu int
        + Network string
        + Address string
        + ReceivedPackets uint64
        + ReceivedBytes uint64
        + ReceivedErrors uint64
        + SentPackets uint64
        + SentBytes uint64
        + SentErrors uint64
        + DroppedPackets uint64
        + Collisions uint64

    }
    class NetstatInterface << (S,Aquamarine) >> {
        + Interface []NetstatAddress

    }
    interface OCIRuntime  {
        + Name() string
        + Path() string
        + CreateContainer(ctr *Container, restoreOptions *ContainerCheckpointOptions) (int64, error)
        + StartContainer(ctr *Container) error
        + KillContainer(ctr *Container, signal uint, all bool) error
        + StopContainer(ctr *Container, timeout uint, all bool) error
        + DeleteContainer(ctr *Container) error
        + PauseContainer(ctr *Container) error
        + UnpauseContainer(ctr *Container) error
        + Attach(ctr *Container, params *AttachOptions) error
        + HTTPAttach(ctr *Container, r *http.Request, w http.ResponseWriter, streams *HTTPAttachStreams, detachKeys *string, cancel <font color=blue>chan</font> bool, hijackDone <font color=blue>chan</font> bool, streamAttach bool, streamLogs bool) error
        + AttachResize(ctr *Container, newSize resize.TerminalSize) error
        + ExecContainer(ctr *Container, sessionID string, options *ExecOptions, streams *define.AttachStreams, newSize *resize.TerminalSize) (int, <font color=blue>chan</font> error, error)
        + ExecContainerHTTP(ctr *Container, sessionID string, options *ExecOptions, r *http.Request, w http.ResponseWriter, streams *HTTPAttachStreams, cancel <font color=blue>chan</font> bool, hijackDone <font color=blue>chan</font> bool, holdConnOpen <font color=blue>chan</font> bool, newSize *resize.TerminalSize) (int, <font color=blue>chan</font> error, error)
        + ExecContainerDetached(ctr *Container, sessionID string, options *ExecOptions, stdin bool) (int, error)
        + ExecAttachResize(ctr *Container, sessionID string, newSize resize.TerminalSize) error
        + ExecStopContainer(ctr *Container, sessionID string, timeout uint) error
        + ExecUpdateStatus(ctr *Container, sessionID string) (bool, error)
        + CheckpointContainer(ctr *Container, options ContainerCheckpointOptions) (int64, error)
        + CheckConmonRunning(ctr *Container) (bool, error)
        + SupportsCheckpoint() bool
        + SupportsJSONErrors() bool
        + SupportsNoCgroups() bool
        + SupportsKVM() bool
        + AttachSocketPath(ctr *Container) (string, error)
        + ExecAttachSocketPath(ctr *Container, sessionID string) (string, error)
        + ExitFilePath(ctr *Container) (string, error)
        + OOMFilePath(ctr *Container) (string, error)
        + PersistDirectoryPath(ctr *Container) (string, error)
        + RuntimeInfo() (*define.ConmonInfo, *define.OCIRuntimeInfo, error)
        + UpdateContainer(ctr *Container, res *specs.LinuxResources) error

    }
    class Pod << (S,Aquamarine) >> {
        + GenerateForKube(ctx context.Context, getService bool, podmanOnly bool) (*v1.Pod, []v1.ServicePort, error)
        + ID() string
        + Name() string
        + MountLabel() (string, error)
        + Namespace() string
        + ResourceLim() *specs.LinuxResources
        + CPUPeriod() uint64
        + CPUQuota() int64
        + MemoryLimit() uint64
        + MemorySwap() uint64
        + BlkioWeight() uint64
        + CPUSetMems() string
        + CPUShares() uint64
        + BlkiThrottleReadBps() []define.InspectBlkioThrottleDevice
        + BlkiThrottleWriteBps() []define.InspectBlkioThrottleDevice
        + NetworkMode() string
        + NamespaceMode(kind specs.LinuxNamespaceType) string
        + VolumesFrom() []string
        + Labels() <font color=blue>map</font>[string]string
        + CreatedTime() time.Time
        + CreateCommand() []string
        + CgroupParent() string
        + SharesPID() bool
        + SharesIPC() bool
        + SharesNet() bool
        + SharesMount() bool
        + SharesUser() bool
        + SharesUTS() bool
        + SharesCgroup() bool
        + Hostname() string
        + CgroupPath() (string, error)
        + HasContainer(id string) (bool, error)
        + AllContainersByID() ([]string, error)
        + AllContainers() ([]*Container, error)
        + HasInfraContainer() bool
        + SharesNamespaces() bool
        + InfraContainerID() (string, error)
        + InfraContainer() (*Container, error)
        + GetPodStats() (<font color=blue>map</font>[string]*define.ContainerStats, error)
        + ProcessLabel() (string, error)
        + Config() (*PodConfig, error)
        + ConfigNoCopy() *PodConfig
        + Start(ctx context.Context) (<font color=blue>map</font>[string]error, error)
        + Stop(ctx context.Context, cleanup bool) (<font color=blue>map</font>[string]error, error)
        + StopWithTimeout(ctx context.Context, cleanup bool, timeout int) (<font color=blue>map</font>[string]error, error)
        + Cleanup(ctx context.Context) (<font color=blue>map</font>[string]error, error)
        + Pause(ctx context.Context) (<font color=blue>map</font>[string]error, error)
        + Unpause(ctx context.Context) (<font color=blue>map</font>[string]error, error)
        + Restart(ctx context.Context) (<font color=blue>map</font>[string]error, error)
        + Kill(ctx context.Context, signal uint) (<font color=blue>map</font>[string]error, error)
        + Status() (<font color=blue>map</font>[string]define.ContainerStatus, error)
        + Inspect() (*define.InspectPodData, error)
        + GetPodStatus() (string, error)
        + GetPodPidInformation(descriptors []string) ([]string, error)
        + GetPodPidInformation(descriptors []string) ([]string, error)
        + ServiceContainer() (*Container, error)

    }
    class PodConfig << (S,Aquamarine) >> {
        + ID string
        + Name string
        + Namespace string
        + Hostname string
        + Labels <font color=blue>map</font>[string]string
        + CgroupParent string
        + UsePodCgroup bool
        + UsePodPID bool
        + UsePodIPC bool
        + UsePodNet bool
        + UsePodMount bool
        + UsePodUser bool
        + UsePodUTS bool
        + UsePodCgroupNS bool
        + HasInfra bool
        + ServiceContainerID string
        + CreatedTime time.Time
        + CreateCommand []string
        + ExitPolicy config.PodExitPolicy
        + RestartPolicy string
        + RestartRetries *uint
        + LockID uint32
        + ResourceLimits specs.LinuxResources

    }
    class PodContainerStats << (S,Aquamarine) >> {
        + Pod *Pod
        + ContainerStats <font color=blue>map</font>[string]*define.ContainerStats

    }
    class RootlessNetNS << (S,Aquamarine) >> {
        + Lock *lockfile.LockFile

        + Do(toRun <font color=blue>func</font>() error) error
        + Cleanup(runtime *Runtime) error

    }
    class Runtime << (S,Aquamarine) >> {
        + Log(ctx context.Context, containers []*Container, options *logs.LogOptions, logChannel <font color=blue>chan</font> *logs.LogLine) error
        + GetDiff(from string, to string, diffType define.DiffType) ([]archive.Change, error)
        + NewNetworkEvent(status events.Status, netName string, netID string, netDriver string) 
        + NewSystemEvent(status events.Status) 
        + Events(ctx context.Context, options events.ReadOptions) error
        + GetEvents(ctx context.Context, filters []string) ([]*events.Event, error)
        + GetExecDiedEvent(ctx context.Context, nameOrID string, execSessionID string) (*events.Event, error)
        + HealthCheck(ctx context.Context, name string) (define.HealthCheckStatus, error)
        + GetHostDistributionInfo() define.DistributionInfo
        + DisconnectContainerFromNetwork(nameOrID string, netName string, force bool) error
        + ConnectContainerToNetwork(nameOrID string, netName string, netOpts types.PerNetworkOptions) error
        + GetRootlessNetNs(new bool) (*RootlessNetNS, error)
        + WithPod(pod *Pod) CtrCreateOption
        + Reset(ctx context.Context) error
        + TmpDir() (string, error)
        + GetConfigNoCopy() (*config.Config, error)
        + GetConfig() (*config.Config, error)
        + DeferredShutdown(force bool) 
        + Shutdown(force bool) error
        + Info() (*define.Info, error)
        + LibimageRuntime() *libimage.Runtime
        + SystemContext() *types.SystemContext
        + GetOCIRuntimePath() string
        + DefaultOCIRuntime() OCIRuntime
        + StorageConfig() storage.StoreOptions
        + GarbageCollect() error
        + RunRoot() string
        + GraphRoot() string
        + GetPodName(id string) (string, error)
        + EnableLabeling() bool
        + Reload() error
        + GetSecretsStorageDir() string
        + SecretsManager() (*secrets.SecretsManager, error)
        + Network() types.ContainerNetwork
        + GetDefaultNetworkName() string
        + RemoteURI() string
        + SetRemoteURI(uri string) 
        + LockConflicts() (<font color=blue>map</font>[uint32][]string, []uint32, error)
        + PruneBuildContainers() ([]*reports.PruneReport, error)
        + SystemCheck(ctx context.Context, options entities.SystemCheckOptions) (entities.SystemCheckReport, error)
        + GetContainerExitCode(id string) (int32, error)
        + ListStorageContainers() ([]*StorageContainer, error)
        + StorageContainer(idOrName string) (*storage.Container, error)
        + RemoveStorageContainer(idOrName string, force bool) error
        + NewContainer(ctx context.Context, rSpec *specs-go.Spec, spec *specgen.SpecGenerator, infra bool, options ...CtrCreateOption) (*Container, error)
        + PrepareVolumeOnCreateContainer(ctx context.Context, ctr *Container) error
        + RestoreContainer(ctx context.Context, rSpec *specs-go.Spec, config *ContainerConfig) (*Container, error)
        + RenameContainer(ctx context.Context, ctr *Container, newName string) (*Container, error)
        + RemoveContainer(ctx context.Context, c *Container, force bool, removeVolume bool, timeout *uint) error
        + RemoveContainerAndDependencies(ctx context.Context, c *Container, force bool, removeVolume bool, timeout *uint) (<font color=blue>map</font>[string]error, <font color=blue>map</font>[string]error, error)
        + EvictContainer(ctx context.Context, idOrName string, removeVolume bool) (string, error)
        + GetContainer(id string) (*Container, error)
        + HasContainer(id string) (bool, error)
        + LookupContainer(idOrName string) (*Container, error)
        + LookupContainerID(idOrName string) (string, error)
        + GetContainers(loadState bool, filters ...ContainerFilter) ([]*Container, error)
        + GetAllContainers() ([]*Container, error)
        + GetRunningContainers() ([]*Container, error)
        + GetContainersByList(containers []string) ([]*Container, error)
        + GetLatestContainer() (*Container, error)
        + GetExecSessionContainer(id string) (*Container, error)
        + PruneContainers(filterFuncs []ContainerFilter) ([]*reports.PruneReport, error)
        + MountStorageContainer(id string) (string, error)
        + UnmountStorageContainer(id string, force bool) (bool, error)
        + IsStorageContainerMounted(id string) (bool, string, error)
        + StorageContainers() ([]storage.Container, error)
        + IsBuildahContainer(id string) (bool, error)
        + RemoveContainersForImageCallback(ctx context.Context) libimage.RemoveContainerFunc
        + IsExternalContainerCallback(_ context.Context) libimage.IsExternalContainerFunc
        + Build(ctx context.Context, options define.BuildOptions, dockerfiles ...string) (string, reference.Canonical, error)
        + Migrate(newRuntime string) error
        + Migrate(newRuntime string) error
        + RemovePod(ctx context.Context, p *Pod, removeCtrs bool, force bool, timeout *uint) (<font color=blue>map</font>[string]error, error)
        + GetPod(id string) (*Pod, error)
        + HasPod(id string) (bool, error)
        + LookupPod(idOrName string) (*Pod, error)
        + Pods(filters ...PodFilter) ([]*Pod, error)
        + GetAllPods() ([]*Pod, error)
        + GetLatestPod() (*Pod, error)
        + GetRunningPods() ([]*Pod, error)
        + PrunePods(ctx context.Context) (<font color=blue>map</font>[string]error, error)
        + NewPod(ctx context.Context, p specgen.PodSpecGenerator, options ...PodCreateOption) (*Pod, error)
        + AddInfra(ctx context.Context, pod *Pod, infraCtr *Container) (*Pod, error)
        + SavePod(pod *Pod) error
        + RenumberLocks() error
        + RemoveVolume(ctx context.Context, v *Volume, force bool, timeout *uint) error
        + GetVolume(name string) (*Volume, error)
        + LookupVolume(name string) (*Volume, error)
        + HasVolume(name string) (bool, error)
        + Volumes(filters ...VolumeFilter) ([]*Volume, error)
        + GetAllVolumes() ([]*Volume, error)
        + PruneVolumes(ctx context.Context, filterFuncs []VolumeFilter) ([]*reports.PruneReport, error)
        + NewVolume(ctx context.Context, options ...VolumeCreateOption) (*Volume, error)
        + UpdateVolumePlugins(ctx context.Context) *define.VolumeReload

    }
    class RuntimeContainerMetadata << (S,Aquamarine) >> {
        + ImageName string
        + ImageID string
        + ContainerName string
        + CreatedAt int64
        + MountLabel string

        + SetMountLabel(mountLabel string) 

    }
    class SQLiteState << (S,Aquamarine) >> {
        + Close() error
        + Refresh() error
        + GetDBConfig() (*DBConfig, error)
        + ValidateDBConfig(runtime *Runtime) error
        + GetContainerName(id string) (string, error)
        + GetPodName(id string) (string, error)
        + Container(id string) (*Container, error)
        + LookupContainerID(idOrName string) (string, error)
        + LookupContainer(idOrName string) (*Container, error)
        + HasContainer(id string) (bool, error)
        + AddContainer(ctr *Container) error
        + RemoveContainer(ctr *Container) error
        + UpdateContainer(ctr *Container) error
        + SaveContainer(ctr *Container) error
        + ContainerInUse(ctr *Container) ([]string, error)
        + AllContainers(loadState bool) ([]*Container, error)
        + GetNetworks(ctr *Container) (<font color=blue>map</font>[string]types.PerNetworkOptions, error)
        + NetworkConnect(ctr *Container, network string, opts types.PerNetworkOptions) error
        + NetworkModify(ctr *Container, network string, opts types.PerNetworkOptions) error
        + NetworkDisconnect(ctr *Container, network string) error
        + GetContainerConfig(id string) (*ContainerConfig, error)
        + AddContainerExitCode(id string, exitCode int32) error
        + GetContainerExitCode(id string) (int32, error)
        + GetContainerExitCodeTimeStamp(id string) (*time.Time, error)
        + PruneContainerExitCodes() error
        + AddExecSession(ctr *Container, session *ExecSession) error
        + GetExecSession(id string) (string, error)
        + RemoveExecSession(session *ExecSession) error
        + GetContainerExecSessions(ctr *Container) ([]string, error)
        + RemoveContainerExecSessions(ctr *Container) error
        + RewriteContainerConfig(ctr *Container, newCfg *ContainerConfig) error
        + SafeRewriteContainerConfig(ctr *Container, oldName string, newName string, newCfg *ContainerConfig) error
        + RewritePodConfig(pod *Pod, newCfg *PodConfig) error
        + RewriteVolumeConfig(volume *Volume, newCfg *VolumeConfig) error
        + Pod(id string) (*Pod, error)
        + LookupPod(idOrName string) (*Pod, error)
        + HasPod(id string) (bool, error)
        + PodHasContainer(pod *Pod, id string) (bool, error)
        + PodContainersByID(pod *Pod) ([]string, error)
        + PodContainers(pod *Pod) ([]*Container, error)
        + AddPod(pod *Pod) error
        + RemovePod(pod *Pod) error
        + RemovePodContainers(pod *Pod) error
        + AddContainerToPod(pod *Pod, ctr *Container) error
        + RemoveContainerFromPod(pod *Pod, ctr *Container) error
        + UpdatePod(pod *Pod) error
        + SavePod(pod *Pod) error
        + AllPods() ([]*Pod, error)
        + AddVolume(volume *Volume) error
        + RemoveVolume(volume *Volume) error
        + UpdateVolume(volume *Volume) error
        + SaveVolume(volume *Volume) error
        + AllVolumes() ([]*Volume, error)
        + Volume(name string) (*Volume, error)
        + LookupVolume(name string) (*Volume, error)
        + HasVolume(name string) (bool, error)
        + VolumeInUse(volume *Volume) ([]string, error)
        + ContainerIDIsVolume(id string) (bool, error)

    }
    class Service << (S,Aquamarine) >> {
        + Pods []string

    }
    class StartupHealthCheckConfig << (S,Aquamarine) >> {
        + SetTo(config *ContainerConfig) 
        + IsNil() bool
        + IsStartup() bool
        + IsTimeChanged(oldInterval time.Duration) bool
        + GetInterval() time.Duration
        + SetCurrentConfigTo(healthCheckOptions *define.HealthCheckOptions) 
        + IsHealthCheckCommandSet(updateHealthCheckConfig define.UpdateHealthCheckConfig) bool
        + SetNewHealthCheckOptions(updateHealthCheckConfig define.UpdateHealthCheckConfig, healthCheckOptions *define.HealthCheckOptions) bool

    }
    interface State  {
        + Close() error
        + Refresh() error
        + GetDBConfig() (*DBConfig, error)
        + ValidateDBConfig(runtime *Runtime) error
        + GetContainerName(id string) (string, error)
        + GetPodName(id string) (string, error)
        + Container(id string) (*Container, error)
        + LookupContainerID(idOrName string) (string, error)
        + LookupContainer(idOrName string) (*Container, error)
        + HasContainer(id string) (bool, error)
        + AddContainer(ctr *Container) error
        + RemoveContainer(ctr *Container) error
        + UpdateContainer(ctr *Container) error
        + SaveContainer(ctr *Container) error
        + ContainerInUse(ctr *Container) ([]string, error)
        + AllContainers(loadState bool) ([]*Container, error)
        + GetNetworks(ctr *Container) (<font color=blue>map</font>[string]types.PerNetworkOptions, error)
        + NetworkConnect(ctr *Container, network string, opts types.PerNetworkOptions) error
        + NetworkModify(ctr *Container, network string, opts types.PerNetworkOptions) error
        + NetworkDisconnect(ctr *Container, network string) error
        + GetContainerConfig(id string) (*ContainerConfig, error)
        + AddContainerExitCode(id string, exitCode int32) error
        + GetContainerExitCode(id string) (int32, error)
        + PruneContainerExitCodes() error
        + AddExecSession(ctr *Container, session *ExecSession) error
        + GetExecSession(id string) (string, error)
        + RemoveExecSession(session *ExecSession) error
        + GetContainerExecSessions(ctr *Container) ([]string, error)
        + RemoveContainerExecSessions(ctr *Container) error
        + ContainerIDIsVolume(id string) (bool, error)
        + RewriteContainerConfig(ctr *Container, newCfg *ContainerConfig) error
        + SafeRewriteContainerConfig(ctr *Container, oldName string, newName string, newCfg *ContainerConfig) error
        + RewritePodConfig(pod *Pod, newCfg *PodConfig) error
        + RewriteVolumeConfig(volume *Volume, newCfg *VolumeConfig) error
        + Pod(id string) (*Pod, error)
        + LookupPod(idOrName string) (*Pod, error)
        + HasPod(id string) (bool, error)
        + PodHasContainer(pod *Pod, ctrID string) (bool, error)
        + PodContainersByID(pod *Pod) ([]string, error)
        + PodContainers(pod *Pod) ([]*Container, error)
        + AddPod(pod *Pod) error
        + RemovePod(pod *Pod) error
        + RemovePodContainers(pod *Pod) error
        + AddContainerToPod(pod *Pod, ctr *Container) error
        + RemoveContainerFromPod(pod *Pod, ctr *Container) error
        + UpdatePod(pod *Pod) error
        + SavePod(pod *Pod) error
        + AllPods() ([]*Pod, error)
        + Volume(volName string) (*Volume, error)
        + LookupVolume(name string) (*Volume, error)
        + HasVolume(volName string) (bool, error)
        + VolumeInUse(volume *Volume) ([]string, error)
        + AddVolume(volume *Volume) error
        + RemoveVolume(volume *Volume) error
        + UpdateVolume(volume *Volume) error
        + SaveVolume(volume *Volume) error
        + AllVolumes() ([]*Volume, error)

    }
    class StorageContainer << (S,Aquamarine) >> {
        + ID string
        + Names []string
        + Image string
        + CreateTime time.Time
        + PresentInLibpod bool

    }
    class Volume << (S,Aquamarine) >> {
        + GenerateForKube() *v1.PersistentVolumeClaim
        + Name() string
        + Size() (uint64, error)
        + Driver() string
        + Scope() string
        + Labels() <font color=blue>map</font>[string]string
        + MountPoint() (string, error)
        + MountCount() (uint, error)
        + Options() <font color=blue>map</font>[string]string
        + Anonymous() bool
        + UID() (int, error)
        + GID() (int, error)
        + CreatedTime() time.Time
        + Config() (*VolumeConfig, error)
        + VolumeInUse() ([]string, error)
        + IsDangling() (bool, error)
        + UsesVolumeDriver() bool
        + Mount() (string, error)
        + Unmount() error
        + NeedsMount() bool
        + Inspect() (*define.InspectVolumeData, error)

    }
    class VolumeConfig << (S,Aquamarine) >> {
        + Name string
        + LockID uint32
        + Labels <font color=blue>map</font>[string]string
        + Driver string
        + MountPoint string
        + CreatedTime time.Time
        + Options <font color=blue>map</font>[string]string
        + IsAnon bool
        + UID int
        + GID int
        + Size uint64
        + Inodes uint64
        + DisableQuota bool
        + Timeout *uint
        + StorageName string
        + StorageID string
        + StorageImageID string
        + MountLabel string

    }
    class VolumeState << (S,Aquamarine) >> {
        + MountPoint string
        + MountCount uint
        + NeedsCopyUp bool
        + NeedsChown bool
        + CopiedUp bool
        + UIDChowned int
        + GIDChowned int

    }
    class YAMLContainer << (S,Aquamarine) >> {
        + Resources *v1.ResourceRequirements

    }
    class YAMLDaemonSet << (S,Aquamarine) >> {
        + Spec *YAMLDaemonSetSpec
        + Status *v1.DaemonSetStatus

    }
    class YAMLDaemonSetSpec << (S,Aquamarine) >> {
        + Template *YAMLPodTemplateSpec
        + Strategy *v1.DaemonSetUpdateStrategy

    }
    class YAMLDeployment << (S,Aquamarine) >> {
        + Spec *YAMLDeploymentSpec
        + Status *v1.DeploymentStatus

    }
    class YAMLDeploymentSpec << (S,Aquamarine) >> {
        + Template *YAMLPodTemplateSpec
        + Strategy *v1.DeploymentStrategy

    }
    class YAMLJob << (S,Aquamarine) >> {
        + Spec *YAMLJobSpec
        + Status *v1.JobStatus

    }
    class YAMLJobSpec << (S,Aquamarine) >> {
        + Template *YAMLPodTemplateSpec

    }
    class YAMLPod << (S,Aquamarine) >> {
        + Spec *YAMLPodSpec
        + Status *v1.PodStatus

    }
    class YAMLPodSpec << (S,Aquamarine) >> {
        + Containers []*YAMLContainer

    }
    class YAMLPodTemplateSpec << (S,Aquamarine) >> {
        + Spec *YAMLPodSpec

    }
    class YAMLService << (S,Aquamarine) >> {
        + Status *v1.ServiceStatus

    }
    class byDestination << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class conmonPipeData << (S,Aquamarine) >> {
    }
    class containerNode << (S,Aquamarine) >> {
    }
    class ctrRmOpts << (S,Aquamarine) >> {
        + Force bool
        + RemoveVolume bool
        + RemovePod bool
        + IgnoreDeps bool
        + RemoveDeps bool
        + NoLockPod bool
        + Timeout *uint

    }
    class dbConfigValidation << (S,Aquamarine) >> {
    }
    class execPipes << (S,Aquamarine) >> {
    }
    class legacyExecSession << (S,Aquamarine) >> {
        + ID string
        + Command []string
        + PID int

    }
    class libpod.ContainerFilter << (T, #FF7700) >>  {
    }
    class libpod.ContainerNetworkDescriptions << (T, #FF7700) >>  {
    }
    class libpod.CtrCreateOption << (T, #FF7700) >>  {
    }
    class libpod.LinuxNS << (T, #FF7700) >>  {
    }
    class libpod.PodCreateOption << (T, #FF7700) >>  {
    }
    class libpod.PodFilter << (T, #FF7700) >>  {
    }
    class libpod.RuntimeOption << (T, #FF7700) >>  {
    }
    class libpod.VolumeCreateOption << (T, #FF7700) >>  {
    }
    class libpod.VolumeFilter << (T, #FF7700) >>  {
    }
    class libpod.byDestination << (T, #FF7700) >>  {
    }
    class libpod.rlimT << (T, #FF7700) >>  {
    }
    class machineExpose << (S,Aquamarine) >> {
        + Local string
        + Remote string
        + Protocol string

    }
    class ociError << (S,Aquamarine) >> {
        + Level string
        + Time string
        + Msg string

    }
    class podState << (S,Aquamarine) >> {
        + CgroupPath string
        + InfraContainerID string

    }
    class safeMountInfo << (S,Aquamarine) >> {
        + Close() 
        + Close() 

    }
    class serviceContainerReport << (S,Aquamarine) >> {
    }
    class servicePortState << (S,Aquamarine) >> {
    }
    class storageService << (S,Aquamarine) >> {
        + CreateContainerStorage(ctx context.Context, systemContext *types.SystemContext, imageName string, imageID string, containerName string, containerID string, options storage.ContainerOptions) (ContainerInfo, error)
        + DeleteContainer(idOrName string) error
        + SetContainerMetadata(idOrName string, metadata RuntimeContainerMetadata) error
        + GetContainerMetadata(idOrName string) (RuntimeContainerMetadata, error)
        + MountContainerImage(idOrName string) (string, error)
        + UnmountContainerImage(idOrName string, force bool) (bool, error)
        + MountedContainerImage(idOrName string) (int, error)
        + GetMountpoint(id string) (string, error)
        + GetWorkDir(id string) (string, error)
        + GetRunDir(id string) (string, error)

    }
    class storageSet << (S,Aquamarine) >> {
        + RunRootSet bool
        + GraphRootSet bool
        + StaticDirSet bool
        + VolumePathSet bool
        + GraphDriverNameSet bool
        + TmpDirSet bool

    }
    class waitResult << (S,Aquamarine) >> {
    }
    class "[]specs-go.Mount" as specsgoMount {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"buildah.CommitOptions" *-- "extends""libpod.ContainerCommitOptions"
"libpod.ContainerImageConfig" *-- "extends""libpod.ContainerConfig"
"libpod.ContainerMiscConfig" *-- "extends""libpod.ContainerConfig"
"libpod.ContainerNameSpaceConfig" *-- "extends""libpod.ContainerConfig"
"libpod.ContainerNetworkConfig" *-- "extends""libpod.ContainerConfig"
"libpod.ContainerRootFSConfig" *-- "extends""libpod.ContainerConfig"
"libpod.ContainerSecurityConfig" *-- "extends""libpod.ContainerConfig"
"secrets.Secret" *-- "extends""libpod.ContainerSecret"
"manifest.Schema2HealthConfig" *-- "extends""libpod.HealthCheckConfig"
"define.StartupHealthCheck" *-- "extends""libpod.StartupHealthCheckConfig"
"v1.Container" *-- "extends""libpod.YAMLContainer"
"v1.DaemonSet" *-- "extends""libpod.YAMLDaemonSet"
"v1.DaemonSetSpec" *-- "extends""libpod.YAMLDaemonSetSpec"
"v1.Deployment" *-- "extends""libpod.YAMLDeployment"
"v1.DeploymentSpec" *-- "extends""libpod.YAMLDeploymentSpec"
"v1.Job" *-- "extends""libpod.YAMLJob"
"v1.JobSpec" *-- "extends""libpod.YAMLJobSpec"
"v1.Pod" *-- "extends""libpod.YAMLPod"
"v1.PodSpec" *-- "extends""libpod.YAMLPodSpec"
"v1.PodTemplateSpec" *-- "extends""libpod.YAMLPodTemplateSpec"
"v1.Service" *-- "extends""libpod.YAMLService"

"libpod.State" <|-- "implements""libpod.BoltState"
"entities.Named" <|-- "implements""libpod.ConmonOCIRuntime"
"entities.Named" <|-- "implements""libpod.Container"
"notifyproxy.Container" <|-- "implements""libpod.Container"
"libpod.IHealthCheckConfig" <|-- "implements""libpod.HealthCheckConfig"
"entities.Named" <|-- "implements""libpod.MissingRuntime"
"entities.Named" <|-- "implements""libpod.Pod"
"libpod.State" <|-- "implements""libpod.SQLiteState"
"libpod.IHealthCheckConfig" <|-- "implements""libpod.StartupHealthCheckConfig"
"entities.Named" <|-- "implements""libpod.Volume"

namespace lock {
    class FileLock << (S,Aquamarine) >> {
        + ID() uint32
        + Lock() 
        + Unlock() 
        + Free() error

    }
    class FileLockManager << (S,Aquamarine) >> {
        + AllocateLock() (Locker, error)
        + AllocateAndRetrieveLock(id uint32) (Locker, error)
        + RetrieveLock(id uint32) (Locker, error)
        + FreeAllLocks() error
        + AvailableLocks() (*uint32, error)
        + LocksHeld() ([]uint32, error)

    }
    class InMemoryManager << (S,Aquamarine) >> {
        + AllocateLock() (Locker, error)
        + RetrieveLock(id uint32) (Locker, error)
        + AllocateAndRetrieveLock(id uint32) (Locker, error)
        + FreeAllLocks() error
        + AvailableLocks() (*uint32, error)
        + LocksHeld() ([]uint32, error)

    }
    interface Locker  {
        + ID() uint32
        + Lock() 
        + Unlock() 
        + Free() error

    }
    interface Manager  {
        + AllocateLock() (Locker, error)
        + RetrieveLock(id uint32) (Locker, error)
        + AllocateAndRetrieveLock(id uint32) (Locker, error)
        + FreeAllLocks() error
        + AvailableLocks() (*uint32, error)
        + LocksHeld() ([]uint32, error)

    }
    class Mutex << (S,Aquamarine) >> {
        + ID() uint32
        + Lock() 
        + Unlock() 
        + Free() error

    }
    class SHMLock << (S,Aquamarine) >> {
        + ID() uint32
        + Lock() 
        + Unlock() 
        + Free() error

    }
    class SHMLockManager << (S,Aquamarine) >> {
        + AllocateLock() (Locker, error)
        + AllocateAndRetrieveLock(id uint32) (Locker, error)
        + RetrieveLock(id uint32) (Locker, error)
        + FreeAllLocks() error
        + AvailableLocks() (*uint32, error)
        + LocksHeld() ([]uint32, error)
        + AllocateLock() (Locker, error)
        + RetrieveLock(id string) (Locker, error)
        + FreeAllLocks() error
        + AvailableLocks() (*uint32, error)
        + LocksHeld() ([]uint32, error)

    }
}

"lock.Locker" <|-- "implements""lock.FileLock"
"lock.Manager" <|-- "implements""lock.FileLockManager"
"lock.Manager" <|-- "implements""lock.InMemoryManager"
"lock.Locker" <|-- "implements""lock.Mutex"
"lock.Locker" <|-- "implements""lock.SHMLock"
"lock.Manager" <|-- "implements""lock.SHMLockManager"

namespace logs {
    class LogLine << (S,Aquamarine) >> {
        + Device string
        + ParseLogType string
        + Time time.Time
        + Msg string
        + CID string
        + CName string
        + ColorID int64

        + String(options *LogOptions) string
        + Since(since time.Time) bool
        + Until(until time.Time) bool
        + Partial() bool
        + Write(stdout io.Writer, stderr io.Writer, logOpts *LogOptions) 

    }
    class LogOptions << (S,Aquamarine) >> {
        + Details bool
        + Follow bool
        + Since time.Time
        + Until time.Time
        + Tail int64
        + Timestamps bool
        + Colors bool
        + Multi bool
        + WaitGroup *sync.WaitGroup
        + UseName bool

    }
}


namespace lookup {
    class Overrides << (S,Aquamarine) >> {
        + DefaultUser *user.ExecUser
        + ContainerEtcPasswdPath string
        + ContainerEtcGroupPath string

    }
}


namespace machine {
    class CleanupCallback << (S,Aquamarine) >> {
        + Funcs []<font color=blue>func</font>() error

        + CleanIfErr(err *error) 
        + CleanOnSignal() 
        + Add(anotherfunc <font color=blue>func</font>() error) 

    }
    class ConnectionConfig << (S,Aquamarine) >> {
        + PodmanSocket *define.VMFile
        + PodmanPipe *define.VMFile

    }
    interface DistributionDownload  {
        + HasUsableCache() (bool, error)
        + Get() *Download
        + CleanCache() error

    }
    class Download << (S,Aquamarine) >> {
        + Arch string
        + Artifact define.Artifact
        + CacheDir string
        + CompressionType compression.ImageCompression
        + DataDir string
        + Format define.ImageFormat
        + ImageName string
        + LocalPath string
        + LocalUncompressedFile string
        + Sha256sum string
        + Size int64
        + URL *url.URL
        + VMKind define.VMType
        + VMName string

        + GetLocalUncompressedFile(dataDir string) string
        + AcquireAlternateImage(inputPath string) (*define.VMFile, error)

    }
    class GenericDownload << (S,Aquamarine) >> {
        + Get() *Download
        + HasUsableCache() (bool, error)
        + CleanCache() error

    }
    class ImageConfig << (S,Aquamarine) >> {
        + IgnitionFile define.VMFile
        + ImageStream string
        + ImagePath define.VMFile

    }
    class InitOptionalFlags << (S,Aquamarine) >> {
        + UserModeNetworking bool

    }
    class InspectInfo << (S,Aquamarine) >> {
        + ConfigDir define.VMFile
        + ConnectionInfo ConnectionConfig
        + Created time.Time
        + LastUp time.Time
        + Name string
        + Resources vmconfigs.ResourceConfig
        + SSHConfig vmconfigs.SSHConfig
        + State define.Status
        + UserModeNetworking bool
        + Rootful bool
        + Rosetta bool

    }
    class InspectOptions << (S,Aquamarine) >> {
    }
    class ListOptions << (S,Aquamarine) >> {
    }
    class ListResponse << (S,Aquamarine) >> {
        + Name string
        + CreatedAt time.Time
        + LastUp time.Time
        + Running bool
        + Starting bool
        + Stream string
        + VMType string
        + CPUs uint64
        + Memory strongunits.MiB
        + DiskSize strongunits.GiB
        + Port int
        + RemoteUsername string
        + IdentityPath string
        + UserModeNetworking bool

    }
    class RemoveOptions << (S,Aquamarine) >> {
        + Force bool
        + SaveImage bool
        + SaveIgnition bool

    }
    class ResetOptions << (S,Aquamarine) >> {
        + Force bool

    }
    class SSHOptions << (S,Aquamarine) >> {
        + Username string
        + Args []string

    }
    class SetFlags << (S,Aquamarine) >> {
        + CPUs uint64
        + DiskSize uint64
        + Memory uint64
        + Rootful bool
        + UserModeNetworking bool
        + USBs []string

    }
    class StartOptions << (S,Aquamarine) >> {
        + NoInfo bool
        + Quiet bool
        + Rosetta bool

    }
    class StopOptions << (S,Aquamarine) >> {
    }
    interface VM  {
        + Init(opts define.InitOptions) (bool, error)
        + Inspect() (*InspectInfo, error)
        + Remove(name string, opts RemoveOptions) (string, <font color=blue>func</font>() error, error)
        + Set(name string, opts define.SetOptions) ([]error, error)
        + SSH(name string, opts SSHOptions) error
        + Start(name string, opts StartOptions) error
        + State(bypass bool) (define.Status, error)
        + Stop(name string, opts StopOptions) error

    }
    class VirtIoFs << (S,Aquamarine) >> {
        + ReadOnly bool
        + Source string
        + Tag string
        + Target string

        + Kind() string
        + ToMount() vmconfigs.Mount

    }
    class Virtualization << (S,Aquamarine) >> {
        + Artifact() define.Artifact
        + Compression() compression.ImageCompression
        + Format() define.ImageFormat
        + VMType() define.VMType
        + NewDownload(vmName string) (Download, error)

    }
    interface Volume  {
        + Kind() VolumeKind

    }
    class WinProxyOpts << (S,Aquamarine) >> {
        + Name string
        + IdentityPath string
        + Port int
        + RemoteUsername string
        + Rootful bool
        + VMType define.VMType
        + Socket *define.VMFile

    }
    class inspectFlagType << (S,Aquamarine) >> {
    }
    class listFlagType << (S,Aquamarine) >> {
    }
    class machine.APIForwardingState << (T, #FF7700) >>  {
    }
    class machine.VolumeKind << (T, #FF7700) >>  {
    }
}
"machine.Download" *-- "extends""machine.GenericDownload"
"machine.VolumeKind" *-- "extends""machine.VirtIoFs"

"machine.DistributionDownload" <|-- "implements""machine.GenericDownload"

namespace main {
    class DirDriver << (S,Aquamarine) >> {
        + Capabilities() *volume.CapabilitiesResponse
        + Create(opts *volume.CreateRequest) error
        + List() (*volume.ListResponse, error)
        + Get(req *volume.GetRequest) (*volume.GetResponse, error)
        + Remove(req *volume.RemoveRequest) error
        + Path(req *volume.PathRequest) (*volume.PathResponse, error)
        + Mount(req *volume.MountRequest) (*volume.MountResponse, error)
        + Unmount(req *volume.UnmountRequest) error

    }
    class EventLogHook << (S,Aquamarine) >> {
        + Fire(entry *logrus.Entry) error
        + Levels() []logrus.Level

    }
    class LogFormat << (S,Aquamarine) >> {
        + Format(entry *logrus.Entry) ([]byte, error)

    }
    class autoUpdateOutput << (S,Aquamarine) >> {
        + Unit string
        + Container string
        + ContainerName string
        + ContainerID string
        + Image string
        + Policy string
        + Updated string

    }
    class cliAutoUpdateOptions << (S,Aquamarine) >> {
    }
    class cliConfig << (S,Aquamarine) >> {
    }
    class clientInfo << (S,Aquamarine) >> {
        + OSArch string
        + Provider string
        + Version string
        + BuildOrigin string

    }
    class dirVol << (S,Aquamarine) >> {
    }
    class fieldStruct << (S,Aquamarine) >> {
        + Comment string
        + Composite bool
        + Name string
        + StructName string
        + Type string

    }
    class launchParams << (S,Aquamarine) >> {
        + Program string
        + User string
        + UID string
        + Target string

    }
    class loginOptionsWrapper << (S,Aquamarine) >> {
    }
    class logrusWriter << (S,Aquamarine) >> {
        + Write(p []byte) (int, error)

    }
    class main.operation << (T, #FF7700) >>  {
    }
    class searchPaths << (S,Aquamarine) >> {
        + Add(path string) 
        + Visited(path string) bool

    }
}
"entities.AutoUpdateOptions" *-- "extends""main.cliAutoUpdateOptions"
"auth.LoginOptions" *-- "extends""main.loginOptionsWrapper"


namespace manifest {
    class manifestAddOptsWrapper << (S,Aquamarine) >> {
    }
    class manifestAnnotateOptsWrapper << (S,Aquamarine) >> {
    }
    class manifestCreateOptsWrapper << (S,Aquamarine) >> {
    }
    class manifestPushOptsWrapper << (S,Aquamarine) >> {
        + TLSVerifyCLI bool
        + CredentialsCLI string
        + SignBySigstoreParamFileCLI string
        + SignPassphraseFileCLI string
        + DigestFile string

    }
}
"entities.ManifestAddOptions" *-- "extends""manifest.manifestAddOptsWrapper"
"entities.ManifestAnnotateOptions" *-- "extends""manifest.manifestAnnotateOptsWrapper"
"entities.ManifestCreateOptions" *-- "extends""manifest.manifestCreateOptsWrapper"
"entities.ImagePushOptions" *-- "extends""manifest.manifestPushOptsWrapper"


namespace manifests {
    class AddArtifactOptions << (S,Aquamarine) >> {
        + Annotation <font color=blue>map</font>[string]string
        + Arch *string
        + Features []string
        + OS *string
        + OSVersion *string
        + OSFeatures []string
        + Variant *string
        + Type **string
        + ConfigType *string
        + Config *string
        + LayerType *string
        + ExcludeTitles *bool
        + Subject *string
        + Annotations <font color=blue>map</font>[string]string
        + Files []string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAnnotation(value <font color=blue>map</font>[string]string) *AddArtifactOptions
        + GetAnnotation() <font color=blue>map</font>[string]string
        + WithArch(value string) *AddArtifactOptions
        + GetArch() string
        + WithFeatures(value []string) *AddArtifactOptions
        + GetFeatures() []string
        + WithOS(value string) *AddArtifactOptions
        + GetOS() string
        + WithOSVersion(value string) *AddArtifactOptions
        + GetOSVersion() string
        + WithOSFeatures(value []string) *AddArtifactOptions
        + GetOSFeatures() []string
        + WithVariant(value string) *AddArtifactOptions
        + GetVariant() string
        + WithType(value *string) *AddArtifactOptions
        + GetType() *string
        + WithConfigType(value string) *AddArtifactOptions
        + GetConfigType() string
        + WithConfig(value string) *AddArtifactOptions
        + GetConfig() string
        + WithLayerType(value string) *AddArtifactOptions
        + GetLayerType() string
        + WithExcludeTitles(value bool) *AddArtifactOptions
        + GetExcludeTitles() bool
        + WithSubject(value string) *AddArtifactOptions
        + GetSubject() string
        + WithAnnotations(value <font color=blue>map</font>[string]string) *AddArtifactOptions
        + GetAnnotations() <font color=blue>map</font>[string]string
        + WithFiles(value []string) *AddArtifactOptions
        + GetFiles() []string

    }
    class AddOptions << (S,Aquamarine) >> {
        + All *bool
        + Annotation <font color=blue>map</font>[string]string
        + Arch *string
        + Features []string
        + OS *string
        + OSVersion *string
        + OSFeatures []string
        + Variant *string
        + Images []string
        + Authfile *string
        + Password *string
        + Username *string
        + SkipTLSVerify *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAll(value bool) *AddOptions
        + GetAll() bool
        + WithAnnotation(value <font color=blue>map</font>[string]string) *AddOptions
        + GetAnnotation() <font color=blue>map</font>[string]string
        + WithArch(value string) *AddOptions
        + GetArch() string
        + WithFeatures(value []string) *AddOptions
        + GetFeatures() []string
        + WithOS(value string) *AddOptions
        + GetOS() string
        + WithOSVersion(value string) *AddOptions
        + GetOSVersion() string
        + WithOSFeatures(value []string) *AddOptions
        + GetOSFeatures() []string
        + WithVariant(value string) *AddOptions
        + GetVariant() string
        + WithImages(value []string) *AddOptions
        + GetImages() []string
        + WithAuthfile(value string) *AddOptions
        + GetAuthfile() string
        + WithPassword(value string) *AddOptions
        + GetPassword() string
        + WithUsername(value string) *AddOptions
        + GetUsername() string
        + WithSkipTLSVerify(value bool) *AddOptions
        + GetSkipTLSVerify() bool

    }
    class CreateOptions << (S,Aquamarine) >> {
        + All *bool
        + Amend *bool
        + Annotation <font color=blue>map</font>[string]string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAll(value bool) *CreateOptions
        + GetAll() bool
        + WithAmend(value bool) *CreateOptions
        + GetAmend() bool
        + WithAnnotation(value <font color=blue>map</font>[string]string) *CreateOptions
        + GetAnnotation() <font color=blue>map</font>[string]string

    }
    class ExistsOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class InspectOptions << (S,Aquamarine) >> {
        + Authfile *string
        + SkipTLSVerify *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAuthfile(value string) *InspectOptions
        + GetAuthfile() string
        + WithSkipTLSVerify(value bool) *InspectOptions
        + GetSkipTLSVerify() bool

    }
    class ModifyOptions << (S,Aquamarine) >> {
        + Operation *string
        + All *bool
        + Annotations <font color=blue>map</font>[string]string
        + IndexAnnotations <font color=blue>map</font>[string]string
        + Arch *string
        + Features []string
        + OS *string
        + OSFeatures []string
        + OSVersion *string
        + Variant *string
        + Images []string
        + Authfile *string
        + Password *string
        + Username *string
        + SkipTLSVerify *bool
        + ArtifactType **string
        + ArtifactConfigType *string
        + ArtifactConfig *string
        + ArtifactLayerType *string
        + ArtifactExcludeTitles *bool
        + ArtifactSubject *string
        + ArtifactAnnotations <font color=blue>map</font>[string]string
        + ArtifactFiles *[]string
        + Body *io.Reader

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithOperation(value string) *ModifyOptions
        + GetOperation() string
        + WithAll(value bool) *ModifyOptions
        + GetAll() bool
        + WithAnnotations(value <font color=blue>map</font>[string]string) *ModifyOptions
        + GetAnnotations() <font color=blue>map</font>[string]string
        + WithIndexAnnotations(value <font color=blue>map</font>[string]string) *ModifyOptions
        + GetIndexAnnotations() <font color=blue>map</font>[string]string
        + WithArch(value string) *ModifyOptions
        + GetArch() string
        + WithFeatures(value []string) *ModifyOptions
        + GetFeatures() []string
        + WithOS(value string) *ModifyOptions
        + GetOS() string
        + WithOSFeatures(value []string) *ModifyOptions
        + GetOSFeatures() []string
        + WithOSVersion(value string) *ModifyOptions
        + GetOSVersion() string
        + WithVariant(value string) *ModifyOptions
        + GetVariant() string
        + WithImages(value []string) *ModifyOptions
        + GetImages() []string
        + WithAuthfile(value string) *ModifyOptions
        + GetAuthfile() string
        + WithPassword(value string) *ModifyOptions
        + GetPassword() string
        + WithUsername(value string) *ModifyOptions
        + GetUsername() string
        + WithSkipTLSVerify(value bool) *ModifyOptions
        + GetSkipTLSVerify() bool
        + WithArtifactType(value *string) *ModifyOptions
        + GetArtifactType() *string
        + WithArtifactConfigType(value string) *ModifyOptions
        + GetArtifactConfigType() string
        + WithArtifactConfig(value string) *ModifyOptions
        + GetArtifactConfig() string
        + WithArtifactLayerType(value string) *ModifyOptions
        + GetArtifactLayerType() string
        + WithArtifactExcludeTitles(value bool) *ModifyOptions
        + GetArtifactExcludeTitles() bool
        + WithArtifactSubject(value string) *ModifyOptions
        + GetArtifactSubject() string
        + WithArtifactAnnotations(value <font color=blue>map</font>[string]string) *ModifyOptions
        + GetArtifactAnnotations() <font color=blue>map</font>[string]string
        + WithArtifactFiles(value []string) *ModifyOptions
        + GetArtifactFiles() []string
        + WithBody(value io.Reader) *ModifyOptions
        + GetBody() io.Reader

    }
    class RemoveOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
}


namespace namespaces {
    class CgroupMode << (S,Aquamarine) >> {
        + IsHost() bool
        + IsDefaultValue() bool
        + IsNS() bool
        + NS() string
        + IsContainer() bool
        + Container() string
        + IsPrivate() bool
        + Valid() bool

    }
    class IpcMode << (S,Aquamarine) >> {
        + IsPrivate() bool
        + IsHost() bool
        + IsShareable() bool
        + IsContainer() bool
        + IsNone() bool
        + IsEmpty() bool
        + Valid() bool
        + Container() string

    }
    class KeepIDUserNsOptions << (S,Aquamarine) >> {
        + UID *uint32
        + GID *uint32
        + MaxSize *uint32

    }
    class NetworkMode << (S,Aquamarine) >> {
        + IsNone() bool
        + IsHost() bool
        + IsDefault() bool
        + IsPrivate() bool
        + IsContainer() bool
        + Container() string
        + UserDefined() string
        + IsBridge() bool
        + IsSlirp4netns() bool
        + IsPasta() bool
        + IsNS() bool
        + NS() string
        + IsPod() bool
        + IsUserDefined() bool

    }
    class PidMode << (S,Aquamarine) >> {
        + IsPrivate() bool
        + IsHost() bool
        + IsContainer() bool
        + Valid() bool
        + Container() string

    }
    class UTSMode << (S,Aquamarine) >> {
        + IsPrivate() bool
        + IsHost() bool
        + IsContainer() bool
        + Container() string
        + Valid() bool

    }
    class UsernsMode << (S,Aquamarine) >> {
        + IsHost() bool
        + IsKeepID() bool
        + IsNoMap() bool
        + IsAuto() bool
        + IsDefaultValue() bool
        + GetKeepIDOptions() (*KeepIDUserNsOptions, error)
        + IsPrivate() bool
        + Valid() bool
        + IsNS() bool
        + NS() string
        + IsContainer() bool
        + Container() string

    }
    class namespaces.CgroupMode << (T, #FF7700) >>  {
    }
    class namespaces.IpcMode << (T, #FF7700) >>  {
    }
    class namespaces.NetworkMode << (T, #FF7700) >>  {
    }
    class namespaces.PidMode << (T, #FF7700) >>  {
    }
    class namespaces.UTSMode << (T, #FF7700) >>  {
    }
    class namespaces.UsernsMode << (T, #FF7700) >>  {
    }
}


namespace network {
    class CreateOptions << (S,Aquamarine) >> {
        + DisableDNS *bool
        + Driver *string
        + Gateway *net.IP
        + Internal *bool
        + Labels <font color=blue>map</font>[string]string
        + MacVLAN *string
        + IPRange *net.IPNet
        + Subnet *net.IPNet
        + IPv6 *bool
        + Options <font color=blue>map</font>[string]string
        + Name *string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithDisableDNS(value bool) *CreateOptions
        + GetDisableDNS() bool
        + WithDriver(value string) *CreateOptions
        + GetDriver() string
        + WithGateway(value net.IP) *CreateOptions
        + GetGateway() net.IP
        + WithInternal(value bool) *CreateOptions
        + GetInternal() bool
        + WithLabels(value <font color=blue>map</font>[string]string) *CreateOptions
        + GetLabels() <font color=blue>map</font>[string]string
        + WithMacVLAN(value string) *CreateOptions
        + GetMacVLAN() string
        + WithIPRange(value net.IPNet) *CreateOptions
        + GetIPRange() net.IPNet
        + WithSubnet(value net.IPNet) *CreateOptions
        + GetSubnet() net.IPNet
        + WithIPv6(value bool) *CreateOptions
        + GetIPv6() bool
        + WithOptions(value <font color=blue>map</font>[string]string) *CreateOptions
        + GetOptions() <font color=blue>map</font>[string]string
        + WithName(value string) *CreateOptions
        + GetName() string

    }
    class DisconnectOptions << (S,Aquamarine) >> {
        + Force *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithForce(value bool) *DisconnectOptions
        + GetForce() bool

    }
    class ExistsOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class ExtraCreateOptions << (S,Aquamarine) >> {
        + IgnoreIfExists *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithIgnoreIfExists(value bool) *ExtraCreateOptions
        + GetIgnoreIfExists() bool

    }
    class InspectOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class ListOptions << (S,Aquamarine) >> {
        + Filters <font color=blue>map</font>[string][]string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithFilters(value <font color=blue>map</font>[string][]string) *ListOptions
        + GetFilters() <font color=blue>map</font>[string][]string

    }
    class ListPrintReports << (S,Aquamarine) >> {
        + Labels() string
        + ID() string

    }
    class PruneOptions << (S,Aquamarine) >> {
        + Filters <font color=blue>map</font>[string][]string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithFilters(value <font color=blue>map</font>[string][]string) *PruneOptions
        + GetFilters() <font color=blue>map</font>[string][]string

    }
    class RemoveOptions << (S,Aquamarine) >> {
        + Force *bool
        + Timeout *uint

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithForce(value bool) *RemoveOptions
        + GetForce() bool
        + WithTimeout(value uint) *RemoveOptions
        + GetTimeout() uint

    }
    class UpdateOptions << (S,Aquamarine) >> {
        + AddDNSServers []string
        + RemoveDNSServers []string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAddDNSServers(value []string) *UpdateOptions
        + GetAddDNSServers() []string
        + WithRemoveDNSServers(value []string) *UpdateOptions
        + GetRemoveDNSServers() []string

    }
}
"types.Network" *-- "extends""network.ListPrintReports"


namespace notifyproxy {
    interface Container  {
        + State() (define.ContainerStatus, error)
        + ID() string

    }
    class NotifyProxy << (S,Aquamarine) >> {
        + SocketPath() string
        + Close() error
        + AddContainer(container Container) 
        + Wait() error

    }
}


namespace ocipull {
    class DiskArtifactOpts << (S,Aquamarine) >> {
    }
    interface Disker  {
        + Get() error

    }
    class LocalBlobDir << (S,Aquamarine) >> {
        + Pull() error
        + Decompress(compressedFile *define.VMFile) (*define.VMFile, error)
        + Unpack() (*define.VMFile, error)
        + DiskEndpoint() string
        + LocalBlob() *types.BlobInfo

    }
    class OCIArtifactDisk << (S,Aquamarine) >> {
        + OriginalFileName() (string, string)
        + Get() error
        + GetNoCompress() (<font color=blue>func</font>() , error)

    }
    class OCIKind << (S,Aquamarine) >> {
        + String() string
        + IsOCIDir() bool

    }
    class OCIOpts << (S,Aquamarine) >> {
        + Scheme *OCIKind
        + Dir *string

    }
    class OSVersion << (S,Aquamarine) >> {
    }
    class PullOptions << (S,Aquamarine) >> {
        + TLSVerify bool
        + Credentials string
        + Quiet bool

    }
    class ocipull.OCIKind << (T, #FF7700) >>  {
    }
}
"semver.Version" *-- "extends""ocipull.OSVersion"

"ocipull.Disker" <|-- "implements""ocipull.OCIArtifactDisk"

namespace os {
    class ApplyOptions << (S,Aquamarine) >> {
        + Image string

    }
    class Distribution << (S,Aquamarine) >> {
        + Name string
        + Variant string

    }
    class MachineOS << (S,Aquamarine) >> {
        + Args []string
        + VM *vmconfigs.MachineConfig
        + Provider vmconfigs.VMProvider
        + VMName string
        + Restart bool

        + Apply(image string, opts ApplyOptions) error

    }
    interface Manager  {
        + Apply(image string, opts ApplyOptions) error

    }
    class ManagerOpts << (S,Aquamarine) >> {
        + VMName string
        + CLIArgs []string
        + Restart bool

    }
    class OSTree << (S,Aquamarine) >> {
        + Apply(image string, opts ApplyOptions) error

    }
}

"os.Manager" <|-- "implements""os.MachineOS"
"os.Manager" <|-- "implements""os.OSTree"

namespace parser {
    class UnitFile << (S,Aquamarine) >> {
        + Filename string
        + Path string

        + Merge(source *UnitFile) 
        + Dup() *UnitFile
        + Parse(data string) error
        + Write(w io.Writer) error
        + ToString() (string, error)
        + HasGroup(groupName string) bool
        + RemoveGroup(groupName string) 
        + RenameGroup(groupName string, newName string) 
        + ListGroups() []string
        + ListKeys(groupName string) []string
        + LookupLastRaw(groupName string, key string) (string, bool)
        + HasKey(groupName string, key string) bool
        + LookupLast(groupName string, key string) (string, bool)
        + Lookup(groupName string, key string) (string, bool)
        + LookupBoolean(groupName string, key string) (bool, bool)
        + LookupBooleanWithDefault(groupName string, key string, defaultValue bool) bool
        + LookupInt(groupName string, key string, defaultValue int64) int64
        + LookupUint32(groupName string, key string, defaultValue uint32) uint32
        + LookupUID(groupName string, key string, defaultValue uint32) (uint32, error)
        + LookupGID(groupName string, key string, defaultValue uint32) (uint32, error)
        + LookupAllRaw(groupName string, key string) []string
        + LookupAll(groupName string, key string) []string
        + LookupAllStrv(groupName string, key string) []string
        + LookupAllArgs(groupName string, key string) []string
        + LookupLastArgs(groupName string, key string) ([]string, bool)
        + LookupAllKeyVal(groupName string, key string) <font color=blue>map</font>[string]string
        + Set(groupName string, key string, value string) 
        + Setv(groupName string, keyvals ...string) 
        + Add(groupName string, key string, value string) 
        + AddCmdline(groupName string, key string, args []string) 
        + Unset(groupName string, key string) 
        + AddComment(groupName string, comments ...string) 
        + PrependComment(groupName string, comments ...string) 
        + PrependUnitLine(groupName string, key string, value string) 
        + GetTemplateParts() (string, string, bool)
        + GetUnitDropinPaths() []string

    }
    class UnitFileParser << (S,Aquamarine) >> {
    }
    class parser.SplitFlags << (T, #FF7700) >>  {
    }
    class unitGroup << (S,Aquamarine) >> {
    }
    class unitLine << (S,Aquamarine) >> {
    }
}


namespace plan9 {
    class Server << (S,Aquamarine) >> {
        + Stop() error
        + WaitForError() error

    }
}


namespace play {
    class play.KubeOptions << (T, #FF7700) >>  {
    }
    class "kube.PlayOptions" as kubePlayOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace plugin {
    class VolumePlugin << (S,Aquamarine) >> {
        + Name string
        + SocketPath string
        + Client *http.Client

        + CreateVolume(req *volume.CreateRequest) error
        + ListVolumes() ([]*volume.Volume, error)
        + GetVolume(req *volume.GetRequest) (*volume.Volume, error)
        + RemoveVolume(req *volume.RemoveRequest) error
        + GetVolumePath(req *volume.PathRequest) (string, error)
        + MountVolume(req *volume.MountRequest) (string, error)
        + UnmountVolume(req *volume.UnmountRequest) error

    }
    class activateResponse << (S,Aquamarine) >> {
        + Implements []string

    }
}


namespace pods {
    class CreateOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class ExistsOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class InspectOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class KillOptions << (S,Aquamarine) >> {
        + Signal *string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithSignal(value string) *KillOptions
        + GetSignal() string

    }
    class ListOptions << (S,Aquamarine) >> {
        + Filters <font color=blue>map</font>[string][]string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithFilters(value <font color=blue>map</font>[string][]string) *ListOptions
        + GetFilters() <font color=blue>map</font>[string][]string

    }
    class ListPodReporter << (S,Aquamarine) >> {
        + Created() string
        + Labels() <font color=blue>map</font>[string]string
        + Label(name string) string
        + Networks() string
        + NumberOfContainers() int
        + ID() string
        + Id() string
        + InfraID() string
        + InfraId() string
        + ContainerIds() string
        + ContainerNames() string
        + ContainerStatuses() string
        + Restarts() string

    }
    class PauseOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class PruneOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class RemoveOptions << (S,Aquamarine) >> {
        + Force *bool
        + Timeout *uint

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithForce(value bool) *RemoveOptions
        + GetForce() bool
        + WithTimeout(value uint) *RemoveOptions
        + GetTimeout() uint

    }
    class RestartOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class StartOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class StatsOptions << (S,Aquamarine) >> {
        + All *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAll(value bool) *StatsOptions
        + GetAll() bool

    }
    class StopOptions << (S,Aquamarine) >> {
        + Timeout *int

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithTimeout(value int) *StopOptions
        + GetTimeout() int

    }
    class TopOptions << (S,Aquamarine) >> {
        + Descriptors []string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithDescriptors(value []string) *TopOptions
        + GetDescriptors() []string

    }
    class UnpauseOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class logsOptionsWrapper << (S,Aquamarine) >> {
        + SinceRaw string
        + UntilRaw string

    }
    class lprSort << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, j int) 

    }
    class podPsSortedCreated << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class podPsSortedID << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class podPsSortedName << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class podPsSortedNumber << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class podPsSortedStatus << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class podRmOptionsWrapper << (S,Aquamarine) >> {
        + PodIDFiles []string

    }
    class podStartOptionsWrapper << (S,Aquamarine) >> {
        + PodIDFiles []string

    }
    class podStatsOptionsWrapper << (S,Aquamarine) >> {
        + Format string
        + NoReset bool
        + NoStream bool

    }
    class podStopOptionsWrapper << (S,Aquamarine) >> {
    }
    class pods.lprSort << (T, #FF7700) >>  {
    }
    class "[]*entities.ListPodsReport" as entitiesListPodsReport {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"entities.ListPodsReport" *-- "extends""pods.ListPodReporter"
"entities.PodLogsOptions" *-- "extends""pods.logsOptionsWrapper"
"pods.lprSort" *-- "extends""pods.podPsSortedCreated"
"pods.lprSort" *-- "extends""pods.podPsSortedID"
"pods.lprSort" *-- "extends""pods.podPsSortedName"
"pods.lprSort" *-- "extends""pods.podPsSortedNumber"
"pods.lprSort" *-- "extends""pods.podPsSortedStatus"
"entities.PodRmOptions" *-- "extends""pods.podRmOptionsWrapper"
"entities.PodStartOptions" *-- "extends""pods.podStartOptionsWrapper"
"entities.PodStatsOptions" *-- "extends""pods.podStatsOptionsWrapper"
"entities.PodStopOptions" *-- "extends""pods.podStopOptionsWrapper"

"entities.Identifier" <|-- "implements""pods.ListPodReporter"

namespace ps {
    class SortContainers << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, j int) 

    }
    class SortCreateTime << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class SortPSContainers << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, j int) 

    }
    class SortPSCreateTime << (S,Aquamarine) >> {
        + Less(i int, j int) bool

    }
    class ps.SortContainers << (T, #FF7700) >>  {
    }
    class ps.SortPSContainers << (T, #FF7700) >>  {
    }
    class "[]entities.ListContainer" as entitiesListContainer {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "[]*libpod.Container" as libpodContainer {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"ps.SortContainers" *-- "extends""ps.SortCreateTime"
"ps.SortPSContainers" *-- "extends""ps.SortPSCreateTime"


namespace qemu {
    class QEMUStubber << (S,Aquamarine) >> {
        + Command command.QemuCmd

        + StopVM(mc *vmconfigs.MachineConfig, _ bool) error
        + Remove(mc *vmconfigs.MachineConfig) ([]string, <font color=blue>func</font>() error, error)
        + State(mc *vmconfigs.MachineConfig, bypass bool) (define.Status, error)
        + UserModeNetworkEnabled( *vmconfigs.MachineConfig) bool
        + UseProviderNetworkSetup() bool
        + RequireExclusiveActive() bool
        + CreateVM(opts define.CreateVMOpts, mc *vmconfigs.MachineConfig, builder *ignition.IgnitionBuilder) error
        + StartVM(mc *vmconfigs.MachineConfig) (<font color=blue>func</font>() error, <font color=blue>func</font>() error, error)
        + Exists(name string) (bool, error)
        + VMType() define.VMType
        + PrepareIgnition(_ *vmconfigs.MachineConfig, _ *ignition.IgnitionBuilder) (*ignition.ReadyUnitOpts, error)
        + StopHostNetworking(_ *vmconfigs.MachineConfig, _ define.VMType) error
        + SetProviderAttrs(mc *vmconfigs.MachineConfig, opts define.SetOptions) error
        + StartNetworking(mc *vmconfigs.MachineConfig, cmd *types.GvproxyCommand) error
        + RemoveAndCleanMachines(_ *define.MachineDirs) error
        + MountVolumesToVM(mc *vmconfigs.MachineConfig, quiet bool) error
        + MountType() vmconfigs.VolumeMountType
        + PostStartNetworking(mc *vmconfigs.MachineConfig, noInfo bool) error
        + UpdateSSHPort(mc *vmconfigs.MachineConfig, port int) error
        + GetRosetta(mc *vmconfigs.MachineConfig) (bool, error)

    }
    class setNewMachineCMDOpts << (S,Aquamarine) >> {
    }
    class virtiofsdHelperCmd << (S,Aquamarine) >> {
    }
    class virtiofsdSpawner << (S,Aquamarine) >> {
    }
}
"vmconfigs.QEMUConfig" *-- "extends""qemu.QEMUStubber"

"vmconfigs.VMProvider" <|-- "implements""qemu.QEMUStubber"

namespace quadlet {
    class PodmanCmdline << (S,Aquamarine) >> {
        + Args []string

    }
    class UnitInfo << (S,Aquamarine) >> {
        + ServiceName string
        + ResourceName string
        + ContainersToStart []string

        + ServiceFileName() string

    }
}


namespace registry {
    class CliCommand << (S,Aquamarine) >> {
        + Command *cobra.Command
        + Parent *cobra.Command

    }
    class Options << (S,Aquamarine) >> {
        + PodmanPath string
        + PodmanArgs []string
        + Image string

    }
    class Registry << (S,Aquamarine) >> {
        + Image string
        + User string
        + Password string
        + Port string

        + Stop() error

    }
}


namespace reports {
    class PruneReport << (S,Aquamarine) >> {
        + Id string
        + Err error
        + Size uint64

    }
    class RmReport << (S,Aquamarine) >> {
        + Id string
        + Err error
        + RawInput string

    }
    class ScpReport << (S,Aquamarine) >> {
        + Id string

    }
}


namespace resource {
    interface CanonicalValue  {
        + AsCanonicalBytes(out []byte) ([]byte, int32)
        + AsCanonicalBase1024Bytes(out []byte) ([]byte, int32)

    }
    class Quantity << (S,Aquamarine) >> {
        + DeepCopy() Quantity
        + CanonicalizeBytes(out []byte) ([]byte, []byte)
        + AsApproximateFloat64() float64
        + AsInt64() (int64, bool)
        + ToDec() *Quantity
        + AsDec() *inf.Dec
        + AsCanonicalBytes(out []byte) ([]byte, int32)
        + IsZero() bool
        + AsScale(scale Scale) (CanonicalValue, bool)
        + Cmp(y Quantity) int
        + CmpInt64(y int64) int
        + String() string
        + MarshalJSON() ([]byte, error)
        + ToUnstructured() <font color=blue>interface</font>{}
        + UnmarshalJSON(value []byte) error
        + Value() int64
        + MilliValue() int64
        + ScaledValue(scale Scale) int64
        + Set(value int64) 
        + SetMilli(value int64) 
        + SetScaled(value int64, scale Scale) 

    }
    class Scale << (S,Aquamarine) >> {
    }
    class bePair << (S,Aquamarine) >> {
    }
    class fastLookup << (S,Aquamarine) >> {
    }
    class infDecAmount << (S,Aquamarine) >> {
        + AsScale(scale Scale) (infDecAmount, bool)
        + AsCanonicalBytes(out []byte) ([]byte, int32)
        + AsCanonicalBase1024Bytes(out []byte) ([]byte, int32)

    }
    class int64Amount << (S,Aquamarine) >> {
        + Sign() int
        + AsInt64() (int64, bool)
        + AsScaledInt64(scale Scale) (int64, bool)
        + AsDec() *inf.Dec
        + Cmp(b int64Amount) int
        + Add(b int64Amount) bool
        + Sub(b int64Amount) bool
        + AsScale(scale Scale) (int64Amount, bool)
        + AsCanonicalBytes(out []byte) ([]byte, int32)
        + AsCanonicalBase1024Bytes(out []byte) ([]byte, int32)

    }
    class listSuffixer << (S,Aquamarine) >> {
    }
    class resource.Format << (T, #FF7700) >>  {
    }
    class resource.Scale << (T, #FF7700) >>  {
    }
    class resource.suffix << (T, #FF7700) >>  {
    }
    class suffixHandler << (S,Aquamarine) >> {
    }
    interface suffixer  {
    }
}
"resource.Format" *-- "extends""resource.Quantity"
"resource.suffixHandler" *-- "extends""resource.fastLookup"
"inf.Dec" *-- "extends""resource.infDecAmount"

"resource.CanonicalValue" <|-- "implements""resource.infDecAmount"
"resource.CanonicalValue" <|-- "implements""resource.int64Amount"
"resource.suffixer" <|-- "implements""resource.suffixHandler"

namespace reversereader {
    class ReverseReader << (S,Aquamarine) >> {
        + Read() (string, error)

    }
}


namespace seccomp {
    class seccomp.Policy << (T, #FF7700) >>  {
    }
}


namespace secrets {
    class CreateOptions << (S,Aquamarine) >> {
        + Name *string
        + Driver *string
        + DriverOpts <font color=blue>map</font>[string]string
        + Labels <font color=blue>map</font>[string]string
        + Replace *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithName(value string) *CreateOptions
        + GetName() string
        + WithDriver(value string) *CreateOptions
        + GetDriver() string
        + WithDriverOpts(value <font color=blue>map</font>[string]string) *CreateOptions
        + GetDriverOpts() <font color=blue>map</font>[string]string
        + WithLabels(value <font color=blue>map</font>[string]string) *CreateOptions
        + GetLabels() <font color=blue>map</font>[string]string
        + WithReplace(value bool) *CreateOptions
        + GetReplace() bool

    }
    class InspectOptions << (S,Aquamarine) >> {
        + ShowSecret *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithShowSecret(value bool) *InspectOptions
        + GetShowSecret() bool

    }
    class ListOptions << (S,Aquamarine) >> {
        + Filters <font color=blue>map</font>[string][]string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithFilters(value <font color=blue>map</font>[string][]string) *ListOptions
        + GetFilters() <font color=blue>map</font>[string][]string

    }
    class RemoveOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class listFlagType << (S,Aquamarine) >> {
    }
}


namespace server {
    class APIServer << (S,Aquamarine) >> {
        + CorsHeaders string
        + PProfAddr string

        + APIHandler(h http.HandlerFunc) http.HandlerFunc
        + StreamBufferedAPIHandler(h http.HandlerFunc) http.HandlerFunc
        + Serve() error
        + Shutdown(halt bool) error
        + Close() error

    }
    class BufferedResponseWriter << (S,Aquamarine) >> {
        + Header() http.Header
        + Hijack() (net.Conn, *bufio.ReadWriter, error)
        + Write(b []byte) (int, error)
        + WriteHeader(statusCode int) 
        + Flush() 

    }
    class responseWriter << (S,Aquamarine) >> {
        + Write(b []byte) (int, error)
        + Hijack() (net.Conn, *bufio.ReadWriter, error)
        + Header() http.Header
        + WriteHeader(statusCode int) 
        + Flush() 

    }
}
"context.CancelFunc" *-- "extends""server.APIServer"
"context.Context" *-- "extends""server.APIServer"
"http.Server" *-- "extends""server.APIServer"
"libpod.Runtime" *-- "extends""server.APIServer"
"net.Listener" *-- "extends""server.APIServer"
"schema.Decoder" *-- "extends""server.APIServer"
"http.ResponseWriter" *-- "extends""server.responseWriter"


namespace shim {
    class knownMachineConfig << (S,Aquamarine) >> {
        + Provider vmconfigs.VMProvider
        + MachineConfig *vmconfigs.MachineConfig

    }
}


namespace shm {
    class SHMLocks << (S,Aquamarine) >> {
        + GetMaxLocks() uint32
        + Close() error
        + AllocateSemaphore() (uint32, error)
        + AllocateGivenSemaphore(sem uint32) error
        + DeallocateSemaphore(sem uint32) error
        + DeallocateAllSemaphores() error
        + LockSemaphore(sem uint32) error
        + UnlockSemaphore(sem uint32) error
        + GetFreeLocks() (uint32, error)
        + GetTakenLocks() ([]uint32, error)
        + GetMaxLocks() uint32
        + Close() error
        + AllocateSemaphore() (uint32, error)
        + AllocateGivenSemaphore(sem uint32) error
        + DeallocateSemaphore(sem uint32) error
        + DeallocateAllSemaphores() error
        + LockSemaphore(sem uint32) error
        + UnlockSemaphore(sem uint32) error
        + GetFreeLocks() (uint32, error)
        + GetTakenLocks() ([]uint32, error)

    }
}


namespace specgen {
    class ContainerBasicConfig << (S,Aquamarine) >> {
        + Name string
        + Pod string
        + Entrypoint []string
        + Command []string
        + EnvHost *bool
        + HTTPProxy *bool
        + Env <font color=blue>map</font>[string]string
        + Terminal *bool
        + Stdin *bool
        + Labels <font color=blue>map</font>[string]string
        + Annotations <font color=blue>map</font>[string]string
        + StopSignal *syscall.Signal
        + StopTimeout *uint
        + Timeout uint
        + LogConfiguration *LogConfig
        + ConmonPidFile string
        + RestartPolicy string
        + RestartRetries *uint
        + OCIRuntime string
        + Systemd string
        + SdNotifyMode string
        + PidNS Namespace
        + UtsNS Namespace
        + Hostname string
        + HostUsers []string
        + Sysctl <font color=blue>map</font>[string]string
        + Remove *bool
        + RemoveImage *bool
        + ContainerCreateCommand []string
        + PreserveFDs uint
        + PreserveFD []uint
        + Timezone string
        + DependencyContainers []string
        + PidFile string
        + EnvSecrets <font color=blue>map</font>[string]string
        + InitContainerType string
        + Personality *specs-go.LinuxPersonality
        + EnvMerge []string
        + UnsetEnv []string
        + UnsetEnvAll *bool
        + Passwd *bool
        + PasswdEntry string
        + GroupEntry string

    }
    class ContainerCgroupConfig << (S,Aquamarine) >> {
        + CgroupNS Namespace
        + CgroupsMode string
        + CgroupParent string

    }
    class ContainerHealthCheckConfig << (S,Aquamarine) >> {
        + HealthConfig *manifest.Schema2HealthConfig
        + HealthCheckOnFailureAction define.HealthCheckOnFailureAction
        + StartupHealthConfig *define.StartupHealthCheck
        + HealthLogDestination string
        + HealthMaxLogCount uint
        + HealthMaxLogSize uint

    }
    class ContainerNetworkConfig << (S,Aquamarine) >> {
        + NetNS Namespace
        + PortMappings []types.PortMapping
        + PublishExposedPorts *bool
        + Expose <font color=blue>map</font>[uint16]string
        + Networks <font color=blue>map</font>[string]types.PerNetworkOptions
        + CNINetworks []string
        + UseImageResolvConf *bool
        + DNSServers []net.IP
        + DNSSearch []string
        + DNSOptions []string
        + UseImageHostname *bool
        + UseImageHosts *bool
        + BaseHostsFile string
        + HostAdd []string
        + NetworkOptions <font color=blue>map</font>[string][]string

    }
    class ContainerResourceConfig << (S,Aquamarine) >> {
        + IntelRdt *specs-go.LinuxIntelRdt
        + ResourceLimits *specs-go.LinuxResources
        + Rlimits []specs-go.POSIXRlimit
        + OOMScoreAdj *int
        + WeightDevice <font color=blue>map</font>[string]specs-go.LinuxWeightDevice
        + ThrottleReadBpsDevice <font color=blue>map</font>[string]specs-go.LinuxThrottleDevice
        + ThrottleWriteBpsDevice <font color=blue>map</font>[string]specs-go.LinuxThrottleDevice
        + ThrottleReadIOPSDevice <font color=blue>map</font>[string]specs-go.LinuxThrottleDevice
        + ThrottleWriteIOPSDevice <font color=blue>map</font>[string]specs-go.LinuxThrottleDevice
        + CgroupConf <font color=blue>map</font>[string]string

    }
    class ContainerSecurityConfig << (S,Aquamarine) >> {
        + Privileged *bool
        + User string
        + Groups []string
        + CapAdd []string
        + CapDrop []string
        + SelinuxOpts []string
        + ApparmorProfile string
        + SeccompPolicy string
        + SeccompProfilePath string
        + NoNewPrivileges *bool
        + UserNS Namespace
        + IDMappings *types.IDMappingOptions
        + ReadOnlyFilesystem *bool
        + ReadWriteTmpfs *bool
        + LabelNested *bool
        + Umask string
        + ProcOpts []string
        + Mask []string
        + Unmask []string

    }
    class ContainerStorageConfig << (S,Aquamarine) >> {
        + Image string
        + RawImageName string
        + ImageOS string
        + ImageArch string
        + ImageVariant string
        + Rootfs string
        + RootfsOverlay *bool
        + RootfsMapping *string
        + ImageVolumeMode string
        + VolumesFrom []string
        + Init *bool
        + InitPath string
        + Mounts []specs-go.Mount
        + Volumes []*NamedVolume
        + OverlayVolumes []*OverlayVolume
        + ImageVolumes []*ImageVolume
        + Devices []specs-go.LinuxDevice
        + DeviceCgroupRule []specs-go.LinuxDeviceCgroup
        + DevicesFrom []string
        + HostDeviceList []specs-go.LinuxDevice
        + IpcNS Namespace
        + ShmSize *int64
        + ShmSizeSystemd *int64
        + WorkDir string
        + CreateWorkingDir *bool
        + StorageOpts <font color=blue>map</font>[string]string
        + RootfsPropagation string
        + Secrets []Secret
        + Volatile *bool
        + ChrootDirs []string

    }
    class ImageVolume << (S,Aquamarine) >> {
        + Source string
        + Destination string
        + ReadWrite bool
        + SubPath string

    }
    class LogConfig << (S,Aquamarine) >> {
        + Driver string
        + Path string
        + Size int64
        + Options <font color=blue>map</font>[string]string

    }
    class NamedVolume << (S,Aquamarine) >> {
        + Name string
        + Dest string
        + Options []string
        + IsAnonymous bool
        + SubPath string

    }
    class Namespace << (S,Aquamarine) >> {
        + NSMode NamespaceMode
        + Value string

        + IsDefault() bool
        + IsHost() bool
        + IsNone() bool
        + IsBridge() bool
        + IsPath() bool
        + IsContainer() bool
        + IsPod() bool
        + IsPrivate() bool
        + IsAuto() bool
        + IsKeepID() bool
        + IsNoMap() bool
        + String() string

    }
    class OverlayVolume << (S,Aquamarine) >> {
        + Destination string
        + Source string
        + Options []string

    }
    class PodBasicConfig << (S,Aquamarine) >> {
        + Name string
        + Hostname string
        + ExitPolicy string
        + Labels <font color=blue>map</font>[string]string
        + NoInfra bool
        + InfraConmonPidFile string
        + InfraCommand []string
        + InfraImage string
        + InfraName string
        + Ipc Namespace
        + SharedNamespaces []string
        + RestartPolicy string
        + RestartRetries *uint
        + ShareParent *bool
        + PodCreateCommand []string
        + Pid Namespace
        + Userns Namespace
        + UtsNs Namespace
        + Devices []string
        + Sysctl <font color=blue>map</font>[string]string

    }
    class PodCgroupConfig << (S,Aquamarine) >> {
        + CgroupParent string

    }
    class PodNetworkConfig << (S,Aquamarine) >> {
        + NetNS Namespace
        + PortMappings []types.PortMapping
        + Networks <font color=blue>map</font>[string]types.PerNetworkOptions
        + CNINetworks []string
        + NoManageResolvConf bool
        + DNSServer []net.IP
        + DNSSearch []string
        + DNSOption []string
        + NoManageHostname bool
        + NoManageHosts bool
        + HostAdd []string
        + HostsFile string
        + NetworkOptions <font color=blue>map</font>[string][]string

    }
    class PodResourceConfig << (S,Aquamarine) >> {
        + ResourceLimits *specs-go.LinuxResources
        + CPUPeriod uint64
        + CPUQuota int64
        + ThrottleReadBpsDevice <font color=blue>map</font>[string]specs-go.LinuxThrottleDevice

    }
    class PodSecurityConfig << (S,Aquamarine) >> {
        + SecurityOpt []string
        + IDMappings *types.IDMappingOptions

    }
    class PodSpecGenerator << (S,Aquamarine) >> {
        + InfraContainerSpec *SpecGenerator
        + ServiceContainerID string

        + Validate() error

    }
    class PodStorageConfig << (S,Aquamarine) >> {
        + Mounts []specs-go.Mount
        + Volumes []*NamedVolume
        + OverlayVolumes []*OverlayVolume
        + ImageVolumes []*ImageVolume
        + VolumesFrom []string
        + ShmSize *int64
        + ShmSizeSystemd *int64

    }
    class Secret << (S,Aquamarine) >> {
        + Source string
        + Target string
        + UID uint32
        + GID uint32
        + Mode uint32

    }
    class SpecGenerator << (S,Aquamarine) >> {
        + Validate() error
        + InitResourceLimits(rtc *config.Config) 
        + InitResourceLimits(rtc *config.Config) 
        + IsPrivileged() bool
        + IsInitContainer() bool
        + SetImage(image *libimage.Image, resolvedImageName string) 
        + GetImage() (*libimage.Image, string)

    }
    class cacheLibImage << (S,Aquamarine) >> {
    }
    class specgen.NamespaceMode << (T, #FF7700) >>  {
    }
}
"specgen.PodBasicConfig" *-- "extends""specgen.PodSpecGenerator"
"specgen.PodCgroupConfig" *-- "extends""specgen.PodSpecGenerator"
"specgen.PodNetworkConfig" *-- "extends""specgen.PodSpecGenerator"
"specgen.PodResourceConfig" *-- "extends""specgen.PodSpecGenerator"
"specgen.PodSecurityConfig" *-- "extends""specgen.PodSpecGenerator"
"specgen.PodStorageConfig" *-- "extends""specgen.PodSpecGenerator"
"specgen.ContainerBasicConfig" *-- "extends""specgen.SpecGenerator"
"specgen.ContainerCgroupConfig" *-- "extends""specgen.SpecGenerator"
"specgen.ContainerHealthCheckConfig" *-- "extends""specgen.SpecGenerator"
"specgen.ContainerNetworkConfig" *-- "extends""specgen.SpecGenerator"
"specgen.ContainerResourceConfig" *-- "extends""specgen.SpecGenerator"
"specgen.ContainerSecurityConfig" *-- "extends""specgen.SpecGenerator"
"specgen.ContainerStorageConfig" *-- "extends""specgen.SpecGenerator"
"specgen.cacheLibImage" *-- "extends""specgen.SpecGenerator"


namespace specgenutil {
    class universalMount << (S,Aquamarine) >> {
    }
}


namespace stdpull {
    class DiskFromURL << (S,Aquamarine) >> {
        + Get() error

    }
    class StdDiskPull << (S,Aquamarine) >> {
        + Get() error

    }
}

"ocipull.Disker" <|-- "implements""stdpull.DiskFromURL"
"ocipull.Disker" <|-- "implements""stdpull.StdDiskPull"

namespace store {
    class ArtifactStore << (S,Aquamarine) >> {
        + SystemContext *types.SystemContext

        + Remove(ctx context.Context, name string) (*digest.Digest, error)
        + Inspect(ctx context.Context, nameOrDigest string) (*libartifact.Artifact, error)
        + List(ctx context.Context) (libartifact.ArtifactList, error)
        + Pull(ctx context.Context, name string, opts libimage.CopyOptions) error
        + Push(ctx context.Context, src string, dest string, opts libimage.CopyOptions) error
        + Add(ctx context.Context, dest string, paths []string, options *types.AddOptions) (*digest.Digest, error)

    }
    class unparsedArtifactImage << (S,Aquamarine) >> {
        + Reference() types.ImageReference
        + Manifest(ctx context.Context) ([]byte, string, error)
        + Signatures(ctx context.Context) ([][]byte, error)

    }
}


namespace swagger {
    class badParamError << (S,Aquamarine) >> {
        + Body errorhandling.ErrorModel

    }
    class conflictError << (S,Aquamarine) >> {
        + Body errorhandling.ErrorModel

    }
    class containerAlreadyStartedError << (S,Aquamarine) >> {
        + Body errorhandling.ErrorModel

    }
    class containerAlreadyStoppedError << (S,Aquamarine) >> {
        + Body errorhandling.ErrorModel

    }
    class containerCreateResponse << (S,Aquamarine) >> {
        + Body entities.ContainerCreateResponse

    }
    class containerInspectResponse << (S,Aquamarine) >> {
        + Body types.ContainerJSON

    }
    class containerInspectResponseLibpod << (S,Aquamarine) >> {
        + Body define.InspectContainerData

    }
    class containerNotFound << (S,Aquamarine) >> {
        + Body errorhandling.ErrorModel

    }
    class containerRemoveLibpod << (S,Aquamarine) >> {
        + Body []handlers.LibpodContainersRmReport

    }
    class containerStats << (S,Aquamarine) >> {
        + Body define.ContainerStats

    }
    class containerTopResponse << (S,Aquamarine) >> {
        + Body handlers.ContainerTopOKBody

    }
    class containerUpdateRequest << (S,Aquamarine) >> {
    }
    class containerUpdateResponse << (S,Aquamarine) >> {
        + Body <font color=blue>struct</font>{string}

    }
    class containerWaitResponse << (S,Aquamarine) >> {
        + Body <font color=blue>struct</font>{int, <font color=blue>struct</font>{string}}

    }
    class containersList << (S,Aquamarine) >> {
        + Body []handlers.Container

    }
    class containersListLibpod << (S,Aquamarine) >> {
        + Body []entities.ListContainer

    }
    class containersPrune << (S,Aquamarine) >> {
        + Body []handlers.ContainersPruneReport

    }
    class containersPruneLibpod << (S,Aquamarine) >> {
        + Body []handlers.ContainersPruneReportLibpod

    }
    class execSessionInspect << (S,Aquamarine) >> {
        + Body define.InspectExecSession

    }
    class execSessionNotFound << (S,Aquamarine) >> {
        + Body errorhandling.ErrorModel

    }
    class healthCheck << (S,Aquamarine) >> {
        + Body define.HealthCheckResults

    }
    class history << (S,Aquamarine) >> {
        + Body handlers.HistoryResponse

    }
    class imageDeleteResponse << (S,Aquamarine) >> {
        + Body []<font color=blue>struct</font>{[]string, string}

    }
    class imageInspect << (S,Aquamarine) >> {
        + Body handlers.ImageInspect

    }
    class imageList << (S,Aquamarine) >> {
        + Body []image.Summary

    }
    class imageListLibpod << (S,Aquamarine) >> {
        + Body []entities.ImageSummary

    }
    class imageNotFound << (S,Aquamarine) >> {
        + Body errorhandling.ErrorModel

    }
    class imagesImportResponseLibpod << (S,Aquamarine) >> {
        + Body entities.ImageImportReport

    }
    class imagesLoadResponseLibpod << (S,Aquamarine) >> {
        + Body entities.ImageLoadReport

    }
    class imagesPruneLibpod << (S,Aquamarine) >> {
        + Body []reports.PruneReport

    }
    class imagesPullResponseLibpod << (S,Aquamarine) >> {
        + Body handlers.LibpodImagesPullReport

    }
    class imagesRemoveResponseLibpod << (S,Aquamarine) >> {
        + Body handlers.LibpodImagesRemoveReport

    }
    class imagesScpResponseLibpod << (S,Aquamarine) >> {
        + Body reports.ScpReport

    }
    class infoResponse << (S,Aquamarine) >> {
        + Body define.Info

    }
    class inspectImageResponseLibpod << (S,Aquamarine) >> {
        + Body inspect.ImageData

    }
    class internalError << (S,Aquamarine) >> {
        + Body errorhandling.ErrorModel

    }
    class manifestInspect << (S,Aquamarine) >> {
        + Body manifest.Schema2List

    }
    class manifestNotFound << (S,Aquamarine) >> {
        + Body errorhandling.ErrorModel

    }
    class networkConnectedError << (S,Aquamarine) >> {
        + Body errorhandling.ErrorModel

    }
    class networkCreateLibpod << (S,Aquamarine) >> {
    }
    class networkCreateResponse << (S,Aquamarine) >> {
        + Body types.Network

    }
    class networkInspectCompat << (S,Aquamarine) >> {
        + Body network.Inspect

    }
    class networkInspectResponse << (S,Aquamarine) >> {
        + Body entities.NetworkInspectReport

    }
    class networkListCompat << (S,Aquamarine) >> {
        + Body []network.Summary

    }
    class networkListLibpod << (S,Aquamarine) >> {
        + Body []types.Network

    }
    class networkNotFound << (S,Aquamarine) >> {
        + Body errorhandling.ErrorModel

    }
    class networkPruneResponse << (S,Aquamarine) >> {
        + Body []entities.NetworkPruneReport

    }
    class networkRmResponse << (S,Aquamarine) >> {
        + Body []entities.NetworkRmReport

    }
    class ok << (S,Aquamarine) >> {
        + Body <font color=blue>struct</font>{string}

    }
    class playKubeResponseLibpod << (S,Aquamarine) >> {
        + Body entities.PlayKubeReport

    }
    class podAlreadyStartedError << (S,Aquamarine) >> {
        + Body errorhandling.ErrorModel

    }
    class podAlreadyStoppedError << (S,Aquamarine) >> {
        + Body errorhandling.ErrorModel

    }
    class podInspectResponse << (S,Aquamarine) >> {
        + Body define.InspectPodData

    }
    class podKillResponse << (S,Aquamarine) >> {
        + Body entities.PodKillReport

    }
    class podNotFound << (S,Aquamarine) >> {
        + Body errorhandling.ErrorModel

    }
    class podPauseResponse << (S,Aquamarine) >> {
        + Body entities.PodPauseReport

    }
    class podPruneResponse << (S,Aquamarine) >> {
        + Body entities.PodPruneReport

    }
    class podRestartResponse << (S,Aquamarine) >> {
        + Body entities.PodRestartReport

    }
    class podRmResponse << (S,Aquamarine) >> {
        + Body entities.PodRmReport

    }
    class podStartResponse << (S,Aquamarine) >> {
        + Body entities.PodStartReport

    }
    class podStatsResponse << (S,Aquamarine) >> {
        + Body []entities.PodStatsReport

    }
    class podStopResponse << (S,Aquamarine) >> {
        + Body entities.PodStopReport

    }
    class podTopResponse << (S,Aquamarine) >> {
        + Body handlers.PodTopOKBody

    }
    class podUnpauseResponse << (S,Aquamarine) >> {
        + Body entities.PodUnpauseReport

    }
    class podsListResponse << (S,Aquamarine) >> {
        + Body []entities.ListPodsReport

    }
    class registrySearchResponse << (S,Aquamarine) >> {
        + Body <font color=blue>struct</font>{string, string, string, int, string, string, string}

    }
    class swagger.networkConnectRequest << (T, #FF7700) >>  {
    }
    class swagger.networkConnectRequestLibpod << (T, #FF7700) >>  {
    }
    class swagger.networkCreate << (T, #FF7700) >>  {
    }
    class swagger.networkDisconnectRequest << (T, #FF7700) >>  {
    }
    class swagger.networkUpdateRequestLibpod << (T, #FF7700) >>  {
    }
    class systemAuthResponse << (S,Aquamarine) >> {
        + Body entities.AuthReport

    }
    class systemCheckResponse << (S,Aquamarine) >> {
        + Body entities.SystemCheckReport

    }
    class systemDiskUsage << (S,Aquamarine) >> {
        + Body entities.SystemDfReport

    }
    class systemPruneResponse << (S,Aquamarine) >> {
        + Body entities.SystemPruneReport

    }
    class treeResponse << (S,Aquamarine) >> {
        + Body entities.ImageTreeReport

    }
    class versionResponse << (S,Aquamarine) >> {
        + Body entities.ComponentVersion

    }
    class volumeCreate << (S,Aquamarine) >> {
        + Driver string
        + DriverOpts <font color=blue>map</font>[string]string
        + Labels <font color=blue>map</font>[string]string
        + Name string

    }
    class volumeCreateResponse << (S,Aquamarine) >> {
        + Body entities.VolumeConfigResponse

    }
    class volumeInspect << (S,Aquamarine) >> {
        + Body volume.Volume

    }
    class volumeList << (S,Aquamarine) >> {
        + Body volume.ListResponse

    }
    class volumeListLibpod << (S,Aquamarine) >> {
        + Body []entities.VolumeConfigResponse

    }
    class volumeNotFound << (S,Aquamarine) >> {
        + Body errorhandling.ErrorModel

    }
    class volumePruneLibpod << (S,Aquamarine) >> {
        + Body []reports.PruneReport

    }
    class volumePruneResponse << (S,Aquamarine) >> {
        + Body volume.PruneReport

    }
    class "entities.NetworkConnectOptions" as entitiesNetworkConnectOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "entities.NetworkUpdateOptions" as entitiesNetworkUpdateOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "network.ConnectOptions" as networkConnectOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "network.CreateRequest" as networkCreateRequest {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "network.DisconnectOptions" as networkDisconnectOptions {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"container.UpdateConfig" *-- "extends""swagger.containerUpdateRequest"
"types.Network" *-- "extends""swagger.networkCreateLibpod"


namespace system {
    class CheckOptions << (S,Aquamarine) >> {
        + Quick *bool
        + Repair *bool
        + RepairLossy *bool
        + UnreferencedLayerMaximumAge *string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithQuick(value bool) *CheckOptions
        + GetQuick() bool
        + WithRepair(value bool) *CheckOptions
        + GetRepair() bool
        + WithRepairLossy(value bool) *CheckOptions
        + GetRepairLossy() bool
        + WithUnreferencedLayerMaximumAge(value string) *CheckOptions
        + GetUnreferencedLayerMaximumAge() string

    }
    class DiskOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class Event << (S,Aquamarine) >> {
        + ContainerExitCode *int
        + ID string
        + Image string
        + Name string
        + Network string
        + Status events.Status
        + Time int64
        + TimeNano int64
        + Type events.Type
        + HealthStatus string
        + Error string

        + ToJSONString() (string, error)

    }
    class EventsOptions << (S,Aquamarine) >> {
        + Filters <font color=blue>map</font>[string][]string
        + Since *string
        + Stream *bool
        + Until *string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithFilters(value <font color=blue>map</font>[string][]string) *EventsOptions
        + GetFilters() <font color=blue>map</font>[string][]string
        + WithSince(value string) *EventsOptions
        + GetSince() string
        + WithStream(value bool) *EventsOptions
        + GetStream() bool
        + WithUntil(value string) *EventsOptions
        + GetUntil() string

    }
    class InfoOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class PruneOptions << (S,Aquamarine) >> {
        + All *bool
        + Filters <font color=blue>map</font>[string][]string
        + Volumes *bool
        + External *bool
        + Build *bool

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithAll(value bool) *PruneOptions
        + GetAll() bool
        + WithFilters(value <font color=blue>map</font>[string][]string) *PruneOptions
        + GetFilters() <font color=blue>map</font>[string][]string
        + WithVolumes(value bool) *PruneOptions
        + GetVolumes() bool
        + WithExternal(value bool) *PruneOptions
        + GetExternal() bool
        + WithBuild(value bool) *PruneOptions
        + GetBuild() bool

    }
    class VersionOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class dfContainer << (S,Aquamarine) >> {
        + ContainerID() string
        + Image() string
        + Command() string
        + RWSize() string
        + Created() string

    }
    class dfImage << (S,Aquamarine) >> {
        + ImageID() string
        + Created() string
        + Size() string
        + SharedSize() string
        + UniqueSize() string

    }
    class dfSummary << (S,Aquamarine) >> {
        + Type string
        + Total int
        + Active int
        + RawSize int64
        + RawReclaimable int64

        + Size() string
        + Reclaimable() string
        + MarshalJSON() ([]byte, error)

    }
    class dfVolume << (S,Aquamarine) >> {
        + Size() string

    }
    interface halfCloser  {
    }
    interface halfReadCloser  {
        + CloseRead() error

    }
    class halfReadCloserWrapper << (S,Aquamarine) >> {
        + CloseRead() error

    }
    interface halfReadWriteCloser  {
    }
    interface halfWriteCloser  {
        + CloseWrite() error

    }
    class halfWriteCloserWrapper << (S,Aquamarine) >> {
        + CloseWrite() error

    }
    class infoReport << (S,Aquamarine) >> {
        + Client *define.Version

    }
    class nopCloseReader << (S,Aquamarine) >> {
        + CloseRead() error

    }
}
"events.Details" *-- "extends""system.Event"
"entities.SystemDfContainerReport" *-- "extends""system.dfContainer"
"entities.SystemDfImageReport" *-- "extends""system.dfImage"
"entities.SystemDfVolumeReport" *-- "extends""system.dfVolume"
"system.halfReadCloser" *-- "extends""system.halfCloser"
"system.halfWriteCloser" *-- "extends""system.halfCloser"
"io.ReadCloser" *-- "extends""system.halfReadCloserWrapper"
"system.halfWriteCloser" *-- "extends""system.halfReadWriteCloser"
"io.WriteCloser" *-- "extends""system.halfWriteCloserWrapper"
"define.Info" *-- "extends""system.infoReport"
"system.halfReadWriteCloser" *-- "extends""system.nopCloseReader"

"system.halfReadCloser" <|-- "implements""system.halfReadCloserWrapper"
"containers.CloseWriter" <|-- "implements""system.halfWriteCloserWrapper"
"system.halfWriteCloser" <|-- "implements""system.halfWriteCloserWrapper"
"system.halfReadCloser" <|-- "implements""system.nopCloseReader"

namespace terminal {
    class RawTtyFormatter << (S,Aquamarine) >> {
        + Format(entry *logrus.Entry) ([]byte, error)

    }
}


namespace trust {
    class AddPolicyEntriesInput << (S,Aquamarine) >> {
        + Scope string
        + Type string
        + PubKeyFiles []string

    }
    class Policy << (S,Aquamarine) >> {
        + Transport string
        + Name string
        + RepoName string
        + Keys []string
        + SignatureStore string
        + Type string
        + GPGId string

    }
    class genericPolicyContent << (S,Aquamarine) >> {
        + Default json.RawMessage
        + Transports genericTransportsContent

    }
    class policyContent << (S,Aquamarine) >> {
        + Default []repoContent
        + Transports transportsContent

    }
    class registryConfiguration << (S,Aquamarine) >> {
        + DefaultDocker *registryNamespace
        + Docker <font color=blue>map</font>[string]registryNamespace

    }
    class registryNamespace << (S,Aquamarine) >> {
        + Lookaside string
        + LookasideStaging string
        + SigStore string
        + SigStoreStaging string

    }
    class repoContent << (S,Aquamarine) >> {
        + Type string
        + KeyType string
        + KeyPath string
        + KeyPaths []string
        + KeyData string
        + SignedIdentity json.RawMessage

    }
    class trust.genericRepoMap << (T, #FF7700) >>  {
    }
    class trust.genericTransportsContent << (T, #FF7700) >>  {
    }
    class trust.gpgIDReader << (T, #FF7700) >>  {
    }
    class trust.repoMap << (T, #FF7700) >>  {
    }
    class trust.transportsContent << (T, #FF7700) >>  {
    }
    class "<font color=blue>map</font>[string]json.RawMessage" as fontcolorbluemapfontstringjsonRawMessage {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace tunnel {
    class ContainerEngine << (S,Aquamarine) >> {
        + ClientCtx context.Context

        + AutoUpdate(ctx context.Context, options entities.AutoUpdateOptions) ([]*entities.AutoUpdateReport, []error)
        + ContainerRunlabel(ctx context.Context, label string, image string, args []string, options entities.ContainerRunlabelOptions) error
        + ContainerExists(ctx context.Context, nameOrID string, options entities.ContainerExistsOptions) (*entities.BoolReport, error)
        + ContainerWait(ctx context.Context, namesOrIds []string, opts entities.WaitOptions) ([]entities.WaitReport, error)
        + ContainerPause(ctx context.Context, namesOrIds []string, options entities.PauseUnPauseOptions) ([]*entities.PauseUnpauseReport, error)
        + ContainerUnpause(ctx context.Context, namesOrIds []string, options entities.PauseUnPauseOptions) ([]*entities.PauseUnpauseReport, error)
        + ContainerStop(ctx context.Context, namesOrIds []string, opts entities.StopOptions) ([]*entities.StopReport, error)
        + ContainerKill(ctx context.Context, namesOrIds []string, opts entities.KillOptions) ([]*entities.KillReport, error)
        + ContainerRestart(ctx context.Context, namesOrIds []string, opts entities.RestartOptions) ([]*entities.RestartReport, error)
        + ContainerRm(ctx context.Context, namesOrIds []string, opts entities.RmOptions) ([]*reports.RmReport, error)
        + ContainerPrune(ctx context.Context, opts entities.ContainerPruneOptions) ([]*reports.PruneReport, error)
        + ContainerInspect(ctx context.Context, namesOrIds []string, opts entities.InspectOptions) ([]*entities.ContainerInspectReport, []error, error)
        + ContainerTop(ctx context.Context, opts entities.TopOptions) (*entities.StringSliceReport, error)
        + ContainerCommit(ctx context.Context, nameOrID string, opts entities.CommitOptions) (*entities.CommitReport, error)
        + ContainerExport(ctx context.Context, nameOrID string, options entities.ContainerExportOptions) error
        + ContainerCheckpoint(ctx context.Context, namesOrIds []string, opts entities.CheckpointOptions) ([]*entities.CheckpointReport, error)
        + ContainerRestore(ctx context.Context, namesOrIds []string, opts entities.RestoreOptions) ([]*entities.RestoreReport, error)
        + ContainerCreate(ctx context.Context, s *specgen.SpecGenerator) (*entities.ContainerCreateReport, error)
        + ContainerLogs(_ context.Context, nameOrIDs []string, opts entities.ContainerLogsOptions) error
        + ContainerAttach(ctx context.Context, nameOrID string, opts entities.AttachOptions) error
        + ContainerExec(ctx context.Context, nameOrID string, options entities.ExecOptions, streams define.AttachStreams) (int, error)
        + ContainerExecDetached(ctx context.Context, nameOrID string, options entities.ExecOptions) (string, error)
        + ContainerStart(ctx context.Context, namesOrIds []string, options entities.ContainerStartOptions) ([]*entities.ContainerStartReport, error)
        + ContainerList(ctx context.Context, opts entities.ContainerListOptions) ([]entities.ListContainer, error)
        + ContainerListExternal(ctx context.Context) ([]entities.ListContainer, error)
        + ContainerRun(ctx context.Context, opts entities.ContainerRunOptions) (*entities.ContainerRunReport, error)
        + Diff(ctx context.Context, namesOrIDs []string, opts entities.DiffOptions) (*entities.DiffReport, error)
        + ContainerCleanup(ctx context.Context, namesOrIds []string, options entities.ContainerCleanupOptions) ([]*entities.ContainerCleanupReport, error)
        + ContainerInit(ctx context.Context, namesOrIds []string, options entities.ContainerInitOptions) ([]*entities.ContainerInitReport, error)
        + ContainerMount(ctx context.Context, nameOrIDs []string, options entities.ContainerMountOptions) ([]*entities.ContainerMountReport, error)
        + ContainerUnmount(ctx context.Context, nameOrIDs []string, options entities.ContainerUnmountOptions) ([]*entities.ContainerUnmountReport, error)
        + Config(_ context.Context) (*config.Config, error)
        + ContainerPort(ctx context.Context, nameOrID string, options entities.ContainerPortOptions) ([]*entities.ContainerPortReport, error)
        + ContainerCopyFromArchive(ctx context.Context, nameOrID string, path string, reader io.Reader, options entities.CopyOptions) (entities.ContainerCopyFunc, error)
        + ContainerCopyToArchive(ctx context.Context, nameOrID string, path string, writer io.Writer) (entities.ContainerCopyFunc, error)
        + ContainerStat(ctx context.Context, nameOrID string, path string) (*entities.ContainerStatReport, error)
        + Shutdown(_ context.Context) 
        + ContainerStats(ctx context.Context, namesOrIds []string, options entities.ContainerStatsOptions) (<font color=blue>chan</font> entities.ContainerStatsReport, error)
        + ShouldRestart(_ context.Context, id string) (bool, error)
        + ContainerRename(ctx context.Context, nameOrID string, opts entities.ContainerRenameOptions) error
        + ContainerClone(ctx context.Context, ctrCloneOpts entities.ContainerCloneOptions) (*entities.ContainerCreateReport, error)
        + ContainerUpdate(ctx context.Context, updateOptions *entities.ContainerUpdateOptions) (string, error)
        + Events(ctx context.Context, opts entities.EventsOptions) error
        + HealthCheckRun(ctx context.Context, nameOrID string, options entities.HealthCheckOptions) (*define.HealthCheckResults, error)
        + GenerateSystemd(ctx context.Context, nameOrID string, opts entities.GenerateSystemdOptions) (*entities.GenerateSystemdReport, error)
        + GenerateKube(ctx context.Context, nameOrIDs []string, opts entities.GenerateKubeOptions) (*entities.GenerateKubeReport, error)
        + GenerateSpec(ctx context.Context, opts *entities.GenerateSpecOptions) (*entities.GenerateSpecReport, error)
        + PlayKube(ctx context.Context, body io.Reader, opts entities.PlayKubeOptions) (*entities.PlayKubeReport, error)
        + PlayKubeDown(ctx context.Context, body io.Reader, options entities.PlayKubeDownOptions) (*entities.PlayKubeReport, error)
        + KubeApply(ctx context.Context, body io.Reader, opts entities.ApplyOptions) error
        + NetworkUpdate(ctx context.Context, netName string, opts entities.NetworkUpdateOptions) error
        + NetworkList(ctx context.Context, opts entities.NetworkListOptions) ([]types.Network, error)
        + NetworkInspect(ctx context.Context, namesOrIds []string, opts entities.InspectOptions) ([]entities.NetworkInspectReport, []error, error)
        + NetworkReload(ctx context.Context, names []string, opts entities.NetworkReloadOptions) ([]*entities.NetworkReloadReport, error)
        + NetworkRm(ctx context.Context, namesOrIds []string, opts entities.NetworkRmOptions) ([]*entities.NetworkRmReport, error)
        + NetworkCreate(ctx context.Context, net types.Network, createOptions *types.NetworkCreateOptions) (*types.Network, error)
        + NetworkDisconnect(ctx context.Context, networkname string, opts entities.NetworkDisconnectOptions) error
        + NetworkConnect(ctx context.Context, networkname string, opts entities.NetworkConnectOptions) error
        + NetworkExists(ctx context.Context, networkname string) (*entities.BoolReport, error)
        + NetworkPrune(ctx context.Context, options entities.NetworkPruneOptions) ([]*entities.NetworkPruneReport, error)
        + PodExists(ctx context.Context, nameOrID string) (*entities.BoolReport, error)
        + PodKill(ctx context.Context, namesOrIds []string, opts entities.PodKillOptions) ([]*entities.PodKillReport, error)
        + PodLogs(ctx context.Context, nameOrIDs string, options entities.PodLogsOptions) error
        + PodPause(ctx context.Context, namesOrIds []string, options entities.PodPauseOptions) ([]*entities.PodPauseReport, error)
        + PodUnpause(ctx context.Context, namesOrIds []string, options entities.PodunpauseOptions) ([]*entities.PodUnpauseReport, error)
        + PodStop(ctx context.Context, namesOrIds []string, opts entities.PodStopOptions) ([]*entities.PodStopReport, error)
        + PodRestart(ctx context.Context, namesOrIds []string, options entities.PodRestartOptions) ([]*entities.PodRestartReport, error)
        + PodStart(ctx context.Context, namesOrIds []string, options entities.PodStartOptions) ([]*entities.PodStartReport, error)
        + PodRm(ctx context.Context, namesOrIds []string, opts entities.PodRmOptions) ([]*entities.PodRmReport, error)
        + PodPrune(ctx context.Context, opts entities.PodPruneOptions) ([]*entities.PodPruneReport, error)
        + PodCreate(ctx context.Context, specg entities.PodSpec) (*entities.PodCreateReport, error)
        + PodClone(ctx context.Context, podClone entities.PodCloneOptions) (*entities.PodCloneReport, error)
        + PodTop(ctx context.Context, opts entities.PodTopOptions) (*entities.StringSliceReport, error)
        + PodPs(ctx context.Context, opts entities.PodPSOptions) ([]*entities.ListPodsReport, error)
        + PodInspect(ctx context.Context, namesOrIDs []string, options entities.InspectOptions) ([]*entities.PodInspectReport, []error, error)
        + PodStats(ctx context.Context, namesOrIds []string, opts entities.PodStatsOptions) ([]*entities.PodStatsReport, error)
        + SecretCreate(ctx context.Context, name string, reader io.Reader, options entities.SecretCreateOptions) (*entities.SecretCreateReport, error)
        + SecretInspect(ctx context.Context, nameOrIDs []string, options entities.SecretInspectOptions) ([]*entities.SecretInfoReport, []error, error)
        + SecretList(ctx context.Context, opts entities.SecretListRequest) ([]*entities.SecretInfoReport, error)
        + SecretRm(ctx context.Context, nameOrIDs []string, options entities.SecretRmOptions) ([]*entities.SecretRmReport, error)
        + SecretExists(ctx context.Context, nameOrID string) (*entities.BoolReport, error)
        + Info(ctx context.Context) (*define.Info, error)
        + SetupRootless(_ context.Context, noMoveProcess bool, cgroupMode string) error
        + SystemPrune(ctx context.Context, opts entities.SystemPruneOptions) (*entities.SystemPruneReport, error)
        + SystemCheck(ctx context.Context, opts entities.SystemCheckOptions) (*entities.SystemCheckReport, error)
        + Migrate(ctx context.Context, options entities.SystemMigrateOptions) error
        + Renumber(ctx context.Context) error
        + Reset(ctx context.Context) error
        + SystemDf(ctx context.Context, options entities.SystemDfOptions) (*entities.SystemDfReport, error)
        + Unshare(ctx context.Context, args []string, options entities.SystemUnshareOptions) error
        + Version(ctx context.Context) (*entities.SystemVersionReport, error)
        + Locks(ctx context.Context) (*entities.LocksReport, error)
        + VolumeCreate(ctx context.Context, opts entities.VolumeCreateOptions) (*entities.IDOrNameResponse, error)
        + VolumeRm(ctx context.Context, namesOrIds []string, opts entities.VolumeRmOptions) ([]*entities.VolumeRmReport, error)
        + VolumeInspect(ctx context.Context, namesOrIds []string, opts entities.InspectOptions) ([]*entities.VolumeInspectReport, []error, error)
        + VolumePrune(ctx context.Context, opts entities.VolumePruneOptions) ([]*reports.PruneReport, error)
        + VolumeList(ctx context.Context, opts entities.VolumeListOptions) ([]*entities.VolumeListReport, error)
        + VolumeExists(ctx context.Context, nameOrID string) (*entities.BoolReport, error)
        + VolumeMounted(ctx context.Context, nameOrID string) (*entities.BoolReport, error)
        + VolumeMount(ctx context.Context, nameOrIDs []string) ([]*entities.VolumeMountReport, error)
        + VolumeUnmount(ctx context.Context, nameOrIDs []string) ([]*entities.VolumeUnmountReport, error)
        + VolumeReload(ctx context.Context) (*entities.VolumeReloadReport, error)

    }
    class FarmNode << (S,Aquamarine) >> {
        + NodeName string

    }
    class ImageEngine << (S,Aquamarine) >> {
        + ClientCtx context.Context

        + ArtifactInspect(ctx context.Context, name string, opts entities.ArtifactInspectOptions) (*entities.ArtifactInspectReport, error)
        + ArtifactList(ctx context.Context, opts entities.ArtifactListOptions) ([]*entities.ArtifactListReport, error)
        + ArtifactPull(ctx context.Context, name string, opts entities.ArtifactPullOptions) (*entities.ArtifactPullReport, error)
        + ArtifactRm(ctx context.Context, name string, opts entities.ArtifactRemoveOptions) (*entities.ArtifactRemoveReport, error)
        + ArtifactPush(ctx context.Context, name string, opts entities.ArtifactPushOptions) (*entities.ArtifactPushReport, error)
        + ArtifactAdd(ctx context.Context, name string, paths []string, opts *entities.ArtifactAddOptions) (*entities.ArtifactAddReport, error)
        + FarmNodeName(ctx context.Context) string
        + FarmNodeDriver(ctx context.Context) string
        + FarmNodeInspect(ctx context.Context) (*entities.FarmInspectReport, error)
        + Exists(_ context.Context, nameOrID string) (*entities.BoolReport, error)
        + Remove(ctx context.Context, imagesArg []string, opts entities.ImageRemoveOptions) (*entities.ImageRemoveReport, []error)
        + List(ctx context.Context, opts entities.ImageListOptions) ([]*entities.ImageSummary, error)
        + Mount(ctx context.Context, images []string, options entities.ImageMountOptions) ([]*entities.ImageMountReport, error)
        + Unmount(ctx context.Context, images []string, options entities.ImageUnmountOptions) ([]*entities.ImageUnmountReport, error)
        + History(ctx context.Context, nameOrID string, opts entities.ImageHistoryOptions) (*entities.ImageHistoryReport, error)
        + Prune(ctx context.Context, opts entities.ImagePruneOptions) ([]*reports.PruneReport, error)
        + Pull(ctx context.Context, rawImage string, opts entities.ImagePullOptions) (*entities.ImagePullReport, error)
        + Tag(ctx context.Context, nameOrID string, tags []string, opt entities.ImageTagOptions) error
        + Untag(ctx context.Context, nameOrID string, tags []string, opt entities.ImageUntagOptions) error
        + Inspect(ctx context.Context, namesOrIDs []string, opts entities.InspectOptions) ([]*entities.ImageInspectReport, []error, error)
        + Load(ctx context.Context, opts entities.ImageLoadOptions) (*entities.ImageLoadReport, error)
        + Import(ctx context.Context, opts entities.ImageImportOptions) (*entities.ImageImportReport, error)
        + Push(ctx context.Context, source string, destination string, opts entities.ImagePushOptions) (*entities.ImagePushReport, error)
        + Save(ctx context.Context, nameOrID string, tags []string, opts entities.ImageSaveOptions) error
        + Search(ctx context.Context, term string, opts entities.ImageSearchOptions) ([]entities.ImageSearchReport, error)
        + Config(_ context.Context) (*config.Config, error)
        + Build(_ context.Context, containerFiles []string, opts entities.BuildOptions) (*entities.BuildReport, error)
        + Tree(ctx context.Context, nameOrID string, opts entities.ImageTreeOptions) (*entities.ImageTreeReport, error)
        + Shutdown(_ context.Context) 
        + Sign(ctx context.Context, names []string, options entities.SignOptions) (*entities.SignReport, error)
        + Scp(ctx context.Context, src string, dst string, opts entities.ImageScpOptions) (*entities.ImageScpReport, error)
        + ManifestCreate(ctx context.Context, name string, images []string, opts entities.ManifestCreateOptions) (string, error)
        + ManifestExists(ctx context.Context, name string) (*entities.BoolReport, error)
        + ManifestInspect(ctx context.Context, name string, opts entities.ManifestInspectOptions) (*define.ManifestListData, error)
        + ManifestAdd(_ context.Context, name string, imageNames []string, opts entities.ManifestAddOptions) (string, error)
        + ManifestAddArtifact(_ context.Context, name string, files []string, opts entities.ManifestAddArtifactOptions) (string, error)
        + ManifestAnnotate(ctx context.Context, name string, images string, opts entities.ManifestAnnotateOptions) (string, error)
        + ManifestRemoveDigest(ctx context.Context, name string, image string) (string, error)
        + ManifestRm(ctx context.Context, names []string, opts entities.ImageRemoveOptions) (*entities.ImageRemoveReport, []error)
        + ManifestPush(ctx context.Context, name string, destination string, opts entities.ImagePushOptions) (string, error)
        + ManifestListClear(ctx context.Context, name string) (string, error)
        + ShowTrust(ctx context.Context, args []string, options entities.ShowTrustOptions) (*entities.ShowTrustReport, error)
        + SetTrust(ctx context.Context, args []string, options entities.SetTrustOptions) error

    }
    class SystemEngine << (S,Aquamarine) >> {
        + ClientCtx context.Context

    }
    class TestingEngine << (S,Aquamarine) >> {
        + ClientCtx context.Context

        + CreateStorageLayer(ctx context.Context, opts entities.CreateStorageLayerOptions) (*entities.CreateStorageLayerReport, error)
        + CreateLayer(ctx context.Context, opts entities.CreateLayerOptions) (*entities.CreateLayerReport, error)
        + CreateLayerData(ctx context.Context, opts entities.CreateLayerDataOptions) (*entities.CreateLayerDataReport, error)
        + ModifyLayer(ctx context.Context, opts entities.ModifyLayerOptions) (*entities.ModifyLayerReport, error)
        + PopulateLayer(ctx context.Context, opts entities.PopulateLayerOptions) (*entities.PopulateLayerReport, error)
        + RemoveStorageLayer(ctx context.Context, opts entities.RemoveStorageLayerOptions) (*entities.RemoveStorageLayerReport, error)
        + CreateImage(ctx context.Context, opts entities.CreateImageOptions) (*entities.CreateImageReport, error)
        + CreateImageData(ctx context.Context, opts entities.CreateImageDataOptions) (*entities.CreateImageDataReport, error)
        + RemoveLayer(ctx context.Context, opts entities.RemoveLayerOptions) (*entities.RemoveLayerReport, error)
        + RemoveImage(ctx context.Context, opts entities.RemoveImageOptions) (*entities.RemoveImageReport, error)
        + RemoveContainer(ctx context.Context, opts entities.RemoveContainerOptions) (*entities.RemoveContainerReport, error)
        + CreateContainer(ctx context.Context, opts entities.CreateContainerOptions) (*entities.CreateContainerReport, error)
        + CreateContainerData(ctx context.Context, opts entities.CreateContainerDataOptions) (*entities.CreateContainerDataReport, error)
        + RemoveLayerData(ctx context.Context, opts entities.RemoveLayerDataOptions) (*entities.RemoveLayerDataReport, error)
        + RemoveImageData(ctx context.Context, opts entities.RemoveImageDataOptions) (*entities.RemoveImageDataReport, error)
        + RemoveContainerData(ctx context.Context, opts entities.RemoveContainerDataOptions) (*entities.RemoveContainerDataReport, error)
        + ModifyLayerData(ctx context.Context, opts entities.ModifyLayerDataOptions) (*entities.ModifyLayerDataReport, error)
        + ModifyImageData(ctx context.Context, opts entities.ModifyImageDataOptions) (*entities.ModifyImageDataReport, error)
        + ModifyContainerData(ctx context.Context, opts entities.ModifyContainerDataOptions) (*entities.ModifyContainerDataReport, error)

    }
}
"tunnel.FarmNode" *-- "extends""tunnel.ImageEngine"

"entities.ContainerEngine" <|-- "implements""tunnel.ContainerEngine"
"entities.ImageEngine" <|-- "implements""tunnel.ImageEngine"
"entities.TestingEngine" <|-- "implements""tunnel.TestingEngine"

namespace types {
    class AddOptions << (S,Aquamarine) >> {
        + Annotations <font color=blue>map</font>[string]string
        + ArtifactType string

    }
    class AuthConfig << (S,Aquamarine) >> {
        + Username string
        + Password string
        + Auth string
        + Email string
        + ServerAddress string
        + IdentityToken string
        + RegistryToken string

    }
    class AuthReport << (S,Aquamarine) >> {
        + IdentityToken string
        + Status string

    }
    class BuildOptions << (S,Aquamarine) >> {
        + ContainerFiles []string
        + LogFileToClose *os.File
        + TmpDirToClose string

    }
    class BuildReport << (S,Aquamarine) >> {
        + ID string
        + SaveFormat string

    }
    class CheckpointReport << (S,Aquamarine) >> {
        + Err error
        + Id string
        + RawInput string
        + RuntimeDuration int64
        + CRIUStatistics *define.CRIUCheckpointRestoreStatistics

    }
    class ComponentVersion << (S,Aquamarine) >> {
        + Name string
        + Version string
        + Details <font color=blue>map</font>[string]string

    }
    class ContainerCreateResponse << (S,Aquamarine) >> {
        + ID string
        + Warnings []string

    }
    class ContainerStatReport << (S,Aquamarine) >> {
    }
    class ContainerStatsReport << (S,Aquamarine) >> {
        + Error error
        + Stats []define.ContainerStats

    }
    class ContainerUpdateOptions << (S,Aquamarine) >> {
        + NameOrID string
        + Specgen *specgen.SpecGenerator
        + Resources *specs.LinuxResources
        + DevicesLimits *define.UpdateContainerDevicesLimits
        + ChangedHealthCheckConfiguration *define.UpdateHealthCheckConfig
        + RestartPolicy *string
        + RestartRetries *uint

        + ProcessSpecgen() 

    }
    class Event << (S,Aquamarine) >> {
        + HealthStatus string

    }
    class FarmBuildOptions << (S,Aquamarine) >> {
        + Cleanup bool
        + Authfile string
        + SkipTLSVerify *bool

    }
    class FarmInspectReport << (S,Aquamarine) >> {
        + NativePlatforms []string
        + EmulatedPlatforms []string
        + OS string
        + Arch string
        + Variant string

    }
    class GenerateKubeReport << (S,Aquamarine) >> {
        + Reader io.Reader

    }
    class GenerateSpecReport << (S,Aquamarine) >> {
        + Data []byte

    }
    class GenerateSystemdReport << (S,Aquamarine) >> {
        + Units <font color=blue>map</font>[string]string

    }
    class GetArtifactOptions << (S,Aquamarine) >> {
    }
    class HistoryResponse << (S,Aquamarine) >> {
        + ID string
        + Created int64
        + CreatedBy string
        + Tags []string
        + Size int64
        + Comment string

    }
    class ImageHistoryLayer << (S,Aquamarine) >> {
        + ID string
        + Created time.Time
        + CreatedBy string
        + Tags []string
        + Size int64
        + Comment string

    }
    class ImageHistoryReport << (S,Aquamarine) >> {
        + Layers []ImageHistoryLayer

    }
    class ImageImportReport << (S,Aquamarine) >> {
        + Id string

    }
    class ImageInspectReport << (S,Aquamarine) >> {
    }
    class ImageLoadReport << (S,Aquamarine) >> {
        + Names []string

    }
    class ImageMountReport << (S,Aquamarine) >> {
        + Id string
        + Name string
        + Repositories []string
        + Path string

    }
    class ImagePullReport << (S,Aquamarine) >> {
        + Stream string
        + Error string
        + Images []string
        + ID string

    }
    class ImagePushStream << (S,Aquamarine) >> {
        + ManifestDigest string
        + Stream string
        + Error string

    }
    class ImageRemoveReport << (S,Aquamarine) >> {
        + Deleted []string
        + Untagged []string
        + ExitCode int

    }
    class ImageSearchReport << (S,Aquamarine) >> {
        + Index string
        + Name string
        + Description string
        + Stars int
        + Official string
        + Automated string
        + Tag string

    }
    class ImageSummary << (S,Aquamarine) >> {
        + ID string
        + ParentId string
        + RepoTags []string
        + RepoDigests []string
        + Created int64
        + Size int64
        + SharedSize int
        + VirtualSize int64
        + Labels <font color=blue>map</font>[string]string
        + Containers int
        + ReadOnly bool
        + Dangling bool
        + Arch string
        + Digest string
        + History []string
        + IsManifestList *bool
        + Names []string
        + Os string

        + Id() string
        + IsReadOnly() bool
        + IsDangling() bool

    }
    class ImageTreeReport << (S,Aquamarine) >> {
        + Tree string

    }
    class ImageUnmountReport << (S,Aquamarine) >> {
        + Err error
        + Id string

    }
    class LibpodImagesRemoveReport << (S,Aquamarine) >> {
        + Errors []string

    }
    class ListContainer << (S,Aquamarine) >> {
        + AutoRemove bool
        + Command []string
        + Created time.Time
        + CreatedAt string
        + CIDFile string
        + Exited bool
        + ExitedAt int64
        + ExitCode int32
        + ExposedPorts <font color=blue>map</font>[uint16][]string
        + ID string
        + Image string
        + ImageID string
        + IsInfra bool
        + Labels <font color=blue>map</font>[string]string
        + Mounts []string
        + Names []string
        + Namespaces ListContainerNamespaces
        + Networks []string
        + Pid int
        + Pod string
        + PodName string
        + Ports []types.PortMapping
        + Restarts uint
        + Size *define.ContainerSize
        + StartedAt int64
        + State string
        + Status string

        + CGROUPNS() string
        + IPC() string
        + MNT() string
        + NET() string
        + PIDNS() string
        + USERNS() string
        + UTS() string

    }
    class ListContainerNamespaces << (S,Aquamarine) >> {
        + MNT string
        + Cgroup string
        + IPC string
        + NET string
        + PIDNS string
        + UTS string
        + User string

    }
    class ListPodContainer << (S,Aquamarine) >> {
        + Id string
        + Names string
        + Status string
        + RestartCount uint

    }
    class ListPodsReport << (S,Aquamarine) >> {
        + Cgroup string
        + Containers []*ListPodContainer
        + Created time.Time
        + Id string
        + InfraId string
        + Name string
        + Namespace string
        + Networks []string
        + Status string
        + Labels <font color=blue>map</font>[string]string

    }
    class ListRegistriesReport << (S,Aquamarine) >> {
        + Registries []string

    }
    class LocksReport << (S,Aquamarine) >> {
        + LockConflicts <font color=blue>map</font>[uint32][]string
        + LocksHeld []uint32

    }
    class ManifestModifyReport << (S,Aquamarine) >> {
        + ID string
        + Images []string
        + Files []string
        + Errors []error

    }
    class ManifestPushReport << (S,Aquamarine) >> {
        + ID string
        + Stream string
        + Error string

    }
    class ManifestRemoveReport << (S,Aquamarine) >> {
        + Deleted []string
        + Untagged []string
        + Errors []string
        + ExitCode int

    }
    class NetworkConnectOptions << (S,Aquamarine) >> {
        + Container string

    }
    class NetworkContainerInfo << (S,Aquamarine) >> {
        + Name string
        + Interfaces <font color=blue>map</font>[string]types.NetInterface

    }
    class NetworkCreateReport << (S,Aquamarine) >> {
        + Name string

    }
    class NetworkInspectReport << (S,Aquamarine) >> {
        + Containers <font color=blue>map</font>[string]NetworkContainerInfo

    }
    class NetworkPruneReport << (S,Aquamarine) >> {
        + Name string
        + Error error

    }
    class NetworkReloadReport << (S,Aquamarine) >> {
        + Id string
        + Err error

    }
    class NetworkRmReport << (S,Aquamarine) >> {
        + Name string
        + Err error

    }
    class PlayKubePod << (S,Aquamarine) >> {
        + ID string
        + Containers []string
        + InitContainers []string
        + Logs []string
        + ContainerErrors []string

    }
    class PlayKubeReport << (S,Aquamarine) >> {
        + Pods []PlayKubePod
        + Volumes []PlayKubeVolume
        + Secrets []PlaySecret
        + ServiceContainerID string
        + ExitCode *int32

    }
    class PlayKubeTeardown << (S,Aquamarine) >> {
        + StopReport []*PodStopReport
        + RmReport []*PodRmReport
        + VolumeRmReport []*VolumeRmReport
        + SecretRmReport []*SecretRmReport

    }
    class PlayKubeVolume << (S,Aquamarine) >> {
        + Name string

    }
    class PlaySecret << (S,Aquamarine) >> {
        + CreateReport *SecretCreateReport

    }
    class PodCloneReport << (S,Aquamarine) >> {
        + Id string

    }
    class PodCreateReport << (S,Aquamarine) >> {
        + Id string

    }
    class PodInspectReport << (S,Aquamarine) >> {
    }
    class PodKillReport << (S,Aquamarine) >> {
        + Errs []error
        + Id string

    }
    class PodPauseReport << (S,Aquamarine) >> {
        + Errs []error
        + Id string

    }
    class PodPruneReport << (S,Aquamarine) >> {
        + Err error
        + Id string

    }
    class PodRestartReport << (S,Aquamarine) >> {
        + Errs []error
        + Id string

    }
    class PodRmReport << (S,Aquamarine) >> {
        + RemovedCtrs <font color=blue>map</font>[string]error
        + Err error
        + Id string

    }
    class PodSpec << (S,Aquamarine) >> {
        + PodSpecGen specgen.PodSpecGenerator

    }
    class PodStartReport << (S,Aquamarine) >> {
        + Errs []error
        + Id string
        + RawInput string

    }
    class PodStatsReport << (S,Aquamarine) >> {
        + CPU string
        + MemUsage string
        + MemUsageBytes string
        + Mem string
        + NetIO string
        + BlockIO string
        + PIDS string
        + Pod string
        + CID string
        + Name string

    }
    class PodStopReport << (S,Aquamarine) >> {
        + Errs []error
        + Id string
        + RawInput string

    }
    class PodUnpauseReport << (S,Aquamarine) >> {
        + Errs []error
        + Id string

    }
    class RestoreReport << (S,Aquamarine) >> {
        + Err error
        + Id string
        + RawInput string
        + RuntimeDuration int64
        + CRIUStatistics *define.CRIUCheckpointRestoreStatistics

    }
    class SecretCreateReport << (S,Aquamarine) >> {
        + ID string

    }
    class SecretDriverSpec << (S,Aquamarine) >> {
        + Name string
        + Options <font color=blue>map</font>[string]string

    }
    class SecretInfoReport << (S,Aquamarine) >> {
        + ID string
        + CreatedAt time.Time
        + UpdatedAt time.Time
        + Spec SecretSpec
        + SecretData string

    }
    class SecretInfoReportCompat << (S,Aquamarine) >> {
        + Version SecretVersion

    }
    class SecretListReport << (S,Aquamarine) >> {
        + ID string
        + Name string
        + Driver string
        + CreatedAt string
        + UpdatedAt string

    }
    class SecretRmReport << (S,Aquamarine) >> {
        + ID string
        + Err error

    }
    class SecretSpec << (S,Aquamarine) >> {
        + Name string
        + Driver SecretDriverSpec
        + Labels <font color=blue>map</font>[string]string

    }
    class SecretVersion << (S,Aquamarine) >> {
        + Index int

    }
    class ServiceOptions << (S,Aquamarine) >> {
        + CorsHeaders string
        + PProfAddr string
        + Timeout time.Duration
        + URI string

    }
    class ShowTrustReport << (S,Aquamarine) >> {
        + Raw []byte
        + SystemRegistriesDirPath string
        + JSONOutput []byte
        + Policies []*trust.Policy

    }
    class SystemCheckOptions << (S,Aquamarine) >> {
        + Quick bool
        + Repair bool
        + RepairLossy bool
        + UnreferencedLayerMaximumAge *time.Duration

    }
    class SystemCheckReport << (S,Aquamarine) >> {
        + Errors bool
        + Layers <font color=blue>map</font>[string][]string
        + ROLayers <font color=blue>map</font>[string][]string
        + RemovedLayers []string
        + Images <font color=blue>map</font>[string][]string
        + ROImages <font color=blue>map</font>[string][]string
        + RemovedImages <font color=blue>map</font>[string][]string
        + Containers <font color=blue>map</font>[string][]string
        + RemovedContainers <font color=blue>map</font>[string]string

    }
    class SystemComponentVersion << (S,Aquamarine) >> {
    }
    class SystemDfContainerReport << (S,Aquamarine) >> {
        + ContainerID string
        + Image string
        + Command []string
        + LocalVolumes int
        + Size int64
        + RWSize int64
        + Created time.Time
        + Status string
        + Names string

    }
    class SystemDfImageReport << (S,Aquamarine) >> {
        + Repository string
        + Tag string
        + ImageID string
        + Created time.Time
        + Size int64
        + SharedSize int64
        + UniqueSize int64
        + Containers int

    }
    class SystemDfOptions << (S,Aquamarine) >> {
        + Format string
        + Verbose bool

    }
    class SystemDfReport << (S,Aquamarine) >> {
        + ImagesSize int64
        + Images []*SystemDfImageReport
        + Containers []*SystemDfContainerReport
        + Volumes []*SystemDfVolumeReport

    }
    class SystemDfVolumeReport << (S,Aquamarine) >> {
        + VolumeName string
        + Links int
        + Size int64
        + ReclaimableSize int64

    }
    class SystemMigrateOptions << (S,Aquamarine) >> {
        + NewRuntime string

    }
    class SystemPruneOptions << (S,Aquamarine) >> {
        + All bool
        + Volume bool
        + Filters <font color=blue>map</font>[string][]string
        + External bool
        + Build bool

    }
    class SystemPruneReport << (S,Aquamarine) >> {
        + PodPruneReport []*PodPruneReport
        + ContainerPruneReports []*reports.PruneReport
        + ImagePruneReports []*reports.PruneReport
        + NetworkPruneReports []*NetworkPruneReport
        + VolumePruneReports []*reports.PruneReport
        + ReclaimedSpace uint64

    }
    class SystemUnshareOptions << (S,Aquamarine) >> {
        + RootlessNetNS bool

    }
    class SystemVersionReport << (S,Aquamarine) >> {
        + Client *define.Version
        + Server *define.Version

    }
    class Version << (S,Aquamarine) >> {
        + Platform <font color=blue>struct</font>{string}
        + Components []ComponentVersion
        + Version string
        + APIVersion string
        + MinAPIVersion string
        + GitCommit string
        + GoVersion string
        + Os string
        + Arch string
        + KernelVersion string
        + Experimental bool
        + BuildTime string

    }
    class VolumeConfigResponse << (S,Aquamarine) >> {
    }
    class VolumeCreateOptions << (S,Aquamarine) >> {
        + Name string
        + Driver string
        + Label <font color=blue>map</font>[string]string
        + Labels <font color=blue>map</font>[string]string
        + Options <font color=blue>map</font>[string]string
        + IgnoreIfExists bool

    }
    class VolumeInspectReport << (S,Aquamarine) >> {
    }
    class VolumeListReport << (S,Aquamarine) >> {
    }
    class VolumeMountReport << (S,Aquamarine) >> {
        + Err error
        + Id string
        + Name string
        + Path string

    }
    class VolumeReloadReport << (S,Aquamarine) >> {
    }
    class VolumeRmReport << (S,Aquamarine) >> {
        + Err error
        + Id string

    }
    class VolumeUnmountReport << (S,Aquamarine) >> {
        + Err error
        + Id string

    }
    class types.APIContextKey << (T, #FF7700) >>  {
    }
    class types.ContainerCopyFunc << (T, #FF7700) >>  {
    }
    class types.KubePlayReport << (T, #FF7700) >>  {
    }
    class types.UID << (T, #FF7700) >>  {
    }
}
"define.BuildOptions" *-- "extends""types.BuildOptions"
"types.FarmBuildOptions" *-- "extends""types.BuildOptions"
"define.FileInfo" *-- "extends""types.ContainerStatReport"
"events.Message" *-- "extends""types.Event"
"inspect.ImageData" *-- "extends""types.ImageInspectReport"
"entities.ImageRemoveReport" *-- "extends""types.LibpodImagesRemoveReport"
"types.PerNetworkOptions" *-- "extends""types.NetworkConnectOptions"
"types.Network" *-- "extends""types.NetworkInspectReport"
"types.PlayKubeTeardown" *-- "extends""types.PlayKubeReport"
"define.InspectPodData" *-- "extends""types.PodInspectReport"
"types.SecretInfoReport" *-- "extends""types.SecretInfoReportCompat"
"types.Version" *-- "extends""types.SystemComponentVersion"
"define.InspectVolumeData" *-- "extends""types.VolumeConfigResponse"
"types.VolumeConfigResponse" *-- "extends""types.VolumeInspectReport"
"types.VolumeConfigResponse" *-- "extends""types.VolumeListReport"
"define.VolumeReload" *-- "extends""types.VolumeReloadReport"

"entities.Identifier" <|-- "implements""types.ImageSummary"

namespace util {
    class defaultMountOptions << (S,Aquamarine) >> {
    }
    class idMapFlags << (S,Aquamarine) >> {
        + Extends bool
        + UserMap bool
        + GroupMap bool

    }
    class tomlConfig << (S,Aquamarine) >> {
        + Storage <font color=blue>struct</font>{string, string, string, <font color=blue>struct</font>{tomlOptionsConfig}}

    }
    class tomlOptionsConfig << (S,Aquamarine) >> {
        + MountProgram string

    }
    class util.getDefaultMountOptionsFn << (T, #FF7700) >>  {
    }
}


namespace utils {
    class ExitMatcher << (S,Aquamarine) >> {
        + ExpectedExitCode int
        + ExitCode int
        + ExpectedStderr string
        + ExpectedStderrRegex string

        + Match(actual <font color=blue>interface</font>{}) (bool, error)
        + FailureMessage(_ <font color=blue>interface</font>{}) string
        + NegatedFailureMessage(_ <font color=blue>interface</font>{}) string
        + MatchMayChangeInTheFuture(actual <font color=blue>interface</font>{}) bool

    }
    class HostOS << (S,Aquamarine) >> {
        + Distribution string
        + Version string
        + Arch string

    }
    class NetworkBackend << (S,Aquamarine) >> {
        + ToString() string

    }
    class OutputErrors << (S,Aquamarine) >> {
        + PrintErrors() error

    }
    class PodmanExecOptions << (S,Aquamarine) >> {
        + UID uint32
        + CWD string
        + Env []string
        + NoEvents bool
        + NoCache bool
        + Wrapper []string
        + ExtraFiles []*os.File

    }
    class PodmanSession << (S,Aquamarine) >> {
        + OutputToString() string
        + OutputToStringArray() []string
        + ErrorToString() string
        + ErrorToStringArray() []string
        + GrepString(term string) (bool, []string)
        + ErrorGrepString(term string) (bool, []string)
        + LineInOutputStartsWith(term string) bool
        + LineInOutputContains(term string) bool
        + LineInOutputContainsTag(repo string, tag string) bool
        + IsJSONOutputValid() bool
        + WaitWithDefaultTimeout() 
        + WaitWithTimeout(timeout int) 

    }
    class PodmanTest << (S,Aquamarine) >> {
        + ImageCacheDir string
        + ImageCacheFS string
        + NetworkBackend NetworkBackend
        + DatabaseBackend string
        + PodmanBinary string
        + PodmanMakeOptions <font color=blue>func</font>([]string, PodmanExecOptions) []string
        + RemoteCommand *exec.Cmd
        + RemotePodmanBinary string
        + RemoteSession *os.Process
        + RemoteSocket string
        + RemoteSocketLock string
        + RemoteTest bool
        + TempDir string

        + MakeOptions(args []string, options PodmanExecOptions) []string
        + PodmanExecBaseWithOptions(args []string, options PodmanExecOptions) *PodmanSession
        + WaitForContainer() bool
        + NumberOfContainersRunning() int
        + NumberOfContainers() int
        + NumberOfPods() int
        + GetContainerStatus() string
        + WaitContainerReady(id string, expStr string, timeout int, step int) bool

    }
    interface PodmanTestCommon  {
        + MakeOptions(args []string, options PodmanExecOptions) []string
        + WaitForContainer() bool
        + WaitContainerReady(id string, expStr string, timeout int, step int) bool

    }
    class ValidJSONMatcher << (S,Aquamarine) >> {
        + Match(actual <font color=blue>interface</font>{}) (bool, error)
        + FailureMessage(actual <font color=blue>interface</font>{}) string
        + NegatedFailureMessage(actual <font color=blue>interface</font>{}) string

    }
    class exitCleanlyMatcher << (S,Aquamarine) >> {
        + Match(actual <font color=blue>interface</font>{}) (bool, error)
        + FailureMessage(_ <font color=blue>interface</font>{}) string
        + NegatedFailureMessage(_ <font color=blue>interface</font>{}) string

    }
    interface podmanSession  {
        + ExitCode() int
        + ErrorToString() string

    }
    class pullResult << (S,Aquamarine) >> {
    }
    class utils.NetworkBackend << (T, #FF7700) >>  {
    }
    class utils.OutputErrors << (T, #FF7700) >>  {
    }
    class utils.containerWaitFn << (T, #FF7700) >>  {
    }
    class waitQueryDocker << (S,Aquamarine) >> {
        + Condition string

    }
    class waitQueryLibpod << (S,Aquamarine) >> {
        + Interval string
        + Conditions []string

    }
    class "<font color=blue>func</font>(...define.ContainerStatus) (int32, error)" as fontcolorbluefuncfontdefineContainerStatusint32error {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"types.GomegaMatcher" *-- "extends""utils.ExitMatcher"
"utils.Session" *-- "extends""utils.PodmanSession"
"types.GomegaMatcher" *-- "extends""utils.ValidJSONMatcher"

"utils.PodmanTestCommon" <|-- "implements""utils.PodmanTest"

namespace v1 {
    class APIGroup << (S,Aquamarine) >> {
        + Name string
        + Versions []GroupVersionForDiscovery
        + PreferredVersion GroupVersionForDiscovery
        + ServerAddressByClientCIDRs []ServerAddressByClientCIDR

    }
    class APIGroupList << (S,Aquamarine) >> {
        + Groups []APIGroup

    }
    class APIResource << (S,Aquamarine) >> {
        + Name string
        + SingularName string
        + Namespaced bool
        + Group string
        + Version string
        + Kind string
        + Verbs Verbs
        + ShortNames []string
        + Categories []string
        + StorageVersionHash string

    }
    class APIResourceList << (S,Aquamarine) >> {
        + GroupVersion string
        + APIResources []APIResource

    }
    class APIVersions << (S,Aquamarine) >> {
        + Versions []string
        + ServerAddressByClientCIDRs []ServerAddressByClientCIDR

        + String() string
        + GoString() string

    }
    class Affinity << (S,Aquamarine) >> {
        + NodeAffinity *NodeAffinity
        + PodAffinity *PodAffinity
        + PodAntiAffinity *PodAntiAffinity

    }
    class ApplyOptions << (S,Aquamarine) >> {
        + DryRun []string
        + Force bool
        + FieldManager string

        + ToPatchOptions() PatchOptions

    }
    class AuthInfo << (S,Aquamarine) >> {
        + ClientCertificate string
        + ClientCertificateData []byte
        + ClientKey string
        + ClientKeyData []byte
        + Token string
        + TokenFile string
        + Impersonate string
        + ImpersonateUID string
        + ImpersonateGroups []string
        + ImpersonateUserExtra <font color=blue>map</font>[string][]string
        + Username string
        + Password string
        + AuthProvider *AuthProviderConfig
        + Exec *ExecConfig
        + Extensions []NamedExtension

    }
    class AuthProviderConfig << (S,Aquamarine) >> {
        + Name string
        + Config <font color=blue>map</font>[string]string

    }
    class Capabilities << (S,Aquamarine) >> {
        + Add []Capability
        + Drop []Capability

    }
    class ClientIPConfig << (S,Aquamarine) >> {
        + TimeoutSeconds *int32

    }
    class Cluster << (S,Aquamarine) >> {
        + Server string
        + TLSServerName string
        + InsecureSkipTLSVerify bool
        + CertificateAuthority string
        + CertificateAuthorityData []byte
        + ProxyURL string
        + Extensions []NamedExtension

    }
    class ComponentCondition << (S,Aquamarine) >> {
        + Type ComponentConditionType
        + Status ConditionStatus
        + Message string
        + Error string

    }
    class ComponentStatus << (S,Aquamarine) >> {
        + Conditions []ComponentCondition

    }
    class ComponentStatusList << (S,Aquamarine) >> {
        + Items []ComponentStatus

    }
    class Condition << (S,Aquamarine) >> {
        + Type string
        + Status ConditionStatus
        + ObservedGeneration int64
        + LastTransitionTime Time
        + Reason string
        + Message string

    }
    class Config << (S,Aquamarine) >> {
        + Kind string
        + APIVersion string
        + Preferences Preferences
        + Clusters []NamedCluster
        + AuthInfos []NamedAuthInfo
        + Contexts []NamedContext
        + CurrentContext string
        + Extensions []NamedExtension

    }
    class ConfigMap << (S,Aquamarine) >> {
        + Immutable *bool
        + Data <font color=blue>map</font>[string]string
        + BinaryData <font color=blue>map</font>[string][]byte

    }
    class ConfigMapEnvSource << (S,Aquamarine) >> {
        + Optional *bool

    }
    class ConfigMapKeySelector << (S,Aquamarine) >> {
        + Key string
        + Optional *bool

    }
    class ConfigMapList << (S,Aquamarine) >> {
        + Items []ConfigMap

    }
    class ConfigMapNodeConfigSource << (S,Aquamarine) >> {
        + Namespace string
        + Name string
        + UID types.UID
        + ResourceVersion string
        + KubeletConfigKey string

    }
    class ConfigMapProjection << (S,Aquamarine) >> {
        + Items []KeyToPath
        + Optional *bool

    }
    class ConfigMapVolumeSource << (S,Aquamarine) >> {
        + Items []KeyToPath
        + DefaultMode *int32
        + Optional *bool

    }
    class Container << (S,Aquamarine) >> {
        + Name string
        + Image string
        + Command []string
        + Args []string
        + WorkingDir string
        + Ports []ContainerPort
        + EnvFrom []EnvFromSource
        + Env []EnvVar
        + Resources ResourceRequirements
        + VolumeMounts []VolumeMount
        + VolumeDevices []VolumeDevice
        + LivenessProbe *Probe
        + ReadinessProbe *Probe
        + StartupProbe *Probe
        + Lifecycle *Lifecycle
        + TerminationMessagePath string
        + TerminationMessagePolicy TerminationMessagePolicy
        + ImagePullPolicy PullPolicy
        + SecurityContext *SecurityContext
        + Stdin bool
        + StdinOnce bool
        + TTY bool

    }
    class ContainerImage << (S,Aquamarine) >> {
        + Names []string
        + SizeBytes int64

    }
    class ContainerPort << (S,Aquamarine) >> {
        + Name string
        + HostPort int32
        + ContainerPort int32
        + Protocol Protocol
        + HostIP string

    }
    class ContainerState << (S,Aquamarine) >> {
        + Waiting *ContainerStateWaiting
        + Running *ContainerStateRunning
        + Terminated *ContainerStateTerminated

    }
    class ContainerStateRunning << (S,Aquamarine) >> {
        + StartedAt v1.Time

    }
    class ContainerStateTerminated << (S,Aquamarine) >> {
        + ExitCode int32
        + Signal int32
        + Reason string
        + Message string
        + StartedAt v1.Time
        + FinishedAt v1.Time
        + ContainerID string

    }
    class ContainerStateWaiting << (S,Aquamarine) >> {
        + Reason string
        + Message string

    }
    class ContainerStatus << (S,Aquamarine) >> {
        + Name string
        + State ContainerState
        + LastTerminationState ContainerState
        + Ready bool
        + RestartCount int32
        + Image string
        + ImageID string
        + ContainerID string
        + Started *bool

    }
    class Context << (S,Aquamarine) >> {
        + Cluster string
        + AuthInfo string
        + Namespace string
        + Extensions []NamedExtension

    }
    class CreateOptions << (S,Aquamarine) >> {
        + DryRun []string
        + FieldManager string

    }
    class DaemonSet << (S,Aquamarine) >> {
        + Spec DaemonSetSpec
        + Status DaemonSetStatus
        + Spec DaemonSetSpec
        + Status DaemonSetStatus

    }
    class DaemonSetCondition << (S,Aquamarine) >> {
        + Type DaemonSetConditionType
        + Status v1.ConditionStatus
        + LastTransitionTime v1.Time
        + Reason string
        + Message string
        + Type DaemonSetConditionType
        + Status ConditionStatus
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

    }
    class DaemonSetList << (S,Aquamarine) >> {
        + Items []DaemonSet
        + Items []DaemonSet

    }
    class DaemonSetSpec << (S,Aquamarine) >> {
        + Selector *v1.LabelSelector
        + Template v1.PodTemplateSpec
        + UpdateStrategy DaemonSetUpdateStrategy
        + MinReadySeconds int32
        + RevisionHistoryLimit *int32
        + Selector *v1.LabelSelector
        + Template PodTemplateSpec
        + UpdateStrategy DaemonSetUpdateStrategy
        + MinReadySeconds int32
        + RevisionHistoryLimit *int32

    }
    class DaemonSetStatus << (S,Aquamarine) >> {
        + CurrentNumberScheduled int32
        + NumberMisscheduled int32
        + DesiredNumberScheduled int32
        + NumberReady int32
        + ObservedGeneration int64
        + UpdatedNumberScheduled int32
        + NumberAvailable int32
        + NumberUnavailable int32
        + CollisionCount *int32
        + Conditions []DaemonSetCondition
        + CurrentNumberScheduled int32
        + NumberMisscheduled int32
        + DesiredNumberScheduled int32
        + NumberReady int32
        + ObservedGeneration int64
        + UpdatedNumberScheduled int32
        + NumberAvailable int32
        + NumberUnavailable int32
        + CollisionCount *int32
        + Conditions []DaemonSetCondition

    }
    class DaemonSetUpdateStrategy << (S,Aquamarine) >> {
        + Type DaemonSetUpdateStrategyType
        + RollingUpdate *RollingUpdateDaemonSet
        + Type DaemonSetUpdateStrategyType
        + RollingUpdate *RollingUpdateDaemonSet

    }
    class DeleteOptions << (S,Aquamarine) >> {
        + GracePeriodSeconds *int64
        + Preconditions *Preconditions
        + OrphanDependents *bool
        + PropagationPolicy *DeletionPropagation
        + DryRun []string

    }
    class Deployment << (S,Aquamarine) >> {
        + Spec DeploymentSpec
        + Status DeploymentStatus
        + Spec DeploymentSpec
        + Status DeploymentStatus

    }
    class DeploymentCondition << (S,Aquamarine) >> {
        + Type DeploymentConditionType
        + Status v1.ConditionStatus
        + LastUpdateTime v1.Time
        + LastTransitionTime v1.Time
        + Reason string
        + Message string
        + Type DeploymentConditionType
        + Status ConditionStatus
        + LastUpdateTime v1.Time
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

    }
    class DeploymentList << (S,Aquamarine) >> {
        + Items []Deployment
        + Items []Deployment

    }
    class DeploymentSpec << (S,Aquamarine) >> {
        + Replicas *int32
        + Selector *v1.LabelSelector
        + Template v1.PodTemplateSpec
        + Strategy DeploymentStrategy
        + MinReadySeconds int32
        + RevisionHistoryLimit *int32
        + Paused bool
        + ProgressDeadlineSeconds *int32
        + Replicas *int32
        + Selector *v1.LabelSelector
        + Template PodTemplateSpec
        + Strategy DeploymentStrategy
        + MinReadySeconds int32
        + RevisionHistoryLimit *int32
        + Paused bool
        + ProgressDeadlineSeconds *int32

    }
    class DeploymentStatus << (S,Aquamarine) >> {
        + ObservedGeneration int64
        + Replicas int32
        + UpdatedReplicas int32
        + ReadyReplicas int32
        + AvailableReplicas int32
        + UnavailableReplicas int32
        + Conditions []DeploymentCondition
        + CollisionCount *int32
        + ObservedGeneration int64
        + Replicas int32
        + UpdatedReplicas int32
        + ReadyReplicas int32
        + AvailableReplicas int32
        + UnavailableReplicas int32
        + Conditions []DeploymentCondition
        + CollisionCount *int32

    }
    class DeploymentStrategy << (S,Aquamarine) >> {
        + Type DeploymentStrategyType
        + RollingUpdate *RollingUpdateDeployment
        + Type DeploymentStrategyType
        + RollingUpdate *RollingUpdateDeployment

    }
    class DownwardAPIProjection << (S,Aquamarine) >> {
        + Items []DownwardAPIVolumeFile

    }
    class DownwardAPIVolumeFile << (S,Aquamarine) >> {
        + Path string
        + FieldRef *ObjectFieldSelector
        + ResourceFieldRef *ResourceFieldSelector
        + Mode *int32

    }
    class DownwardAPIVolumeSource << (S,Aquamarine) >> {
        + Items []DownwardAPIVolumeFile
        + DefaultMode *int32

    }
    class Duration << (S,Aquamarine) >> {
        + UnmarshalJSON(b []byte) error
        + MarshalJSON() ([]byte, error)
        + ToUnstructured() <font color=blue>interface</font>{}

    }
    class EmptyDirVolumeSource << (S,Aquamarine) >> {
        + Medium StorageMedium
        + SizeLimit *resource.Quantity

    }
    class EndpointAddress << (S,Aquamarine) >> {
        + IP string
        + Hostname string
        + NodeName *string
        + TargetRef *ObjectReference

    }
    class EndpointPort << (S,Aquamarine) >> {
        + Name string
        + Port int32
        + Protocol Protocol
        + AppProtocol *string

    }
    class EndpointSubset << (S,Aquamarine) >> {
        + Addresses []EndpointAddress
        + NotReadyAddresses []EndpointAddress
        + Ports []EndpointPort

    }
    class Endpoints << (S,Aquamarine) >> {
        + Subsets []EndpointSubset

    }
    class EnvFromSource << (S,Aquamarine) >> {
        + Prefix string
        + ConfigMapRef *ConfigMapEnvSource
        + SecretRef *SecretEnvSource

    }
    class EnvVar << (S,Aquamarine) >> {
        + Name string
        + Value string
        + ValueFrom *EnvVarSource

    }
    class EnvVarSource << (S,Aquamarine) >> {
        + FieldRef *ObjectFieldSelector
        + ResourceFieldRef *ResourceFieldSelector
        + ConfigMapKeyRef *ConfigMapKeySelector
        + SecretKeyRef *SecretKeySelector

    }
    class EphemeralContainer << (S,Aquamarine) >> {
        + TargetContainerName string

    }
    class EphemeralContainerCommon << (S,Aquamarine) >> {
        + Name string
        + Image string
        + Command []string
        + Args []string
        + WorkingDir string
        + Ports []ContainerPort
        + EnvFrom []EnvFromSource
        + Env []EnvVar
        + Resources ResourceRequirements
        + VolumeMounts []VolumeMount
        + VolumeDevices []VolumeDevice
        + LivenessProbe *Probe
        + ReadinessProbe *Probe
        + StartupProbe *Probe
        + Lifecycle *Lifecycle
        + TerminationMessagePath string
        + TerminationMessagePolicy TerminationMessagePolicy
        + ImagePullPolicy PullPolicy
        + SecurityContext *SecurityContext
        + Stdin bool
        + StdinOnce bool
        + TTY bool

    }
    class Event << (S,Aquamarine) >> {
        + InvolvedObject ObjectReference
        + Reason string
        + Message string
        + Source EventSource
        + FirstTimestamp v1.Time
        + LastTimestamp v1.Time
        + Count int32
        + Type string
        + EventTime v1.MicroTime
        + Series *EventSeries
        + Action string
        + Related *ObjectReference
        + ReportingController string
        + ReportingInstance string

    }
    class EventList << (S,Aquamarine) >> {
        + Items []Event

    }
    class EventSeries << (S,Aquamarine) >> {
        + Count int32
        + LastObservedTime v1.MicroTime

    }
    class EventSource << (S,Aquamarine) >> {
        + Component string
        + Host string

    }
    class ExecAction << (S,Aquamarine) >> {
        + Command []string

    }
    class ExecConfig << (S,Aquamarine) >> {
        + Command string
        + Args []string
        + Env []ExecEnvVar
        + APIVersion string
        + InstallHint string
        + ProvideClusterInfo bool
        + InteractiveMode ExecInteractiveMode

    }
    class ExecEnvVar << (S,Aquamarine) >> {
        + Name string
        + Value string

    }
    class FieldsV1 << (S,Aquamarine) >> {
        + Raw []byte

        + String() string

    }
    class GetOptions << (S,Aquamarine) >> {
        + ResourceVersion string

    }
    class GroupVersionForDiscovery << (S,Aquamarine) >> {
        + GroupVersion string
        + Version string

    }
    class HTTPGetAction << (S,Aquamarine) >> {
        + Path string
        + Port intstr.IntOrString
        + Host string
        + Scheme URIScheme
        + HTTPHeaders []HTTPHeader

    }
    class HTTPHeader << (S,Aquamarine) >> {
        + Name string
        + Value string

    }
    class Handler << (S,Aquamarine) >> {
        + Exec *ExecAction
        + HTTPGet *HTTPGetAction
        + TCPSocket *TCPSocketAction

    }
    class HostAlias << (S,Aquamarine) >> {
        + IP string
        + Hostnames []string

    }
    class HostPathVolumeSource << (S,Aquamarine) >> {
        + Path string
        + Type *HostPathType

    }
    class ImageVolumeSource << (S,Aquamarine) >> {
        + Reference string
        + PullPolicy PullPolicy

    }
    class Job << (S,Aquamarine) >> {
        + Spec JobSpec
        + Status JobStatus

    }
    class JobCondition << (S,Aquamarine) >> {
        + Type JobConditionType
        + Status ConditionStatus
        + LastProbeTime v1.Time
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

    }
    class JobList << (S,Aquamarine) >> {
        + Items []Job

    }
    class JobSpec << (S,Aquamarine) >> {
        + Parallelism *int32
        + Completions *int32
        + ActiveDeadlineSeconds *int64
        + PodFailurePolicy *PodFailurePolicy
        + SuccessPolicy *SuccessPolicy
        + BackoffLimit *int32
        + BackoffLimitPerIndex *int32
        + MaxFailedIndexes *int32
        + Selector *v1.LabelSelector
        + ManualSelector *bool
        + Template PodTemplateSpec
        + TTLSecondsAfterFinished *int32
        + CompletionMode *CompletionMode
        + Suspend *bool
        + PodReplacementPolicy *PodReplacementPolicy
        + ManagedBy *string

    }
    class JobStatus << (S,Aquamarine) >> {
        + Conditions []JobCondition
        + StartTime *v1.Time
        + CompletionTime *v1.Time
        + Active int32
        + Succeeded int32
        + Failed int32
        + Terminating *int32
        + CompletedIndexes string
        + FailedIndexes *string
        + UncountedTerminatedPods *UncountedTerminatedPods
        + Ready *int32

    }
    class JobTemplateSpec << (S,Aquamarine) >> {
        + Spec JobSpec

    }
    class KeyToPath << (S,Aquamarine) >> {
        + Key string
        + Path string
        + Mode *int32

    }
    class LabelSelector << (S,Aquamarine) >> {
        + MatchLabels <font color=blue>map</font>[string]string
        + MatchExpressions []LabelSelectorRequirement

    }
    class LabelSelectorRequirement << (S,Aquamarine) >> {
        + Key string
        + Operator LabelSelectorOperator
        + Values []string

    }
    class Lifecycle << (S,Aquamarine) >> {
        + PostStart *Handler
        + PreStop *Handler

    }
    class LimitRange << (S,Aquamarine) >> {
        + Spec LimitRangeSpec

    }
    class LimitRangeItem << (S,Aquamarine) >> {
        + Type LimitType
        + Max ResourceList
        + Min ResourceList
        + Default ResourceList
        + DefaultRequest ResourceList
        + MaxLimitRequestRatio ResourceList

    }
    class LimitRangeList << (S,Aquamarine) >> {
        + Items []LimitRange

    }
    class LimitRangeSpec << (S,Aquamarine) >> {
        + Limits []LimitRangeItem

    }
    class List << (S,Aquamarine) >> {
        + Items []<font color=blue>interface</font>{}

    }
    class ListMeta << (S,Aquamarine) >> {
        + SelfLink string
        + ResourceVersion string
        + Continue string
        + RemainingItemCount *int64

    }
    class ListOptions << (S,Aquamarine) >> {
        + LabelSelector string
        + FieldSelector string
        + Watch bool
        + AllowWatchBookmarks bool
        + ResourceVersion string
        + ResourceVersionMatch ResourceVersionMatch
        + TimeoutSeconds *int64
        + Limit int64
        + Continue string

    }
    class LoadBalancerIngress << (S,Aquamarine) >> {
        + IP string
        + Hostname string
        + Ports []PortStatus

    }
    class LoadBalancerStatus << (S,Aquamarine) >> {
        + Ingress []LoadBalancerIngress

    }
    class LocalObjectReference << (S,Aquamarine) >> {
        + Name string

    }
    class ManagedFieldsEntry << (S,Aquamarine) >> {
        + Manager string
        + Operation ManagedFieldsOperationType
        + APIVersion string
        + Time *Time
        + FieldsType string
        + FieldsV1 *FieldsV1
        + Subresource string

    }
    class MicroTime << (S,Aquamarine) >> {
        + DeepCopyInto(out *MicroTime) 
        + IsZero() bool
        + Before(u *MicroTime) bool
        + Equal(u *MicroTime) bool
        + BeforeTime(u *Time) bool
        + EqualTime(u *Time) bool
        + UnmarshalJSON(b []byte) error
        + UnmarshalQueryParameter(str string) error
        + MarshalJSON() ([]byte, error)
        + MarshalQueryParameter() (string, error)

    }
    class NamedAuthInfo << (S,Aquamarine) >> {
        + Name string
        + AuthInfo AuthInfo

    }
    class NamedCluster << (S,Aquamarine) >> {
        + Name string
        + Cluster Cluster

    }
    class NamedContext << (S,Aquamarine) >> {
        + Name string
        + Context Context

    }
    class NamedExtension << (S,Aquamarine) >> {
        + Name string
        + Extension <font color=blue>interface</font>{}

    }
    class NodeAffinity << (S,Aquamarine) >> {
        + RequiredDuringSchedulingIgnoredDuringExecution *NodeSelector
        + PreferredDuringSchedulingIgnoredDuringExecution []PreferredSchedulingTerm

    }
    class NodeProxyOptions << (S,Aquamarine) >> {
        + Path string

    }
    class NodeResources << (S,Aquamarine) >> {
        + Capacity ResourceList

    }
    class NodeSelector << (S,Aquamarine) >> {
        + NodeSelectorTerms []NodeSelectorTerm

    }
    class NodeSelectorRequirement << (S,Aquamarine) >> {
        + Key string
        + Operator NodeSelectorOperator
        + Values []string

    }
    class NodeSelectorTerm << (S,Aquamarine) >> {
        + MatchExpressions []NodeSelectorRequirement
        + MatchFields []NodeSelectorRequirement

    }
    class ObjectFieldSelector << (S,Aquamarine) >> {
        + APIVersion string
        + FieldPath string

    }
    class ObjectMeta << (S,Aquamarine) >> {
        + Name string
        + GenerateName string
        + Namespace string
        + SelfLink string
        + UID types.UID
        + ResourceVersion string
        + Generation int64
        + CreationTimestamp Time
        + DeletionTimestamp *Time
        + DeletionGracePeriodSeconds *int64
        + Labels <font color=blue>map</font>[string]string
        + Annotations <font color=blue>map</font>[string]string
        + OwnerReferences []OwnerReference
        + Finalizers []string
        + ClusterName string
        + ManagedFields []ManagedFieldsEntry

    }
    class ObjectReference << (S,Aquamarine) >> {
        + Kind string
        + Namespace string
        + Name string
        + UID types.UID
        + APIVersion string
        + ResourceVersion string
        + FieldPath string

    }
    class OwnerReference << (S,Aquamarine) >> {
        + APIVersion string
        + Kind string
        + Name string
        + UID types.UID
        + Controller *bool
        + BlockOwnerDeletion *bool

    }
    class PartialObjectMetadata << (S,Aquamarine) >> {
    }
    class PartialObjectMetadataList << (S,Aquamarine) >> {
        + Items []PartialObjectMetadata

    }
    class Patch << (S,Aquamarine) >> {
    }
    class PatchOptions << (S,Aquamarine) >> {
        + DryRun []string
        + Force *bool
        + FieldManager string

    }
    class PersistentVolume << (S,Aquamarine) >> {
        + Spec PersistentVolumeSpec
        + Status PersistentVolumeStatus

    }
    class PersistentVolumeClaim << (S,Aquamarine) >> {
        + Spec PersistentVolumeClaimSpec
        + Status PersistentVolumeClaimStatus

    }
    class PersistentVolumeClaimCondition << (S,Aquamarine) >> {
        + Type PersistentVolumeClaimConditionType
        + Status ConditionStatus
        + LastProbeTime v1.Time
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

    }
    class PersistentVolumeClaimList << (S,Aquamarine) >> {
        + Items []PersistentVolumeClaim

    }
    class PersistentVolumeClaimSpec << (S,Aquamarine) >> {
        + AccessModes []PersistentVolumeAccessMode
        + Selector *v1.LabelSelector
        + Resources ResourceRequirements
        + VolumeName string
        + StorageClassName *string
        + VolumeMode *PersistentVolumeMode
        + DataSource *TypedLocalObjectReference
        + DataSourceRef *TypedLocalObjectReference

    }
    class PersistentVolumeClaimStatus << (S,Aquamarine) >> {
        + Phase PersistentVolumeClaimPhase
        + AccessModes []PersistentVolumeAccessMode
        + Capacity ResourceList
        + Conditions []PersistentVolumeClaimCondition

    }
    class PersistentVolumeClaimTemplate << (S,Aquamarine) >> {
        + Spec PersistentVolumeClaimSpec

    }
    class PersistentVolumeClaimVolumeSource << (S,Aquamarine) >> {
        + ClaimName string
        + ReadOnly bool

    }
    class PersistentVolumeList << (S,Aquamarine) >> {
        + Items []PersistentVolume

    }
    class PersistentVolumeSource << (S,Aquamarine) >> {
        + HostPath *HostPathVolumeSource

    }
    class PersistentVolumeSpec << (S,Aquamarine) >> {
        + Capacity ResourceList
        + AccessModes []PersistentVolumeAccessMode
        + ClaimRef *ObjectReference
        + PersistentVolumeReclaimPolicy PersistentVolumeReclaimPolicy
        + StorageClassName string
        + MountOptions []string
        + VolumeMode *PersistentVolumeMode
        + NodeAffinity *VolumeNodeAffinity

    }
    class PersistentVolumeStatus << (S,Aquamarine) >> {
        + Phase PersistentVolumePhase
        + Message string
        + Reason string

    }
    class Pod << (S,Aquamarine) >> {
        + Spec PodSpec
        + Status PodStatus

    }
    class PodAffinity << (S,Aquamarine) >> {
        + RequiredDuringSchedulingIgnoredDuringExecution []PodAffinityTerm
        + PreferredDuringSchedulingIgnoredDuringExecution []WeightedPodAffinityTerm

    }
    class PodAffinityTerm << (S,Aquamarine) >> {
        + LabelSelector *v1.LabelSelector
        + Namespaces []string
        + TopologyKey string
        + NamespaceSelector *v1.LabelSelector

    }
    class PodAntiAffinity << (S,Aquamarine) >> {
        + RequiredDuringSchedulingIgnoredDuringExecution []PodAffinityTerm
        + PreferredDuringSchedulingIgnoredDuringExecution []WeightedPodAffinityTerm

    }
    class PodAttachOptions << (S,Aquamarine) >> {
        + Stdin bool
        + Stdout bool
        + Stderr bool
        + TTY bool
        + Container string

    }
    class PodCondition << (S,Aquamarine) >> {
        + Type PodConditionType
        + Status ConditionStatus
        + LastProbeTime v1.Time
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

    }
    class PodDNSConfig << (S,Aquamarine) >> {
        + Nameservers []string
        + Searches []string
        + Options []PodDNSConfigOption

    }
    class PodDNSConfigOption << (S,Aquamarine) >> {
        + Name string
        + Value *string

    }
    class PodExecOptions << (S,Aquamarine) >> {
        + Stdin bool
        + Stdout bool
        + Stderr bool
        + TTY bool
        + Container string
        + Command []string

    }
    class PodFailurePolicy << (S,Aquamarine) >> {
        + Rules []PodFailurePolicyRule

    }
    class PodFailurePolicyOnExitCodesRequirement << (S,Aquamarine) >> {
        + ContainerName *string
        + Operator PodFailurePolicyOnExitCodesOperator
        + Values []int32

    }
    class PodFailurePolicyOnPodConditionsPattern << (S,Aquamarine) >> {
        + Type PodConditionType
        + Status ConditionStatus

    }
    class PodFailurePolicyRule << (S,Aquamarine) >> {
        + Action PodFailurePolicyAction
        + OnExitCodes *PodFailurePolicyOnExitCodesRequirement
        + OnPodConditions []PodFailurePolicyOnPodConditionsPattern

    }
    class PodIP << (S,Aquamarine) >> {
        + IP string

    }
    class PodList << (S,Aquamarine) >> {
        + Items []Pod

    }
    class PodLogOptions << (S,Aquamarine) >> {
        + Container string
        + Follow bool
        + Previous bool
        + SinceSeconds *int64
        + SinceTime *v1.Time
        + Timestamps bool
        + TailLines *int64
        + LimitBytes *int64
        + InsecureSkipTLSVerifyBackend bool

    }
    class PodPortForwardOptions << (S,Aquamarine) >> {
        + Ports []int32

    }
    class PodProxyOptions << (S,Aquamarine) >> {
        + Path string

    }
    class PodReadinessGate << (S,Aquamarine) >> {
        + ConditionType PodConditionType

    }
    class PodSecurityContext << (S,Aquamarine) >> {
        + SELinuxOptions *SELinuxOptions
        + RunAsUser *int64
        + RunAsGroup *int64
        + RunAsNonRoot *bool
        + SupplementalGroups []int64
        + FSGroup *int64
        + Sysctls []Sysctl
        + FSGroupChangePolicy *PodFSGroupChangePolicy
        + SeccompProfile *SeccompProfile

    }
    class PodSpec << (S,Aquamarine) >> {
        + Volumes []Volume
        + InitContainers []Container
        + Containers []Container
        + EphemeralContainers []EphemeralContainer
        + RestartPolicy RestartPolicy
        + TerminationGracePeriodSeconds *int64
        + ActiveDeadlineSeconds *int64
        + DNSPolicy DNSPolicy
        + NodeSelector <font color=blue>map</font>[string]string
        + ServiceAccountName string
        + DeprecatedServiceAccount string
        + AutomountServiceAccountToken *bool
        + NodeName string
        + HostNetwork bool
        + HostPID bool
        + HostIPC bool
        + ShareProcessNamespace *bool
        + SecurityContext *PodSecurityContext
        + ImagePullSecrets []LocalObjectReference
        + Hostname string
        + Subdomain string
        + Affinity *Affinity
        + SchedulerName string
        + HostAliases []HostAlias
        + PriorityClassName string
        + Priority *int32
        + DNSConfig *PodDNSConfig
        + ReadinessGates []PodReadinessGate
        + RuntimeClassName *string
        + EnableServiceLinks *bool
        + PreemptionPolicy *PreemptionPolicy
        + Overhead ResourceList
        + TopologySpreadConstraints []TopologySpreadConstraint
        + SetHostnameAsFQDN *bool
        + HostUsers *bool

    }
    class PodStatus << (S,Aquamarine) >> {
        + Phase PodPhase
        + Conditions []PodCondition
        + Message string
        + Reason string
        + NominatedNodeName string
        + HostIP string
        + PodIP string
        + PodIPs []PodIP
        + StartTime *v1.Time
        + InitContainerStatuses []ContainerStatus
        + ContainerStatuses []ContainerStatus
        + QOSClass PodQOSClass
        + EphemeralContainerStatuses []ContainerStatus

    }
    class PodStatusResult << (S,Aquamarine) >> {
        + Status PodStatus

    }
    class PodTemplate << (S,Aquamarine) >> {
        + Template PodTemplateSpec

    }
    class PodTemplateList << (S,Aquamarine) >> {
        + Items []PodTemplate

    }
    class PodTemplateSpec << (S,Aquamarine) >> {
        + Spec PodSpec

    }
    class PortStatus << (S,Aquamarine) >> {
        + Port int32
        + Protocol Protocol
        + Error *string

    }
    class Preconditions << (S,Aquamarine) >> {
        + UID *types.UID
        + ResourceVersion *string

    }
    class Preferences << (S,Aquamarine) >> {
        + Colors bool
        + Extensions []NamedExtension

    }
    class PreferredSchedulingTerm << (S,Aquamarine) >> {
        + Weight int32
        + Preference NodeSelectorTerm

    }
    class Probe << (S,Aquamarine) >> {
        + InitialDelaySeconds int32
        + TimeoutSeconds int32
        + PeriodSeconds int32
        + SuccessThreshold int32
        + FailureThreshold int32
        + TerminationGracePeriodSeconds *int64

    }
    class ProjectedVolumeSource << (S,Aquamarine) >> {
        + Sources []VolumeProjection
        + DefaultMode *int32

    }
    class ReplicaSet << (S,Aquamarine) >> {
        + Spec ReplicaSetSpec
        + Status ReplicaSetStatus

    }
    class ReplicaSetCondition << (S,Aquamarine) >> {
        + Type ReplicaSetConditionType
        + Status v1.ConditionStatus
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

    }
    class ReplicaSetList << (S,Aquamarine) >> {
        + Items []ReplicaSet

    }
    class ReplicaSetSpec << (S,Aquamarine) >> {
        + Replicas *int32
        + MinReadySeconds int32
        + Selector *v1.LabelSelector
        + Template v1.PodTemplateSpec

    }
    class ReplicaSetStatus << (S,Aquamarine) >> {
        + Replicas int32
        + FullyLabeledReplicas int32
        + ReadyReplicas int32
        + AvailableReplicas int32
        + ObservedGeneration int64
        + Conditions []ReplicaSetCondition

    }
    class ReplicationController << (S,Aquamarine) >> {
        + Spec ReplicationControllerSpec
        + Status ReplicationControllerStatus

    }
    class ReplicationControllerCondition << (S,Aquamarine) >> {
        + Type ReplicationControllerConditionType
        + Status ConditionStatus
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

    }
    class ReplicationControllerList << (S,Aquamarine) >> {
        + Items []ReplicationController

    }
    class ReplicationControllerSpec << (S,Aquamarine) >> {
        + Replicas *int32
        + MinReadySeconds int32
        + Selector <font color=blue>map</font>[string]string
        + Template *PodTemplateSpec

    }
    class ReplicationControllerStatus << (S,Aquamarine) >> {
        + Replicas int32
        + FullyLabeledReplicas int32
        + ReadyReplicas int32
        + AvailableReplicas int32
        + ObservedGeneration int64
        + Conditions []ReplicationControllerCondition

    }
    class ResourceFieldSelector << (S,Aquamarine) >> {
        + ContainerName string
        + Resource string
        + Divisor resource.Quantity

    }
    class ResourceList << (S,Aquamarine) >> {
        + Cpu() *resource.Quantity
        + Memory() *resource.Quantity
        + Storage() *resource.Quantity
        + Pods() *resource.Quantity
        + StorageEphemeral() *resource.Quantity
        + Name(name ResourceName, defaultFormat resource.Format) *resource.Quantity

    }
    class ResourceName << (S,Aquamarine) >> {
        + String() string

    }
    class ResourceQuota << (S,Aquamarine) >> {
        + Spec ResourceQuotaSpec
        + Status ResourceQuotaStatus

    }
    class ResourceQuotaList << (S,Aquamarine) >> {
        + Items []ResourceQuota

    }
    class ResourceQuotaSpec << (S,Aquamarine) >> {
        + Hard ResourceList
        + Scopes []ResourceQuotaScope
        + ScopeSelector *ScopeSelector

    }
    class ResourceQuotaStatus << (S,Aquamarine) >> {
        + Hard ResourceList
        + Used ResourceList

    }
    class ResourceRequirements << (S,Aquamarine) >> {
        + Limits ResourceList
        + Requests ResourceList

    }
    class RollingUpdateDaemonSet << (S,Aquamarine) >> {
        + MaxUnavailable *intstr.IntOrString
        + MaxSurge *intstr.IntOrString
        + MaxUnavailable *intstr.IntOrString
        + MaxSurge *intstr.IntOrString

    }
    class RollingUpdateDeployment << (S,Aquamarine) >> {
        + MaxUnavailable *intstr.IntOrString
        + MaxSurge *intstr.IntOrString
        + MaxUnavailable *intstr.IntOrString
        + MaxSurge *intstr.IntOrString

    }
    class RollingUpdateStatefulSetStrategy << (S,Aquamarine) >> {
        + Partition *int32

    }
    class RootPaths << (S,Aquamarine) >> {
        + Paths []string

    }
    class SELinuxOptions << (S,Aquamarine) >> {
        + User string
        + Role string
        + Type string
        + FileType string
        + Level string

    }
    class ScopeSelector << (S,Aquamarine) >> {
        + MatchExpressions []ScopedResourceSelectorRequirement

    }
    class ScopedResourceSelectorRequirement << (S,Aquamarine) >> {
        + ScopeName ResourceQuotaScope
        + Operator ScopeSelectorOperator
        + Values []string

    }
    class SeccompProfile << (S,Aquamarine) >> {
        + Type SeccompProfileType
        + LocalhostProfile *string

    }
    class Secret << (S,Aquamarine) >> {
        + Immutable *bool
        + Data <font color=blue>map</font>[string][]byte
        + StringData <font color=blue>map</font>[string]string
        + Type SecretType

    }
    class SecretEnvSource << (S,Aquamarine) >> {
        + Optional *bool

    }
    class SecretKeySelector << (S,Aquamarine) >> {
        + Key string
        + Optional *bool

    }
    class SecretList << (S,Aquamarine) >> {
        + Items []Secret

    }
    class SecretProjection << (S,Aquamarine) >> {
        + Items []KeyToPath
        + Optional *bool

    }
    class SecretReference << (S,Aquamarine) >> {
        + Name string
        + Namespace string

    }
    class SecretVolumeSource << (S,Aquamarine) >> {
        + SecretName string
        + Items []KeyToPath
        + DefaultMode *int32
        + Optional *bool

    }
    class SecurityContext << (S,Aquamarine) >> {
        + Capabilities *Capabilities
        + Privileged *bool
        + SELinuxOptions *SELinuxOptions
        + RunAsUser *int64
        + RunAsGroup *int64
        + RunAsNonRoot *bool
        + ReadOnlyRootFilesystem *bool
        + AllowPrivilegeEscalation *bool
        + ProcMount *ProcMountType
        + SeccompProfile *SeccompProfile

    }
    class SerializedReference << (S,Aquamarine) >> {
        + Reference ObjectReference

    }
    class ServerAddressByClientCIDR << (S,Aquamarine) >> {
        + ClientCIDR string
        + ServerAddress string

    }
    class Service << (S,Aquamarine) >> {
        + Spec ServiceSpec
        + Status ServiceStatus

    }
    class ServiceAccount << (S,Aquamarine) >> {
        + Secrets []ObjectReference
        + ImagePullSecrets []LocalObjectReference
        + AutomountServiceAccountToken *bool

    }
    class ServiceAccountList << (S,Aquamarine) >> {
        + Items []ServiceAccount

    }
    class ServiceAccountTokenProjection << (S,Aquamarine) >> {
        + Audience string
        + ExpirationSeconds *int64
        + Path string

    }
    class ServiceList << (S,Aquamarine) >> {
        + Items []Service

    }
    class ServicePort << (S,Aquamarine) >> {
        + Name string
        + Protocol Protocol
        + AppProtocol *string
        + Port int32
        + TargetPort intstr.IntOrString
        + NodePort int32

    }
    class ServiceProxyOptions << (S,Aquamarine) >> {
        + Path string

    }
    class ServiceSpec << (S,Aquamarine) >> {
        + Ports []ServicePort
        + Selector <font color=blue>map</font>[string]string
        + ClusterIP string
        + ClusterIPs []string
        + Type ServiceType
        + ExternalIPs []string
        + SessionAffinity ServiceAffinity
        + LoadBalancerIP string
        + LoadBalancerSourceRanges []string
        + ExternalName string
        + ExternalTrafficPolicy ServiceExternalTrafficPolicyType
        + HealthCheckNodePort int32
        + PublishNotReadyAddresses bool
        + SessionAffinityConfig *SessionAffinityConfig
        + IPFamilies []IPFamily
        + IPFamilyPolicy *IPFamilyPolicyType
        + AllocateLoadBalancerNodePorts *bool
        + LoadBalancerClass *string
        + InternalTrafficPolicy *ServiceInternalTrafficPolicyType

    }
    class ServiceStatus << (S,Aquamarine) >> {
        + LoadBalancer LoadBalancerStatus
        + Conditions []v1.Condition

    }
    class SessionAffinityConfig << (S,Aquamarine) >> {
        + ClientIP *ClientIPConfig

    }
    class StatefulSet << (S,Aquamarine) >> {
        + Spec StatefulSetSpec
        + Status StatefulSetStatus

    }
    class StatefulSetCondition << (S,Aquamarine) >> {
        + Type StatefulSetConditionType
        + Status v1.ConditionStatus
        + LastTransitionTime v1.Time
        + Reason string
        + Message string

    }
    class StatefulSetList << (S,Aquamarine) >> {
        + Items []StatefulSet

    }
    class StatefulSetSpec << (S,Aquamarine) >> {
        + Replicas *int32
        + Selector *v1.LabelSelector
        + Template v1.PodTemplateSpec
        + VolumeClaimTemplates []v1.PersistentVolumeClaim
        + ServiceName string
        + PodManagementPolicy PodManagementPolicyType
        + UpdateStrategy StatefulSetUpdateStrategy
        + RevisionHistoryLimit *int32
        + MinReadySeconds int32

    }
    class StatefulSetStatus << (S,Aquamarine) >> {
        + ObservedGeneration int64
        + Replicas int32
        + ReadyReplicas int32
        + CurrentReplicas int32
        + UpdatedReplicas int32
        + CurrentRevision string
        + UpdateRevision string
        + CollisionCount *int32
        + Conditions []StatefulSetCondition
        + AvailableReplicas int32

    }
    class StatefulSetUpdateStrategy << (S,Aquamarine) >> {
        + Type StatefulSetUpdateStrategyType
        + RollingUpdate *RollingUpdateStatefulSetStrategy

    }
    class Status << (S,Aquamarine) >> {
        + Status string
        + Message string
        + Reason StatusReason
        + Details *StatusDetails
        + Code int32

    }
    class StatusCause << (S,Aquamarine) >> {
        + Type CauseType
        + Message string
        + Field string

    }
    class StatusDetails << (S,Aquamarine) >> {
        + Name string
        + Group string
        + Kind string
        + UID types.UID
        + Causes []StatusCause
        + RetryAfterSeconds int32

    }
    class SuccessPolicy << (S,Aquamarine) >> {
        + Rules []SuccessPolicyRule

    }
    class SuccessPolicyRule << (S,Aquamarine) >> {
        + SucceededIndexes *string
        + SucceededCount *int32

    }
    class Sysctl << (S,Aquamarine) >> {
        + Name string
        + Value string

    }
    class TCPSocketAction << (S,Aquamarine) >> {
        + Port intstr.IntOrString
        + Host string

    }
    class TableOptions << (S,Aquamarine) >> {
        + NoHeaders bool
        + IncludeObject IncludeObjectPolicy

    }
    class Time << (S,Aquamarine) >> {
        + DeepCopyInto(out *Time) 
        + IsZero() bool
        + Before(u *Time) bool
        + Equal(u *Time) bool
        + Rfc3339Copy() Time
        + UnmarshalJSON(b []byte) error
        + UnmarshalQueryParameter(str string) error
        + MarshalJSON() ([]byte, error)
        + ToUnstructured() <font color=blue>interface</font>{}
        + MarshalQueryParameter() (string, error)

    }
    class TopologySelectorLabelRequirement << (S,Aquamarine) >> {
        + Key string
        + Values []string

    }
    class TopologySelectorTerm << (S,Aquamarine) >> {
        + MatchLabelExpressions []TopologySelectorLabelRequirement

    }
    class TopologySpreadConstraint << (S,Aquamarine) >> {
        + MaxSkew int32
        + TopologyKey string
        + WhenUnsatisfiable UnsatisfiableConstraintAction
        + LabelSelector *v1.LabelSelector

    }
    class TypeMeta << (S,Aquamarine) >> {
        + Kind string
        + APIVersion string

    }
    class TypedLocalObjectReference << (S,Aquamarine) >> {
        + APIGroup *string
        + Kind string
        + Name string

    }
    class UncountedTerminatedPods << (S,Aquamarine) >> {
        + Succeeded []types.UID
        + Failed []types.UID

    }
    class UpdateOptions << (S,Aquamarine) >> {
        + DryRun []string
        + FieldManager string

    }
    class Verbs << (S,Aquamarine) >> {
        + String() string

    }
    class Volume << (S,Aquamarine) >> {
        + Name string

    }
    class VolumeDevice << (S,Aquamarine) >> {
        + Name string
        + DevicePath string

    }
    class VolumeMount << (S,Aquamarine) >> {
        + Name string
        + ReadOnly bool
        + MountPath string
        + SubPath string
        + MountPropagation *MountPropagationMode
        + SubPathExpr string

    }
    class VolumeNodeAffinity << (S,Aquamarine) >> {
        + Required *NodeSelector

    }
    class VolumeProjection << (S,Aquamarine) >> {
        + Secret *SecretProjection
        + DownwardAPI *DownwardAPIProjection
        + ConfigMap *ConfigMapProjection
        + ServiceAccountToken *ServiceAccountTokenProjection

    }
    class VolumeSource << (S,Aquamarine) >> {
        + HostPath *HostPathVolumeSource
        + PersistentVolumeClaim *PersistentVolumeClaimVolumeSource
        + ConfigMap *ConfigMapVolumeSource
        + Secret *SecretVolumeSource
        + EmptyDir *EmptyDirVolumeSource
        + Image *ImageVolumeSource

    }
    class WeightedPodAffinityTerm << (S,Aquamarine) >> {
        + Weight int32
        + PodAffinityTerm PodAffinityTerm

    }
    class v1.Capability << (T, #FF7700) >>  {
    }
    class v1.CauseType << (T, #FF7700) >>  {
    }
    class v1.CompletionMode << (T, #FF7700) >>  {
    }
    class v1.ComponentConditionType << (T, #FF7700) >>  {
    }
    class v1.ConditionStatus << (T, #FF7700) >>  {
    }
    class v1.DNSPolicy << (T, #FF7700) >>  {
    }
    class v1.DaemonSetConditionType << (T, #FF7700) >>  {
    }
    class v1.DaemonSetUpdateStrategyType << (T, #FF7700) >>  {
    }
    class v1.DeletionPropagation << (T, #FF7700) >>  {
    }
    class v1.DeploymentConditionType << (T, #FF7700) >>  {
    }
    class v1.DeploymentStrategyType << (T, #FF7700) >>  {
    }
    class v1.ExecInteractiveMode << (T, #FF7700) >>  {
    }
    class v1.HostPathType << (T, #FF7700) >>  {
    }
    class v1.IPFamily << (T, #FF7700) >>  {
    }
    class v1.IPFamilyPolicyType << (T, #FF7700) >>  {
    }
    class v1.IncludeObjectPolicy << (T, #FF7700) >>  {
    }
    class v1.JobConditionType << (T, #FF7700) >>  {
    }
    class v1.LabelSelectorOperator << (T, #FF7700) >>  {
    }
    class v1.LimitType << (T, #FF7700) >>  {
    }
    class v1.ManagedFieldsOperationType << (T, #FF7700) >>  {
    }
    class v1.MountPropagationMode << (T, #FF7700) >>  {
    }
    class v1.NodeSelectorOperator << (T, #FF7700) >>  {
    }
    class v1.PersistentVolumeAccessMode << (T, #FF7700) >>  {
    }
    class v1.PersistentVolumeClaimConditionType << (T, #FF7700) >>  {
    }
    class v1.PersistentVolumeClaimPhase << (T, #FF7700) >>  {
    }
    class v1.PersistentVolumeMode << (T, #FF7700) >>  {
    }
    class v1.PersistentVolumePhase << (T, #FF7700) >>  {
    }
    class v1.PersistentVolumeReclaimPolicy << (T, #FF7700) >>  {
    }
    class v1.PodConditionType << (T, #FF7700) >>  {
    }
    class v1.PodFSGroupChangePolicy << (T, #FF7700) >>  {
    }
    class v1.PodFailurePolicyAction << (T, #FF7700) >>  {
    }
    class v1.PodFailurePolicyOnExitCodesOperator << (T, #FF7700) >>  {
    }
    class v1.PodManagementPolicyType << (T, #FF7700) >>  {
    }
    class v1.PodPhase << (T, #FF7700) >>  {
    }
    class v1.PodQOSClass << (T, #FF7700) >>  {
    }
    class v1.PodReplacementPolicy << (T, #FF7700) >>  {
    }
    class v1.PreemptionPolicy << (T, #FF7700) >>  {
    }
    class v1.ProcMountType << (T, #FF7700) >>  {
    }
    class v1.Protocol << (T, #FF7700) >>  {
    }
    class v1.PullPolicy << (T, #FF7700) >>  {
    }
    class v1.ReplicaSetConditionType << (T, #FF7700) >>  {
    }
    class v1.ReplicationControllerConditionType << (T, #FF7700) >>  {
    }
    class v1.ResourceList << (T, #FF7700) >>  {
    }
    class v1.ResourceName << (T, #FF7700) >>  {
    }
    class v1.ResourceQuotaScope << (T, #FF7700) >>  {
    }
    class v1.ResourceVersionMatch << (T, #FF7700) >>  {
    }
    class v1.RestartPolicy << (T, #FF7700) >>  {
    }
    class v1.ScopeSelectorOperator << (T, #FF7700) >>  {
    }
    class v1.SeccompProfileType << (T, #FF7700) >>  {
    }
    class v1.SecretType << (T, #FF7700) >>  {
    }
    class v1.ServiceAffinity << (T, #FF7700) >>  {
    }
    class v1.ServiceExternalTrafficPolicyType << (T, #FF7700) >>  {
    }
    class v1.ServiceInternalTrafficPolicyType << (T, #FF7700) >>  {
    }
    class v1.ServiceType << (T, #FF7700) >>  {
    }
    class v1.StatefulSetConditionType << (T, #FF7700) >>  {
    }
    class v1.StatefulSetUpdateStrategyType << (T, #FF7700) >>  {
    }
    class v1.StatusReason << (T, #FF7700) >>  {
    }
    class v1.StorageMedium << (T, #FF7700) >>  {
    }
    class v1.TerminationMessagePolicy << (T, #FF7700) >>  {
    }
    class v1.URIScheme << (T, #FF7700) >>  {
    }
    class v1.UnsatisfiableConstraintAction << (T, #FF7700) >>  {
    }
    class v1.Verbs << (T, #FF7700) >>  {
    }
    class "<font color=blue>map</font>[ResourceName]resource.Quantity" as fontcolorbluemapfontResourceNameresourceQuantity {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"v1.TypeMeta" *-- "extends""v1.APIGroup"
"v1.TypeMeta" *-- "extends""v1.APIGroupList"
"v1.TypeMeta" *-- "extends""v1.APIResourceList"
"v1.TypeMeta" *-- "extends""v1.APIVersions"
"v1.TypeMeta" *-- "extends""v1.ApplyOptions"
"v1.ObjectMeta" *-- "extends""v1.ComponentStatus"
"v1.TypeMeta" *-- "extends""v1.ComponentStatus"
"v1.ListMeta" *-- "extends""v1.ComponentStatusList"
"v1.TypeMeta" *-- "extends""v1.ComponentStatusList"
"v1.ObjectMeta" *-- "extends""v1.ConfigMap"
"v1.TypeMeta" *-- "extends""v1.ConfigMap"
"v1.LocalObjectReference" *-- "extends""v1.ConfigMapEnvSource"
"v1.LocalObjectReference" *-- "extends""v1.ConfigMapKeySelector"
"v1.ListMeta" *-- "extends""v1.ConfigMapList"
"v1.TypeMeta" *-- "extends""v1.ConfigMapList"
"v1.LocalObjectReference" *-- "extends""v1.ConfigMapProjection"
"v1.LocalObjectReference" *-- "extends""v1.ConfigMapVolumeSource"
"v1.TypeMeta" *-- "extends""v1.CreateOptions"
"v1.ObjectMeta" *-- "extends""v1.DaemonSet"
"v1.TypeMeta" *-- "extends""v1.DaemonSet"
"v1.ListMeta" *-- "extends""v1.DaemonSetList"
"v1.TypeMeta" *-- "extends""v1.DaemonSetList"
"v1.TypeMeta" *-- "extends""v1.DeleteOptions"
"v1.ObjectMeta" *-- "extends""v1.Deployment"
"v1.TypeMeta" *-- "extends""v1.Deployment"
"v1.ListMeta" *-- "extends""v1.DeploymentList"
"v1.TypeMeta" *-- "extends""v1.DeploymentList"
"time.Duration" *-- "extends""v1.Duration"
"v1.ObjectMeta" *-- "extends""v1.Endpoints"
"v1.TypeMeta" *-- "extends""v1.Endpoints"
"v1.EphemeralContainerCommon" *-- "extends""v1.EphemeralContainer"
"v1.ObjectMeta" *-- "extends""v1.Event"
"v1.TypeMeta" *-- "extends""v1.Event"
"v1.ListMeta" *-- "extends""v1.EventList"
"v1.TypeMeta" *-- "extends""v1.EventList"
"v1.TypeMeta" *-- "extends""v1.GetOptions"
"v1.ObjectMeta" *-- "extends""v1.Job"
"v1.TypeMeta" *-- "extends""v1.Job"
"v1.ListMeta" *-- "extends""v1.JobList"
"v1.TypeMeta" *-- "extends""v1.JobList"
"v1.ObjectMeta" *-- "extends""v1.JobTemplateSpec"
"v1.ObjectMeta" *-- "extends""v1.LimitRange"
"v1.TypeMeta" *-- "extends""v1.LimitRange"
"v1.ListMeta" *-- "extends""v1.LimitRangeList"
"v1.TypeMeta" *-- "extends""v1.LimitRangeList"
"v1.ListMeta" *-- "extends""v1.List"
"v1.TypeMeta" *-- "extends""v1.List"
"v1.TypeMeta" *-- "extends""v1.ListOptions"
"time.Time" *-- "extends""v1.MicroTime"
"v1.TypeMeta" *-- "extends""v1.NodeProxyOptions"
"v1.ObjectMeta" *-- "extends""v1.PartialObjectMetadata"
"v1.TypeMeta" *-- "extends""v1.PartialObjectMetadata"
"v1.ListMeta" *-- "extends""v1.PartialObjectMetadataList"
"v1.TypeMeta" *-- "extends""v1.PartialObjectMetadataList"
"v1.TypeMeta" *-- "extends""v1.PatchOptions"
"v1.ObjectMeta" *-- "extends""v1.PersistentVolume"
"v1.TypeMeta" *-- "extends""v1.PersistentVolume"
"v1.ObjectMeta" *-- "extends""v1.PersistentVolumeClaim"
"v1.TypeMeta" *-- "extends""v1.PersistentVolumeClaim"
"v1.ListMeta" *-- "extends""v1.PersistentVolumeClaimList"
"v1.TypeMeta" *-- "extends""v1.PersistentVolumeClaimList"
"v1.ObjectMeta" *-- "extends""v1.PersistentVolumeClaimTemplate"
"v1.ListMeta" *-- "extends""v1.PersistentVolumeList"
"v1.TypeMeta" *-- "extends""v1.PersistentVolumeList"
"v1.PersistentVolumeSource" *-- "extends""v1.PersistentVolumeSpec"
"v1.ObjectMeta" *-- "extends""v1.Pod"
"v1.TypeMeta" *-- "extends""v1.Pod"
"v1.TypeMeta" *-- "extends""v1.PodAttachOptions"
"v1.TypeMeta" *-- "extends""v1.PodExecOptions"
"v1.ListMeta" *-- "extends""v1.PodList"
"v1.TypeMeta" *-- "extends""v1.PodList"
"v1.TypeMeta" *-- "extends""v1.PodLogOptions"
"v1.TypeMeta" *-- "extends""v1.PodPortForwardOptions"
"v1.TypeMeta" *-- "extends""v1.PodProxyOptions"
"v1.ObjectMeta" *-- "extends""v1.PodStatusResult"
"v1.TypeMeta" *-- "extends""v1.PodStatusResult"
"v1.ObjectMeta" *-- "extends""v1.PodTemplate"
"v1.TypeMeta" *-- "extends""v1.PodTemplate"
"v1.ListMeta" *-- "extends""v1.PodTemplateList"
"v1.TypeMeta" *-- "extends""v1.PodTemplateList"
"v1.ObjectMeta" *-- "extends""v1.PodTemplateSpec"
"v1.Handler" *-- "extends""v1.Probe"
"v1.ObjectMeta" *-- "extends""v1.ReplicaSet"
"v1.TypeMeta" *-- "extends""v1.ReplicaSet"
"v1.ListMeta" *-- "extends""v1.ReplicaSetList"
"v1.TypeMeta" *-- "extends""v1.ReplicaSetList"
"v1.ObjectMeta" *-- "extends""v1.ReplicationController"
"v1.TypeMeta" *-- "extends""v1.ReplicationController"
"v1.ListMeta" *-- "extends""v1.ReplicationControllerList"
"v1.TypeMeta" *-- "extends""v1.ReplicationControllerList"
"v1.ObjectMeta" *-- "extends""v1.ResourceQuota"
"v1.TypeMeta" *-- "extends""v1.ResourceQuota"
"v1.ListMeta" *-- "extends""v1.ResourceQuotaList"
"v1.TypeMeta" *-- "extends""v1.ResourceQuotaList"
"v1.ObjectMeta" *-- "extends""v1.Secret"
"v1.TypeMeta" *-- "extends""v1.Secret"
"v1.LocalObjectReference" *-- "extends""v1.SecretEnvSource"
"v1.LocalObjectReference" *-- "extends""v1.SecretKeySelector"
"v1.ListMeta" *-- "extends""v1.SecretList"
"v1.TypeMeta" *-- "extends""v1.SecretList"
"v1.LocalObjectReference" *-- "extends""v1.SecretProjection"
"v1.TypeMeta" *-- "extends""v1.SerializedReference"
"v1.ObjectMeta" *-- "extends""v1.Service"
"v1.TypeMeta" *-- "extends""v1.Service"
"v1.ObjectMeta" *-- "extends""v1.ServiceAccount"
"v1.TypeMeta" *-- "extends""v1.ServiceAccount"
"v1.ListMeta" *-- "extends""v1.ServiceAccountList"
"v1.TypeMeta" *-- "extends""v1.ServiceAccountList"
"v1.ListMeta" *-- "extends""v1.ServiceList"
"v1.TypeMeta" *-- "extends""v1.ServiceList"
"v1.TypeMeta" *-- "extends""v1.ServiceProxyOptions"
"v1.ObjectMeta" *-- "extends""v1.StatefulSet"
"v1.TypeMeta" *-- "extends""v1.StatefulSet"
"v1.ListMeta" *-- "extends""v1.StatefulSetList"
"v1.TypeMeta" *-- "extends""v1.StatefulSetList"
"v1.ListMeta" *-- "extends""v1.Status"
"v1.TypeMeta" *-- "extends""v1.Status"
"v1.TypeMeta" *-- "extends""v1.TableOptions"
"time.Time" *-- "extends""v1.Time"
"v1.TypeMeta" *-- "extends""v1.UpdateOptions"
"v1.VolumeSource" *-- "extends""v1.Volume"


namespace validate {
    class ChoiceValue << (S,Aquamarine) >> {
        + String() string
        + Set(value string) error
        + Choices() string
        + Type() string

    }
}


namespace version {
    class version.Level << (T, #FF7700) >>  {
    }
    class version.Tree << (T, #FF7700) >>  {
    }
}


namespace vfkit {
    class Helper << (S,Aquamarine) >> {
        + LogLevel logrus.Level
        + Endpoint string
        + BinaryPath *define.VMFile
        + VirtualMachine *config.VirtualMachine
        + Rosetta bool

        + State() (define.Status, error)
        + Stop(force bool, wait bool) error

    }
    class vfkit.Endpoint << (T, #FF7700) >>  {
    }
    class vfkit.VZMachineState << (T, #FF7700) >>  {
    }
}


namespace vmconfigs {
    class AnsibleConfig << (S,Aquamarine) >> {
        + PlaybookPath string
        + Contents string
        + User string

    }
    class AppleHVConfig << (S,Aquamarine) >> {
        + Vfkit vfkit.Helper

    }
    class HostUser << (S,Aquamarine) >> {
        + Rootful bool
        + UID int
        + Modified bool

    }
    class HyperVConfig << (S,Aquamarine) >> {
        + ReadyVsock vsock.HVSockRegistryEntry
        + NetworkVSock vsock.HVSockRegistryEntry

    }
    class LibKrunConfig << (S,Aquamarine) >> {
        + KRun vfkit.Helper

    }
    class MachineConfig << (S,Aquamarine) >> {
        + Created time.Time
        + GvProxy types.GvproxyCommand
        + HostUser HostUser
        + LastUp time.Time
        + Mounts []*Mount
        + Name string
        + Resources ResourceConfig
        + SSH SSHConfig
        + Version uint
        + ImagePath *define.VMFile
        + AppleHypervisor *AppleHVConfig
        + HyperVHypervisor *HyperVConfig
        + LibKrunHypervisor *LibKrunConfig
        + QEMUHypervisor *QEMUConfig
        + WSLHypervisor *WSLConfig
        + Starting bool
        + Rosetta bool
        + Ansible *AnsibleConfig

        + Lock() 
        + Unlock() 
        + Refresh() error
        + Write() error
        + SetRootful(rootful bool) error
        + Remove(machines <font color=blue>map</font>[string]bool, saveIgnition bool, saveImage bool) ([]string, <font color=blue>func</font>() error, error)
        + ConfigDir() (*define.VMFile, error)
        + DataDir() (*define.VMFile, error)
        + RuntimeDir() (*define.VMFile, error)
        + SetDirs(dirs *define.MachineDirs) 
        + IgnitionFile() (*define.VMFile, error)
        + ReadySocket() (*define.VMFile, error)
        + GVProxySocket() (*define.VMFile, error)
        + APISocket() (*define.VMFile, error)
        + LogFile() (*define.VMFile, error)
        + IsFirstBoot() (bool, error)
        + ConnectionInfo(vmtype define.VMType) (*define.VMFile, *define.VMFile, error)

    }
    class Mount << (S,Aquamarine) >> {
        + OriginalInput string
        + ReadOnly bool
        + Source string
        + Tag string
        + Target string
        + Type string
        + VSockNumber *uint64

    }
    class OCIMachineImage << (S,Aquamarine) >> {
        + FQImageReference string

    }
    class QEMUConfig << (S,Aquamarine) >> {
        + QMPMonitor command.Monitor
        + QEMUPidPath *define.VMFile
        + QMPMonitor command.Monitor
        + QEMUPidPath *define.VMFile

    }
    class ResourceConfig << (S,Aquamarine) >> {
        + CPUs uint64
        + DiskSize strongunits.GiB
        + Memory strongunits.MiB
        + USBs []define.USBConfig

    }
    class SSHConfig << (S,Aquamarine) >> {
        + IdentityPath string
        + Port int
        + RemoteUsername string

    }
    interface VMProvider  {
        + CreateVM(opts define.CreateVMOpts, mc *MachineConfig, builder *ignition.IgnitionBuilder) error
        + PrepareIgnition(mc *MachineConfig, ignBuilder *ignition.IgnitionBuilder) (*ignition.ReadyUnitOpts, error)
        + Exists(name string) (bool, error)
        + MountType() VolumeMountType
        + MountVolumesToVM(mc *MachineConfig, quiet bool) error
        + Remove(mc *MachineConfig) ([]string, <font color=blue>func</font>() error, error)
        + RemoveAndCleanMachines(dirs *define.MachineDirs) error
        + SetProviderAttrs(mc *MachineConfig, opts define.SetOptions) error
        + StartNetworking(mc *MachineConfig, cmd *types.GvproxyCommand) error
        + PostStartNetworking(mc *MachineConfig, noInfo bool) error
        + StartVM(mc *MachineConfig) (<font color=blue>func</font>() error, <font color=blue>func</font>() error, error)
        + State(mc *MachineConfig, bypass bool) (define.Status, error)
        + StopVM(mc *MachineConfig, hardStop bool) error
        + StopHostNetworking(mc *MachineConfig, vmType define.VMType) error
        + VMType() define.VMType
        + UserModeNetworkEnabled(mc *MachineConfig) bool
        + UseProviderNetworkSetup() bool
        + RequireExclusiveActive() bool
        + UpdateSSHPort(mc *MachineConfig, port int) error
        + GetRosetta(mc *MachineConfig) (bool, error)

    }
    class VMStats << (S,Aquamarine) >> {
        + Created time.Time
        + LastUp time.Time

    }
    class VolumeMountType << (S,Aquamarine) >> {
        + String() string

    }
    class WSLConfig << (S,Aquamarine) >> {
        + UserModeNetworking bool

    }
    interface machineImage  {
    }
    class vmconfigs.RemoteConnectionType << (T, #FF7700) >>  {
    }
    class vmconfigs.VolumeMountType << (T, #FF7700) >>  {
    }
}

"vmconfigs.machineImage" <|-- "implements""vmconfigs.OCIMachineImage"

namespace volumes {
    class CreateOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class ExistsOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class InspectOptions << (S,Aquamarine) >> {
        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)

    }
    class ListOptions << (S,Aquamarine) >> {
        + Filters <font color=blue>map</font>[string][]string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithFilters(value <font color=blue>map</font>[string][]string) *ListOptions
        + GetFilters() <font color=blue>map</font>[string][]string

    }
    class PruneOptions << (S,Aquamarine) >> {
        + Filters <font color=blue>map</font>[string][]string

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithFilters(value <font color=blue>map</font>[string][]string) *PruneOptions
        + GetFilters() <font color=blue>map</font>[string][]string

    }
    class RemoveOptions << (S,Aquamarine) >> {
        + Force *bool
        + Timeout *uint

        + Changed(fieldName string) bool
        + ToParams() (url.Values, error)
        + WithForce(value bool) *RemoveOptions
        + GetForce() bool
        + WithTimeout(value uint) *RemoveOptions
        + GetTimeout() uint

    }
}


namespace vsock {
    class HVSockPurpose << (S,Aquamarine) >> {
        + Equal(purpose string) bool

    }
    class HVSockRegistryEntry << (S,Aquamarine) >> {
        + KeyName string
        + Purpose HVSockPurpose
        + Port uint64
        + MachineName string
        + Key registry.Key

        + Add() error
        + Remove() error
        + Listener() (net.Listener, error)
        + ListenSetupWait() (<font color=blue>func</font>() error, io.Closer, error)

    }
    class vsock.HVSockPurpose << (T, #FF7700) >>  {
    }
}


namespace wsl {
    class ExitCodeError << (S,Aquamarine) >> {
        + Error() string

    }
    class Luid << (S,Aquamarine) >> {
    }
    class LuidAndAttributes << (S,Aquamarine) >> {
    }
    class SHELLEXECUTEINFO << (S,Aquamarine) >> {
    }
    class TokenPrivileges << (S,Aquamarine) >> {
    }
    class WSLStubber << (S,Aquamarine) >> {
        + CreateVM(opts define.CreateVMOpts, mc *vmconfigs.MachineConfig, _ *ignition.IgnitionBuilder) error
        + PrepareIgnition(_ *vmconfigs.MachineConfig, _ *ignition.IgnitionBuilder) (*ignition.ReadyUnitOpts, error)
        + Exists(name string) (bool, error)
        + MountType() vmconfigs.VolumeMountType
        + MountVolumesToVM(mc *vmconfigs.MachineConfig, quiet bool) error
        + Remove(mc *vmconfigs.MachineConfig) ([]string, <font color=blue>func</font>() error, error)
        + RemoveAndCleanMachines(_ *define.MachineDirs) error
        + SetProviderAttrs(mc *vmconfigs.MachineConfig, opts define.SetOptions) error
        + StartNetworking(mc *vmconfigs.MachineConfig, cmd *types.GvproxyCommand) error
        + UserModeNetworkEnabled(mc *vmconfigs.MachineConfig) bool
        + UseProviderNetworkSetup() bool
        + RequireExclusiveActive() bool
        + PostStartNetworking(mc *vmconfigs.MachineConfig, noInfo bool) error
        + StartVM(mc *vmconfigs.MachineConfig) (<font color=blue>func</font>() error, <font color=blue>func</font>() error, error)
        + State(mc *vmconfigs.MachineConfig, bypass bool) (define.Status, error)
        + StopVM(mc *vmconfigs.MachineConfig, hardStop bool) error
        + StopHostNetworking(mc *vmconfigs.MachineConfig, vmType define.VMType) error
        + UpdateSSHPort(mc *vmconfigs.MachineConfig, port int) error
        + VMType() define.VMType
        + GetRosetta(mc *vmconfigs.MachineConfig) (bool, error)

    }
    class WSLVirtualization << (S,Aquamarine) >> {
        + NewMachine(opts define.InitOptions) (machine.VM, error)
        + LoadVMByName(name string) (machine.VM, error)
        + List(_ machine.ListOptions) ([]*machine.ListResponse, error)
        + IsValidVMName(name string) (bool, error)
        + RemoveAndCleanMachines() error
        + VMType() define.VMType

    }
    class fileLock << (S,Aquamarine) >> {
    }
}
"vmconfigs.WSLConfig" *-- "extends""wsl.WSLStubber"
"machine.Virtualization" *-- "extends""wsl.WSLVirtualization"

"vmconfigs.VMProvider" <|-- "implements""wsl.WSLStubber"

hide fields
hide methods
@enduml
